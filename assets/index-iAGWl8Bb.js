(function () {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && r(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function r(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = n(i);
    fetch(i.href, s);
  }
})();
var Cu =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function Xc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default")
    ? e.default
    : e;
}
function R2(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r
        ? Reflect.construct(t, arguments, this.constructor)
        : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return (
    Object.defineProperty(n, "__esModule", { value: !0 }),
    Object.keys(e).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(
        n,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return e[r];
              },
            }
      );
    }),
    n
  );
}
var B2 = { exports: {} },
  bh = {},
  N2 = { exports: {} },
  _e = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var el = Symbol.for("react.element"),
  Pk = Symbol.for("react.portal"),
  Dk = Symbol.for("react.fragment"),
  Ok = Symbol.for("react.strict_mode"),
  Rk = Symbol.for("react.profiler"),
  Bk = Symbol.for("react.provider"),
  Nk = Symbol.for("react.context"),
  Mk = Symbol.for("react.forward_ref"),
  Lk = Symbol.for("react.suspense"),
  Fk = Symbol.for("react.memo"),
  jk = Symbol.for("react.lazy"),
  Lw = Symbol.iterator;
function Uk(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (Lw && e[Lw]) || e["@@iterator"]),
      typeof e == "function" ? e : null);
}
var M2 = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  L2 = Object.assign,
  F2 = {};
function Ba(e, t, n) {
  (this.props = e),
    (this.context = t),
    (this.refs = F2),
    (this.updater = n || M2);
}
Ba.prototype.isReactComponent = {};
Ba.prototype.setState = function (e, t) {
  if (typeof e != "object" && typeof e != "function" && e != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, e, t, "setState");
};
Ba.prototype.forceUpdate = function (e) {
  this.updater.enqueueForceUpdate(this, e, "forceUpdate");
};
function j2() {}
j2.prototype = Ba.prototype;
function zg(e, t, n) {
  (this.props = e),
    (this.context = t),
    (this.refs = F2),
    (this.updater = n || M2);
}
var Gg = (zg.prototype = new j2());
Gg.constructor = zg;
L2(Gg, Ba.prototype);
Gg.isPureReactComponent = !0;
var Fw = Array.isArray,
  U2 = Object.prototype.hasOwnProperty,
  qg = { current: null },
  $2 = { key: !0, ref: !0, __self: !0, __source: !0 };
function H2(e, t, n) {
  var r,
    i = {},
    s = null,
    o = null;
  if (t != null)
    for (r in (t.ref !== void 0 && (o = t.ref),
    t.key !== void 0 && (s = "" + t.key),
    t))
      U2.call(t, r) && !$2.hasOwnProperty(r) && (i[r] = t[r]);
  var a = arguments.length - 2;
  if (a === 1) i.children = n;
  else if (1 < a) {
    for (var u = Array(a), l = 0; l < a; l++) u[l] = arguments[l + 2];
    i.children = u;
  }
  if (e && e.defaultProps)
    for (r in ((a = e.defaultProps), a)) i[r] === void 0 && (i[r] = a[r]);
  return {
    $$typeof: el,
    type: e,
    key: s,
    ref: o,
    props: i,
    _owner: qg.current,
  };
}
function $k(e, t) {
  return {
    $$typeof: el,
    type: e.type,
    key: t,
    ref: e.ref,
    props: e.props,
    _owner: e._owner,
  };
}
function Wg(e) {
  return typeof e == "object" && e !== null && e.$$typeof === el;
}
function Hk(e) {
  var t = { "=": "=0", ":": "=2" };
  return (
    "$" +
    e.replace(/[=:]/g, function (n) {
      return t[n];
    })
  );
}
var jw = /\/+/g;
function Gp(e, t) {
  return typeof e == "object" && e !== null && e.key != null
    ? Hk("" + e.key)
    : t.toString(36);
}
function ad(e, t, n, r, i) {
  var s = typeof e;
  (s === "undefined" || s === "boolean") && (e = null);
  var o = !1;
  if (e === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (e.$$typeof) {
          case el:
          case Pk:
            o = !0;
        }
    }
  if (o)
    return (
      (o = e),
      (i = i(o)),
      (e = r === "" ? "." + Gp(o, 0) : r),
      Fw(i)
        ? ((n = ""),
          e != null && (n = e.replace(jw, "$&/") + "/"),
          ad(i, t, n, "", function (l) {
            return l;
          }))
        : i != null &&
          (Wg(i) &&
            (i = $k(
              i,
              n +
                (!i.key || (o && o.key === i.key)
                  ? ""
                  : ("" + i.key).replace(jw, "$&/") + "/") +
                e
            )),
          t.push(i)),
      1
    );
  if (((o = 0), (r = r === "" ? "." : r + ":"), Fw(e)))
    for (var a = 0; a < e.length; a++) {
      s = e[a];
      var u = r + Gp(s, a);
      o += ad(s, t, n, u, i);
    }
  else if (((u = Uk(e)), typeof u == "function"))
    for (e = u.call(e), a = 0; !(s = e.next()).done; )
      (s = s.value), (u = r + Gp(s, a++)), (o += ad(s, t, n, u, i));
  else if (s === "object")
    throw (
      ((t = String(e)),
      Error(
        "Objects are not valid as a React child (found: " +
          (t === "[object Object]"
            ? "object with keys {" + Object.keys(e).join(", ") + "}"
            : t) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function Tl(e, t, n) {
  if (e == null) return e;
  var r = [],
    i = 0;
  return (
    ad(e, r, "", "", function (s) {
      return t.call(n, s, i++);
    }),
    r
  );
}
function zk(e) {
  if (e._status === -1) {
    var t = e._result;
    (t = t()),
      t.then(
        function (n) {
          (e._status === 0 || e._status === -1) &&
            ((e._status = 1), (e._result = n));
        },
        function (n) {
          (e._status === 0 || e._status === -1) &&
            ((e._status = 2), (e._result = n));
        }
      ),
      e._status === -1 && ((e._status = 0), (e._result = t));
  }
  if (e._status === 1) return e._result.default;
  throw e._result;
}
var un = { current: null },
  ud = { transition: null },
  Gk = {
    ReactCurrentDispatcher: un,
    ReactCurrentBatchConfig: ud,
    ReactCurrentOwner: qg,
  };
_e.Children = {
  map: Tl,
  forEach: function (e, t, n) {
    Tl(
      e,
      function () {
        t.apply(this, arguments);
      },
      n
    );
  },
  count: function (e) {
    var t = 0;
    return (
      Tl(e, function () {
        t++;
      }),
      t
    );
  },
  toArray: function (e) {
    return (
      Tl(e, function (t) {
        return t;
      }) || []
    );
  },
  only: function (e) {
    if (!Wg(e))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return e;
  },
};
_e.Component = Ba;
_e.Fragment = Dk;
_e.Profiler = Rk;
_e.PureComponent = zg;
_e.StrictMode = Ok;
_e.Suspense = Lk;
_e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Gk;
_e.cloneElement = function (e, t, n) {
  if (e == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        e +
        "."
    );
  var r = L2({}, e.props),
    i = e.key,
    s = e.ref,
    o = e._owner;
  if (t != null) {
    if (
      (t.ref !== void 0 && ((s = t.ref), (o = qg.current)),
      t.key !== void 0 && (i = "" + t.key),
      e.type && e.type.defaultProps)
    )
      var a = e.type.defaultProps;
    for (u in t)
      U2.call(t, u) &&
        !$2.hasOwnProperty(u) &&
        (r[u] = t[u] === void 0 && a !== void 0 ? a[u] : t[u]);
  }
  var u = arguments.length - 2;
  if (u === 1) r.children = n;
  else if (1 < u) {
    a = Array(u);
    for (var l = 0; l < u; l++) a[l] = arguments[l + 2];
    r.children = a;
  }
  return { $$typeof: el, type: e.type, key: i, ref: s, props: r, _owner: o };
};
_e.createContext = function (e) {
  return (
    (e = {
      $$typeof: Nk,
      _currentValue: e,
      _currentValue2: e,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (e.Provider = { $$typeof: Bk, _context: e }),
    (e.Consumer = e)
  );
};
_e.createElement = H2;
_e.createFactory = function (e) {
  var t = H2.bind(null, e);
  return (t.type = e), t;
};
_e.createRef = function () {
  return { current: null };
};
_e.forwardRef = function (e) {
  return { $$typeof: Mk, render: e };
};
_e.isValidElement = Wg;
_e.lazy = function (e) {
  return { $$typeof: jk, _payload: { _status: -1, _result: e }, _init: zk };
};
_e.memo = function (e, t) {
  return { $$typeof: Fk, type: e, compare: t === void 0 ? null : t };
};
_e.startTransition = function (e) {
  var t = ud.transition;
  ud.transition = {};
  try {
    e();
  } finally {
    ud.transition = t;
  }
};
_e.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
_e.useCallback = function (e, t) {
  return un.current.useCallback(e, t);
};
_e.useContext = function (e) {
  return un.current.useContext(e);
};
_e.useDebugValue = function () {};
_e.useDeferredValue = function (e) {
  return un.current.useDeferredValue(e);
};
_e.useEffect = function (e, t) {
  return un.current.useEffect(e, t);
};
_e.useId = function () {
  return un.current.useId();
};
_e.useImperativeHandle = function (e, t, n) {
  return un.current.useImperativeHandle(e, t, n);
};
_e.useInsertionEffect = function (e, t) {
  return un.current.useInsertionEffect(e, t);
};
_e.useLayoutEffect = function (e, t) {
  return un.current.useLayoutEffect(e, t);
};
_e.useMemo = function (e, t) {
  return un.current.useMemo(e, t);
};
_e.useReducer = function (e, t, n) {
  return un.current.useReducer(e, t, n);
};
_e.useRef = function (e) {
  return un.current.useRef(e);
};
_e.useState = function (e) {
  return un.current.useState(e);
};
_e.useSyncExternalStore = function (e, t, n) {
  return un.current.useSyncExternalStore(e, t, n);
};
_e.useTransition = function () {
  return un.current.useTransition();
};
_e.version = "18.2.0";
N2.exports = _e;
var G = N2.exports;
const Me = Xc(G);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var qk = G,
  Wk = Symbol.for("react.element"),
  Qk = Symbol.for("react.fragment"),
  Vk = Object.prototype.hasOwnProperty,
  Kk = qk.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  Zk = { key: !0, ref: !0, __self: !0, __source: !0 };
function z2(e, t, n) {
  var r,
    i = {},
    s = null,
    o = null;
  n !== void 0 && (s = "" + n),
    t.key !== void 0 && (s = "" + t.key),
    t.ref !== void 0 && (o = t.ref);
  for (r in t) Vk.call(t, r) && !Zk.hasOwnProperty(r) && (i[r] = t[r]);
  if (e && e.defaultProps)
    for (r in ((t = e.defaultProps), t)) i[r] === void 0 && (i[r] = t[r]);
  return {
    $$typeof: Wk,
    type: e,
    key: s,
    ref: o,
    props: i,
    _owner: Kk.current,
  };
}
bh.Fragment = Qk;
bh.jsx = z2;
bh.jsxs = z2;
B2.exports = bh;
var X = B2.exports,
  l0 = {},
  G2 = { exports: {} },
  Rn = {},
  q2 = { exports: {} },
  W2 = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (e) {
  function t(P, B) {
    var L = P.length;
    P.push(B);
    e: for (; 0 < L; ) {
      var Q = (L - 1) >>> 1,
        z = P[Q];
      if (0 < i(z, B)) (P[Q] = B), (P[L] = z), (L = Q);
      else break e;
    }
  }
  function n(P) {
    return P.length === 0 ? null : P[0];
  }
  function r(P) {
    if (P.length === 0) return null;
    var B = P[0],
      L = P.pop();
    if (L !== B) {
      P[0] = L;
      e: for (var Q = 0, z = P.length, j = z >>> 1; Q < j; ) {
        var W = 2 * (Q + 1) - 1,
          ee = P[W],
          Z = W + 1,
          ne = P[Z];
        if (0 > i(ee, L))
          Z < z && 0 > i(ne, ee)
            ? ((P[Q] = ne), (P[Z] = L), (Q = Z))
            : ((P[Q] = ee), (P[W] = L), (Q = W));
        else if (Z < z && 0 > i(ne, L)) (P[Q] = ne), (P[Z] = L), (Q = Z);
        else break e;
      }
    }
    return B;
  }
  function i(P, B) {
    var L = P.sortIndex - B.sortIndex;
    return L !== 0 ? L : P.id - B.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    e.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    e.unstable_now = function () {
      return o.now() - a;
    };
  }
  var u = [],
    l = [],
    c = 1,
    d = null,
    f = 3,
    p = !1,
    m = !1,
    g = !1,
    w = typeof setTimeout == "function" ? setTimeout : null,
    v = typeof clearTimeout == "function" ? clearTimeout : null,
    y = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function b(P) {
    for (var B = n(l); B !== null; ) {
      if (B.callback === null) r(l);
      else if (B.startTime <= P)
        r(l), (B.sortIndex = B.expirationTime), t(u, B);
      else break;
      B = n(l);
    }
  }
  function _(P) {
    if (((g = !1), b(P), !m))
      if (n(u) !== null) (m = !0), T(A);
      else {
        var B = n(l);
        B !== null && D(_, B.startTime - P);
      }
  }
  function A(P, B) {
    (m = !1), g && ((g = !1), v(E), (E = -1)), (p = !0);
    var L = f;
    try {
      for (
        b(B), d = n(u);
        d !== null && (!(d.expirationTime > B) || (P && !k()));

      ) {
        var Q = d.callback;
        if (typeof Q == "function") {
          (d.callback = null), (f = d.priorityLevel);
          var z = Q(d.expirationTime <= B);
          (B = e.unstable_now()),
            typeof z == "function" ? (d.callback = z) : d === n(u) && r(u),
            b(B);
        } else r(u);
        d = n(u);
      }
      if (d !== null) var j = !0;
      else {
        var W = n(l);
        W !== null && D(_, W.startTime - B), (j = !1);
      }
      return j;
    } finally {
      (d = null), (f = L), (p = !1);
    }
  }
  var x = !1,
    h = null,
    E = -1,
    I = 5,
    C = -1;
  function k() {
    return !(e.unstable_now() - C < I);
  }
  function O() {
    if (h !== null) {
      var P = e.unstable_now();
      C = P;
      var B = !0;
      try {
        B = h(!0, P);
      } finally {
        B ? R() : ((x = !1), (h = null));
      }
    } else x = !1;
  }
  var R;
  if (typeof y == "function")
    R = function () {
      y(O);
    };
  else if (typeof MessageChannel < "u") {
    var N = new MessageChannel(),
      S = N.port2;
    (N.port1.onmessage = O),
      (R = function () {
        S.postMessage(null);
      });
  } else
    R = function () {
      w(O, 0);
    };
  function T(P) {
    (h = P), x || ((x = !0), R());
  }
  function D(P, B) {
    E = w(function () {
      P(e.unstable_now());
    }, B);
  }
  (e.unstable_IdlePriority = 5),
    (e.unstable_ImmediatePriority = 1),
    (e.unstable_LowPriority = 4),
    (e.unstable_NormalPriority = 3),
    (e.unstable_Profiling = null),
    (e.unstable_UserBlockingPriority = 2),
    (e.unstable_cancelCallback = function (P) {
      P.callback = null;
    }),
    (e.unstable_continueExecution = function () {
      m || p || ((m = !0), T(A));
    }),
    (e.unstable_forceFrameRate = function (P) {
      0 > P || 125 < P
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (I = 0 < P ? Math.floor(1e3 / P) : 5);
    }),
    (e.unstable_getCurrentPriorityLevel = function () {
      return f;
    }),
    (e.unstable_getFirstCallbackNode = function () {
      return n(u);
    }),
    (e.unstable_next = function (P) {
      switch (f) {
        case 1:
        case 2:
        case 3:
          var B = 3;
          break;
        default:
          B = f;
      }
      var L = f;
      f = B;
      try {
        return P();
      } finally {
        f = L;
      }
    }),
    (e.unstable_pauseExecution = function () {}),
    (e.unstable_requestPaint = function () {}),
    (e.unstable_runWithPriority = function (P, B) {
      switch (P) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          P = 3;
      }
      var L = f;
      f = P;
      try {
        return B();
      } finally {
        f = L;
      }
    }),
    (e.unstable_scheduleCallback = function (P, B, L) {
      var Q = e.unstable_now();
      switch (
        (typeof L == "object" && L !== null
          ? ((L = L.delay), (L = typeof L == "number" && 0 < L ? Q + L : Q))
          : (L = Q),
        P)
      ) {
        case 1:
          var z = -1;
          break;
        case 2:
          z = 250;
          break;
        case 5:
          z = 1073741823;
          break;
        case 4:
          z = 1e4;
          break;
        default:
          z = 5e3;
      }
      return (
        (z = L + z),
        (P = {
          id: c++,
          callback: B,
          priorityLevel: P,
          startTime: L,
          expirationTime: z,
          sortIndex: -1,
        }),
        L > Q
          ? ((P.sortIndex = L),
            t(l, P),
            n(u) === null &&
              P === n(l) &&
              (g ? (v(E), (E = -1)) : (g = !0), D(_, L - Q)))
          : ((P.sortIndex = z), t(u, P), m || p || ((m = !0), T(A))),
        P
      );
    }),
    (e.unstable_shouldYield = k),
    (e.unstable_wrapCallback = function (P) {
      var B = f;
      return function () {
        var L = f;
        f = B;
        try {
          return P.apply(this, arguments);
        } finally {
          f = L;
        }
      };
    });
})(W2);
q2.exports = W2;
var Jk = q2.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Q2 = G,
  Pn = Jk;
function U(e) {
  for (
    var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1;
    n < arguments.length;
    n++
  )
    t += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    e +
    "; visit " +
    t +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var V2 = new Set(),
  qu = {};
function ho(e, t) {
  la(e, t), la(e + "Capture", t);
}
function la(e, t) {
  for (qu[e] = t, e = 0; e < t.length; e++) V2.add(t[e]);
}
var ai = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  d0 = Object.prototype.hasOwnProperty,
  Yk =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  Uw = {},
  $w = {};
function Xk(e) {
  return d0.call($w, e)
    ? !0
    : d0.call(Uw, e)
    ? !1
    : Yk.test(e)
    ? ($w[e] = !0)
    : ((Uw[e] = !0), !1);
}
function eP(e, t, n, r) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof t) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return r
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((e = e.toLowerCase().slice(0, 5)), e !== "data-" && e !== "aria-");
    default:
      return !1;
  }
}
function tP(e, t, n, r) {
  if (t === null || typeof t > "u" || eP(e, t, n, r)) return !0;
  if (r) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !t;
      case 4:
        return t === !1;
      case 5:
        return isNaN(t);
      case 6:
        return isNaN(t) || 1 > t;
    }
  return !1;
}
function cn(e, t, n, r, i, s, o) {
  (this.acceptsBooleans = t === 2 || t === 3 || t === 4),
    (this.attributeName = r),
    (this.attributeNamespace = i),
    (this.mustUseProperty = n),
    (this.propertyName = e),
    (this.type = t),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var St = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (e) {
    St[e] = new cn(e, 0, !1, e, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (e) {
  var t = e[0];
  St[t] = new cn(t, 1, !1, e[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) {
  St[e] = new cn(e, 2, !1, e.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (e) {
  St[e] = new cn(e, 2, !1, e, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (e) {
    St[e] = new cn(e, 3, !1, e.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (e) {
  St[e] = new cn(e, 3, !0, e, null, !1, !1);
});
["capture", "download"].forEach(function (e) {
  St[e] = new cn(e, 4, !1, e, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (e) {
  St[e] = new cn(e, 6, !1, e, null, !1, !1);
});
["rowSpan", "start"].forEach(function (e) {
  St[e] = new cn(e, 5, !1, e.toLowerCase(), null, !1, !1);
});
var Qg = /[\-:]([a-z])/g;
function Vg(e) {
  return e[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(Qg, Vg);
    St[t] = new cn(t, 1, !1, e, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (e) {
    var t = e.replace(Qg, Vg);
    St[t] = new cn(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (e) {
  var t = e.replace(Qg, Vg);
  St[t] = new cn(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (e) {
  St[e] = new cn(e, 1, !1, e.toLowerCase(), null, !1, !1);
});
St.xlinkHref = new cn(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (e) {
  St[e] = new cn(e, 1, !1, e.toLowerCase(), null, !0, !0);
});
function Kg(e, t, n, r) {
  var i = St.hasOwnProperty(t) ? St[t] : null;
  (i !== null
    ? i.type !== 0
    : r ||
      !(2 < t.length) ||
      (t[0] !== "o" && t[0] !== "O") ||
      (t[1] !== "n" && t[1] !== "N")) &&
    (tP(t, n, i, r) && (n = null),
    r || i === null
      ? Xk(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n))
      : i.mustUseProperty
      ? (e[i.propertyName] = n === null ? (i.type === 3 ? !1 : "") : n)
      : ((t = i.attributeName),
        (r = i.attributeNamespace),
        n === null
          ? e.removeAttribute(t)
          : ((i = i.type),
            (n = i === 3 || (i === 4 && n === !0) ? "" : "" + n),
            r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))));
}
var yi = Q2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Il = Symbol.for("react.element"),
  Bo = Symbol.for("react.portal"),
  No = Symbol.for("react.fragment"),
  Zg = Symbol.for("react.strict_mode"),
  f0 = Symbol.for("react.profiler"),
  K2 = Symbol.for("react.provider"),
  Z2 = Symbol.for("react.context"),
  Jg = Symbol.for("react.forward_ref"),
  h0 = Symbol.for("react.suspense"),
  p0 = Symbol.for("react.suspense_list"),
  Yg = Symbol.for("react.memo"),
  Di = Symbol.for("react.lazy"),
  J2 = Symbol.for("react.offscreen"),
  Hw = Symbol.iterator;
function Ka(e) {
  return e === null || typeof e != "object"
    ? null
    : ((e = (Hw && e[Hw]) || e["@@iterator"]),
      typeof e == "function" ? e : null);
}
var tt = Object.assign,
  qp;
function mu(e) {
  if (qp === void 0)
    try {
      throw Error();
    } catch (n) {
      var t = n.stack.trim().match(/\n( *(at )?)/);
      qp = (t && t[1]) || "";
    }
  return (
    `
` +
    qp +
    e
  );
}
var Wp = !1;
function Qp(e, t) {
  if (!e || Wp) return "";
  Wp = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (t)
      if (
        ((t = function () {
          throw Error();
        }),
        Object.defineProperty(t.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(t, []);
        } catch (l) {
          var r = l;
        }
        Reflect.construct(e, [], t);
      } else {
        try {
          t.call();
        } catch (l) {
          r = l;
        }
        e.call(t.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l) {
        r = l;
      }
      e();
    }
  } catch (l) {
    if (l && r && typeof l.stack == "string") {
      for (
        var i = l.stack.split(`
`),
          s = r.stack.split(`
`),
          o = i.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && i[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (i[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || i[o] !== s[a])) {
                var u =
                  `
` + i[o].replace(" at new ", " at ");
                return (
                  e.displayName &&
                    u.includes("<anonymous>") &&
                    (u = u.replace("<anonymous>", e.displayName)),
                  u
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (Wp = !1), (Error.prepareStackTrace = n);
  }
  return (e = e ? e.displayName || e.name : "") ? mu(e) : "";
}
function nP(e) {
  switch (e.tag) {
    case 5:
      return mu(e.type);
    case 16:
      return mu("Lazy");
    case 13:
      return mu("Suspense");
    case 19:
      return mu("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (e = Qp(e.type, !1)), e;
    case 11:
      return (e = Qp(e.type.render, !1)), e;
    case 1:
      return (e = Qp(e.type, !0)), e;
    default:
      return "";
  }
}
function m0(e) {
  if (e == null) return null;
  if (typeof e == "function") return e.displayName || e.name || null;
  if (typeof e == "string") return e;
  switch (e) {
    case No:
      return "Fragment";
    case Bo:
      return "Portal";
    case f0:
      return "Profiler";
    case Zg:
      return "StrictMode";
    case h0:
      return "Suspense";
    case p0:
      return "SuspenseList";
  }
  if (typeof e == "object")
    switch (e.$$typeof) {
      case Z2:
        return (e.displayName || "Context") + ".Consumer";
      case K2:
        return (e._context.displayName || "Context") + ".Provider";
      case Jg:
        var t = e.render;
        return (
          (e = e.displayName),
          e ||
            ((e = t.displayName || t.name || ""),
            (e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")),
          e
        );
      case Yg:
        return (
          (t = e.displayName || null), t !== null ? t : m0(e.type) || "Memo"
        );
      case Di:
        (t = e._payload), (e = e._init);
        try {
          return m0(e(t));
        } catch {}
    }
  return null;
}
function rP(e) {
  var t = e.type;
  switch (e.tag) {
    case 24:
      return "Cache";
    case 9:
      return (t.displayName || "Context") + ".Consumer";
    case 10:
      return (t._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (e = t.render),
        (e = e.displayName || e.name || ""),
        t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return t;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return m0(t);
    case 8:
      return t === Zg ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof t == "function") return t.displayName || t.name || null;
      if (typeof t == "string") return t;
  }
  return null;
}
function Xi(e) {
  switch (typeof e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return e;
    case "object":
      return e;
    default:
      return "";
  }
}
function Y2(e) {
  var t = e.type;
  return (
    (e = e.nodeName) &&
    e.toLowerCase() === "input" &&
    (t === "checkbox" || t === "radio")
  );
}
function iP(e) {
  var t = Y2(e) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
    r = "" + e[t];
  if (
    !e.hasOwnProperty(t) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var i = n.get,
      s = n.set;
    return (
      Object.defineProperty(e, t, {
        configurable: !0,
        get: function () {
          return i.call(this);
        },
        set: function (o) {
          (r = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(e, t, { enumerable: n.enumerable }),
      {
        getValue: function () {
          return r;
        },
        setValue: function (o) {
          r = "" + o;
        },
        stopTracking: function () {
          (e._valueTracker = null), delete e[t];
        },
      }
    );
  }
}
function kl(e) {
  e._valueTracker || (e._valueTracker = iP(e));
}
function X2(e) {
  if (!e) return !1;
  var t = e._valueTracker;
  if (!t) return !0;
  var n = t.getValue(),
    r = "";
  return (
    e && (r = Y2(e) ? (e.checked ? "true" : "false") : e.value),
    (e = r),
    e !== n ? (t.setValue(e), !0) : !1
  );
}
function jd(e) {
  if (((e = e || (typeof document < "u" ? document : void 0)), typeof e > "u"))
    return null;
  try {
    return e.activeElement || e.body;
  } catch {
    return e.body;
  }
}
function y0(e, t) {
  var n = t.checked;
  return tt({}, t, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? e._wrapperState.initialChecked,
  });
}
function zw(e, t) {
  var n = t.defaultValue == null ? "" : t.defaultValue,
    r = t.checked != null ? t.checked : t.defaultChecked;
  (n = Xi(t.value != null ? t.value : n)),
    (e._wrapperState = {
      initialChecked: r,
      initialValue: n,
      controlled:
        t.type === "checkbox" || t.type === "radio"
          ? t.checked != null
          : t.value != null,
    });
}
function eA(e, t) {
  (t = t.checked), t != null && Kg(e, "checked", t, !1);
}
function g0(e, t) {
  eA(e, t);
  var n = Xi(t.value),
    r = t.type;
  if (n != null)
    r === "number"
      ? ((n === 0 && e.value === "") || e.value != n) && (e.value = "" + n)
      : e.value !== "" + n && (e.value = "" + n);
  else if (r === "submit" || r === "reset") {
    e.removeAttribute("value");
    return;
  }
  t.hasOwnProperty("value")
    ? v0(e, t.type, n)
    : t.hasOwnProperty("defaultValue") && v0(e, t.type, Xi(t.defaultValue)),
    t.checked == null &&
      t.defaultChecked != null &&
      (e.defaultChecked = !!t.defaultChecked);
}
function Gw(e, t, n) {
  if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
    var r = t.type;
    if (
      !(
        (r !== "submit" && r !== "reset") ||
        (t.value !== void 0 && t.value !== null)
      )
    )
      return;
    (t = "" + e._wrapperState.initialValue),
      n || t === e.value || (e.value = t),
      (e.defaultValue = t);
  }
  (n = e.name),
    n !== "" && (e.name = ""),
    (e.defaultChecked = !!e._wrapperState.initialChecked),
    n !== "" && (e.name = n);
}
function v0(e, t, n) {
  (t !== "number" || jd(e.ownerDocument) !== e) &&
    (n == null
      ? (e.defaultValue = "" + e._wrapperState.initialValue)
      : e.defaultValue !== "" + n && (e.defaultValue = "" + n));
}
var yu = Array.isArray;
function Zo(e, t, n, r) {
  if (((e = e.options), t)) {
    t = {};
    for (var i = 0; i < n.length; i++) t["$" + n[i]] = !0;
    for (n = 0; n < e.length; n++)
      (i = t.hasOwnProperty("$" + e[n].value)),
        e[n].selected !== i && (e[n].selected = i),
        i && r && (e[n].defaultSelected = !0);
  } else {
    for (n = "" + Xi(n), t = null, i = 0; i < e.length; i++) {
      if (e[i].value === n) {
        (e[i].selected = !0), r && (e[i].defaultSelected = !0);
        return;
      }
      t !== null || e[i].disabled || (t = e[i]);
    }
    t !== null && (t.selected = !0);
  }
}
function b0(e, t) {
  if (t.dangerouslySetInnerHTML != null) throw Error(U(91));
  return tt({}, t, {
    value: void 0,
    defaultValue: void 0,
    children: "" + e._wrapperState.initialValue,
  });
}
function qw(e, t) {
  var n = t.value;
  if (n == null) {
    if (((n = t.children), (t = t.defaultValue), n != null)) {
      if (t != null) throw Error(U(92));
      if (yu(n)) {
        if (1 < n.length) throw Error(U(93));
        n = n[0];
      }
      t = n;
    }
    t == null && (t = ""), (n = t);
  }
  e._wrapperState = { initialValue: Xi(n) };
}
function tA(e, t) {
  var n = Xi(t.value),
    r = Xi(t.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== e.value && (e.value = n),
    t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)),
    r != null && (e.defaultValue = "" + r);
}
function Ww(e) {
  var t = e.textContent;
  t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t);
}
function nA(e) {
  switch (e) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function w0(e, t) {
  return e == null || e === "http://www.w3.org/1999/xhtml"
    ? nA(t)
    : e === "http://www.w3.org/2000/svg" && t === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : e;
}
var Pl,
  rA = (function (e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (t, n, r, i) {
          MSApp.execUnsafeLocalFunction(function () {
            return e(t, n, r, i);
          });
        }
      : e;
  })(function (e, t) {
    if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e)
      e.innerHTML = t;
    else {
      for (
        Pl = Pl || document.createElement("div"),
          Pl.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>",
          t = Pl.firstChild;
        e.firstChild;

      )
        e.removeChild(e.firstChild);
      for (; t.firstChild; ) e.appendChild(t.firstChild);
    }
  });
function Wu(e, t) {
  if (t) {
    var n = e.firstChild;
    if (n && n === e.lastChild && n.nodeType === 3) {
      n.nodeValue = t;
      return;
    }
  }
  e.textContent = t;
}
var Tu = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  sP = ["Webkit", "ms", "Moz", "O"];
Object.keys(Tu).forEach(function (e) {
  sP.forEach(function (t) {
    (t = t + e.charAt(0).toUpperCase() + e.substring(1)), (Tu[t] = Tu[e]);
  });
});
function iA(e, t, n) {
  return t == null || typeof t == "boolean" || t === ""
    ? ""
    : n || typeof t != "number" || t === 0 || (Tu.hasOwnProperty(e) && Tu[e])
    ? ("" + t).trim()
    : t + "px";
}
function sA(e, t) {
  e = e.style;
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var r = n.indexOf("--") === 0,
        i = iA(n, t[n], r);
      n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : (e[n] = i);
    }
}
var oP = tt(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function E0(e, t) {
  if (t) {
    if (oP[e] && (t.children != null || t.dangerouslySetInnerHTML != null))
      throw Error(U(137, e));
    if (t.dangerouslySetInnerHTML != null) {
      if (t.children != null) throw Error(U(60));
      if (
        typeof t.dangerouslySetInnerHTML != "object" ||
        !("__html" in t.dangerouslySetInnerHTML)
      )
        throw Error(U(61));
    }
    if (t.style != null && typeof t.style != "object") throw Error(U(62));
  }
}
function _0(e, t) {
  if (e.indexOf("-") === -1) return typeof t.is == "string";
  switch (e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var A0 = null;
function Xg(e) {
  return (
    (e = e.target || e.srcElement || window),
    e.correspondingUseElement && (e = e.correspondingUseElement),
    e.nodeType === 3 ? e.parentNode : e
  );
}
var x0 = null,
  Jo = null,
  Yo = null;
function Qw(e) {
  if ((e = rl(e))) {
    if (typeof x0 != "function") throw Error(U(280));
    var t = e.stateNode;
    t && ((t = xh(t)), x0(e.stateNode, e.type, t));
  }
}
function oA(e) {
  Jo ? (Yo ? Yo.push(e) : (Yo = [e])) : (Jo = e);
}
function aA() {
  if (Jo) {
    var e = Jo,
      t = Yo;
    if (((Yo = Jo = null), Qw(e), t)) for (e = 0; e < t.length; e++) Qw(t[e]);
  }
}
function uA(e, t) {
  return e(t);
}
function cA() {}
var Vp = !1;
function lA(e, t, n) {
  if (Vp) return e(t, n);
  Vp = !0;
  try {
    return uA(e, t, n);
  } finally {
    (Vp = !1), (Jo !== null || Yo !== null) && (cA(), aA());
  }
}
function Qu(e, t) {
  var n = e.stateNode;
  if (n === null) return null;
  var r = xh(n);
  if (r === null) return null;
  n = r[t];
  e: switch (t) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (r = !r.disabled) ||
        ((e = e.type),
        (r = !(
          e === "button" ||
          e === "input" ||
          e === "select" ||
          e === "textarea"
        ))),
        (e = !r);
      break e;
    default:
      e = !1;
  }
  if (e) return null;
  if (n && typeof n != "function") throw Error(U(231, t, typeof n));
  return n;
}
var S0 = !1;
if (ai)
  try {
    var Za = {};
    Object.defineProperty(Za, "passive", {
      get: function () {
        S0 = !0;
      },
    }),
      window.addEventListener("test", Za, Za),
      window.removeEventListener("test", Za, Za);
  } catch {
    S0 = !1;
  }
function aP(e, t, n, r, i, s, o, a, u) {
  var l = Array.prototype.slice.call(arguments, 3);
  try {
    t.apply(n, l);
  } catch (c) {
    this.onError(c);
  }
}
var Iu = !1,
  Ud = null,
  $d = !1,
  C0 = null,
  uP = {
    onError: function (e) {
      (Iu = !0), (Ud = e);
    },
  };
function cP(e, t, n, r, i, s, o, a, u) {
  (Iu = !1), (Ud = null), aP.apply(uP, arguments);
}
function lP(e, t, n, r, i, s, o, a, u) {
  if ((cP.apply(this, arguments), Iu)) {
    if (Iu) {
      var l = Ud;
      (Iu = !1), (Ud = null);
    } else throw Error(U(198));
    $d || (($d = !0), (C0 = l));
  }
}
function po(e) {
  var t = e,
    n = e;
  if (e.alternate) for (; t.return; ) t = t.return;
  else {
    e = t;
    do (t = e), t.flags & 4098 && (n = t.return), (e = t.return);
    while (e);
  }
  return t.tag === 3 ? n : null;
}
function dA(e) {
  if (e.tag === 13) {
    var t = e.memoizedState;
    if (
      (t === null && ((e = e.alternate), e !== null && (t = e.memoizedState)),
      t !== null)
    )
      return t.dehydrated;
  }
  return null;
}
function Vw(e) {
  if (po(e) !== e) throw Error(U(188));
}
function dP(e) {
  var t = e.alternate;
  if (!t) {
    if (((t = po(e)), t === null)) throw Error(U(188));
    return t !== e ? null : e;
  }
  for (var n = e, r = t; ; ) {
    var i = n.return;
    if (i === null) break;
    var s = i.alternate;
    if (s === null) {
      if (((r = i.return), r !== null)) {
        n = r;
        continue;
      }
      break;
    }
    if (i.child === s.child) {
      for (s = i.child; s; ) {
        if (s === n) return Vw(i), e;
        if (s === r) return Vw(i), t;
        s = s.sibling;
      }
      throw Error(U(188));
    }
    if (n.return !== r.return) (n = i), (r = s);
    else {
      for (var o = !1, a = i.child; a; ) {
        if (a === n) {
          (o = !0), (n = i), (r = s);
          break;
        }
        if (a === r) {
          (o = !0), (r = i), (n = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === n) {
            (o = !0), (n = s), (r = i);
            break;
          }
          if (a === r) {
            (o = !0), (r = s), (n = i);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(U(189));
      }
    }
    if (n.alternate !== r) throw Error(U(190));
  }
  if (n.tag !== 3) throw Error(U(188));
  return n.stateNode.current === n ? e : t;
}
function fA(e) {
  return (e = dP(e)), e !== null ? hA(e) : null;
}
function hA(e) {
  if (e.tag === 5 || e.tag === 6) return e;
  for (e = e.child; e !== null; ) {
    var t = hA(e);
    if (t !== null) return t;
    e = e.sibling;
  }
  return null;
}
var pA = Pn.unstable_scheduleCallback,
  Kw = Pn.unstable_cancelCallback,
  fP = Pn.unstable_shouldYield,
  hP = Pn.unstable_requestPaint,
  st = Pn.unstable_now,
  pP = Pn.unstable_getCurrentPriorityLevel,
  ev = Pn.unstable_ImmediatePriority,
  mA = Pn.unstable_UserBlockingPriority,
  Hd = Pn.unstable_NormalPriority,
  mP = Pn.unstable_LowPriority,
  yA = Pn.unstable_IdlePriority,
  wh = null,
  kr = null;
function yP(e) {
  if (kr && typeof kr.onCommitFiberRoot == "function")
    try {
      kr.onCommitFiberRoot(wh, e, void 0, (e.current.flags & 128) === 128);
    } catch {}
}
var cr = Math.clz32 ? Math.clz32 : bP,
  gP = Math.log,
  vP = Math.LN2;
function bP(e) {
  return (e >>>= 0), e === 0 ? 32 : (31 - ((gP(e) / vP) | 0)) | 0;
}
var Dl = 64,
  Ol = 4194304;
function gu(e) {
  switch (e & -e) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return e & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return e;
  }
}
function zd(e, t) {
  var n = e.pendingLanes;
  if (n === 0) return 0;
  var r = 0,
    i = e.suspendedLanes,
    s = e.pingedLanes,
    o = n & 268435455;
  if (o !== 0) {
    var a = o & ~i;
    a !== 0 ? (r = gu(a)) : ((s &= o), s !== 0 && (r = gu(s)));
  } else (o = n & ~i), o !== 0 ? (r = gu(o)) : s !== 0 && (r = gu(s));
  if (r === 0) return 0;
  if (
    t !== 0 &&
    t !== r &&
    !(t & i) &&
    ((i = r & -r), (s = t & -t), i >= s || (i === 16 && (s & 4194240) !== 0))
  )
    return t;
  if ((r & 4 && (r |= n & 16), (t = e.entangledLanes), t !== 0))
    for (e = e.entanglements, t &= r; 0 < t; )
      (n = 31 - cr(t)), (i = 1 << n), (r |= e[n]), (t &= ~i);
  return r;
}
function wP(e, t) {
  switch (e) {
    case 1:
    case 2:
    case 4:
      return t + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function EP(e, t) {
  for (
    var n = e.suspendedLanes,
      r = e.pingedLanes,
      i = e.expirationTimes,
      s = e.pendingLanes;
    0 < s;

  ) {
    var o = 31 - cr(s),
      a = 1 << o,
      u = i[o];
    u === -1
      ? (!(a & n) || a & r) && (i[o] = wP(a, t))
      : u <= t && (e.expiredLanes |= a),
      (s &= ~a);
  }
}
function T0(e) {
  return (
    (e = e.pendingLanes & -1073741825),
    e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
  );
}
function gA() {
  var e = Dl;
  return (Dl <<= 1), !(Dl & 4194240) && (Dl = 64), e;
}
function Kp(e) {
  for (var t = [], n = 0; 31 > n; n++) t.push(e);
  return t;
}
function tl(e, t, n) {
  (e.pendingLanes |= t),
    t !== 536870912 && ((e.suspendedLanes = 0), (e.pingedLanes = 0)),
    (e = e.eventTimes),
    (t = 31 - cr(t)),
    (e[t] = n);
}
function _P(e, t) {
  var n = e.pendingLanes & ~t;
  (e.pendingLanes = t),
    (e.suspendedLanes = 0),
    (e.pingedLanes = 0),
    (e.expiredLanes &= t),
    (e.mutableReadLanes &= t),
    (e.entangledLanes &= t),
    (t = e.entanglements);
  var r = e.eventTimes;
  for (e = e.expirationTimes; 0 < n; ) {
    var i = 31 - cr(n),
      s = 1 << i;
    (t[i] = 0), (r[i] = -1), (e[i] = -1), (n &= ~s);
  }
}
function tv(e, t) {
  var n = (e.entangledLanes |= t);
  for (e = e.entanglements; n; ) {
    var r = 31 - cr(n),
      i = 1 << r;
    (i & t) | (e[r] & t) && (e[r] |= t), (n &= ~i);
  }
}
var Re = 0;
function vA(e) {
  return (e &= -e), 1 < e ? (4 < e ? (e & 268435455 ? 16 : 536870912) : 4) : 1;
}
var bA,
  nv,
  wA,
  EA,
  _A,
  I0 = !1,
  Rl = [],
  zi = null,
  Gi = null,
  qi = null,
  Vu = new Map(),
  Ku = new Map(),
  Ni = [],
  AP =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function Zw(e, t) {
  switch (e) {
    case "focusin":
    case "focusout":
      zi = null;
      break;
    case "dragenter":
    case "dragleave":
      Gi = null;
      break;
    case "mouseover":
    case "mouseout":
      qi = null;
      break;
    case "pointerover":
    case "pointerout":
      Vu.delete(t.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Ku.delete(t.pointerId);
  }
}
function Ja(e, t, n, r, i, s) {
  return e === null || e.nativeEvent !== s
    ? ((e = {
        blockedOn: t,
        domEventName: n,
        eventSystemFlags: r,
        nativeEvent: s,
        targetContainers: [i],
      }),
      t !== null && ((t = rl(t)), t !== null && nv(t)),
      e)
    : ((e.eventSystemFlags |= r),
      (t = e.targetContainers),
      i !== null && t.indexOf(i) === -1 && t.push(i),
      e);
}
function xP(e, t, n, r, i) {
  switch (t) {
    case "focusin":
      return (zi = Ja(zi, e, t, n, r, i)), !0;
    case "dragenter":
      return (Gi = Ja(Gi, e, t, n, r, i)), !0;
    case "mouseover":
      return (qi = Ja(qi, e, t, n, r, i)), !0;
    case "pointerover":
      var s = i.pointerId;
      return Vu.set(s, Ja(Vu.get(s) || null, e, t, n, r, i)), !0;
    case "gotpointercapture":
      return (
        (s = i.pointerId), Ku.set(s, Ja(Ku.get(s) || null, e, t, n, r, i)), !0
      );
  }
  return !1;
}
function AA(e) {
  var t = Ps(e.target);
  if (t !== null) {
    var n = po(t);
    if (n !== null) {
      if (((t = n.tag), t === 13)) {
        if (((t = dA(n)), t !== null)) {
          (e.blockedOn = t),
            _A(e.priority, function () {
              wA(n);
            });
          return;
        }
      } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  e.blockedOn = null;
}
function cd(e) {
  if (e.blockedOn !== null) return !1;
  for (var t = e.targetContainers; 0 < t.length; ) {
    var n = k0(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent);
    if (n === null) {
      n = e.nativeEvent;
      var r = new n.constructor(n.type, n);
      (A0 = r), n.target.dispatchEvent(r), (A0 = null);
    } else return (t = rl(n)), t !== null && nv(t), (e.blockedOn = n), !1;
    t.shift();
  }
  return !0;
}
function Jw(e, t, n) {
  cd(e) && n.delete(t);
}
function SP() {
  (I0 = !1),
    zi !== null && cd(zi) && (zi = null),
    Gi !== null && cd(Gi) && (Gi = null),
    qi !== null && cd(qi) && (qi = null),
    Vu.forEach(Jw),
    Ku.forEach(Jw);
}
function Ya(e, t) {
  e.blockedOn === t &&
    ((e.blockedOn = null),
    I0 ||
      ((I0 = !0),
      Pn.unstable_scheduleCallback(Pn.unstable_NormalPriority, SP)));
}
function Zu(e) {
  function t(i) {
    return Ya(i, e);
  }
  if (0 < Rl.length) {
    Ya(Rl[0], e);
    for (var n = 1; n < Rl.length; n++) {
      var r = Rl[n];
      r.blockedOn === e && (r.blockedOn = null);
    }
  }
  for (
    zi !== null && Ya(zi, e),
      Gi !== null && Ya(Gi, e),
      qi !== null && Ya(qi, e),
      Vu.forEach(t),
      Ku.forEach(t),
      n = 0;
    n < Ni.length;
    n++
  )
    (r = Ni[n]), r.blockedOn === e && (r.blockedOn = null);
  for (; 0 < Ni.length && ((n = Ni[0]), n.blockedOn === null); )
    AA(n), n.blockedOn === null && Ni.shift();
}
var Xo = yi.ReactCurrentBatchConfig,
  Gd = !0;
function CP(e, t, n, r) {
  var i = Re,
    s = Xo.transition;
  Xo.transition = null;
  try {
    (Re = 1), rv(e, t, n, r);
  } finally {
    (Re = i), (Xo.transition = s);
  }
}
function TP(e, t, n, r) {
  var i = Re,
    s = Xo.transition;
  Xo.transition = null;
  try {
    (Re = 4), rv(e, t, n, r);
  } finally {
    (Re = i), (Xo.transition = s);
  }
}
function rv(e, t, n, r) {
  if (Gd) {
    var i = k0(e, t, n, r);
    if (i === null) sm(e, t, r, qd, n), Zw(e, r);
    else if (xP(i, e, t, n, r)) r.stopPropagation();
    else if ((Zw(e, r), t & 4 && -1 < AP.indexOf(e))) {
      for (; i !== null; ) {
        var s = rl(i);
        if (
          (s !== null && bA(s),
          (s = k0(e, t, n, r)),
          s === null && sm(e, t, r, qd, n),
          s === i)
        )
          break;
        i = s;
      }
      i !== null && r.stopPropagation();
    } else sm(e, t, r, null, n);
  }
}
var qd = null;
function k0(e, t, n, r) {
  if (((qd = null), (e = Xg(r)), (e = Ps(e)), e !== null))
    if (((t = po(e)), t === null)) e = null;
    else if (((n = t.tag), n === 13)) {
      if (((e = dA(t)), e !== null)) return e;
      e = null;
    } else if (n === 3) {
      if (t.stateNode.current.memoizedState.isDehydrated)
        return t.tag === 3 ? t.stateNode.containerInfo : null;
      e = null;
    } else t !== e && (e = null);
  return (qd = e), null;
}
function xA(e) {
  switch (e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (pP()) {
        case ev:
          return 1;
        case mA:
          return 4;
        case Hd:
        case mP:
          return 16;
        case yA:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Fi = null,
  iv = null,
  ld = null;
function SA() {
  if (ld) return ld;
  var e,
    t = iv,
    n = t.length,
    r,
    i = "value" in Fi ? Fi.value : Fi.textContent,
    s = i.length;
  for (e = 0; e < n && t[e] === i[e]; e++);
  var o = n - e;
  for (r = 1; r <= o && t[n - r] === i[s - r]; r++);
  return (ld = i.slice(e, 1 < r ? 1 - r : void 0));
}
function dd(e) {
  var t = e.keyCode;
  return (
    "charCode" in e
      ? ((e = e.charCode), e === 0 && t === 13 && (e = 13))
      : (e = t),
    e === 10 && (e = 13),
    32 <= e || e === 13 ? e : 0
  );
}
function Bl() {
  return !0;
}
function Yw() {
  return !1;
}
function Bn(e) {
  function t(n, r, i, s, o) {
    (this._reactName = n),
      (this._targetInst = i),
      (this.type = r),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in e)
      e.hasOwnProperty(a) && ((n = e[a]), (this[a] = n ? n(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Bl
        : Yw),
      (this.isPropagationStopped = Yw),
      this
    );
  }
  return (
    tt(t.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = Bl));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = Bl));
      },
      persist: function () {},
      isPersistent: Bl,
    }),
    t
  );
}
var Na = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (e) {
      return e.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  sv = Bn(Na),
  nl = tt({}, Na, { view: 0, detail: 0 }),
  IP = Bn(nl),
  Zp,
  Jp,
  Xa,
  Eh = tt({}, nl, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: ov,
    button: 0,
    buttons: 0,
    relatedTarget: function (e) {
      return e.relatedTarget === void 0
        ? e.fromElement === e.srcElement
          ? e.toElement
          : e.fromElement
        : e.relatedTarget;
    },
    movementX: function (e) {
      return "movementX" in e
        ? e.movementX
        : (e !== Xa &&
            (Xa && e.type === "mousemove"
              ? ((Zp = e.screenX - Xa.screenX), (Jp = e.screenY - Xa.screenY))
              : (Jp = Zp = 0),
            (Xa = e)),
          Zp);
    },
    movementY: function (e) {
      return "movementY" in e ? e.movementY : Jp;
    },
  }),
  Xw = Bn(Eh),
  kP = tt({}, Eh, { dataTransfer: 0 }),
  PP = Bn(kP),
  DP = tt({}, nl, { relatedTarget: 0 }),
  Yp = Bn(DP),
  OP = tt({}, Na, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  RP = Bn(OP),
  BP = tt({}, Na, {
    clipboardData: function (e) {
      return "clipboardData" in e ? e.clipboardData : window.clipboardData;
    },
  }),
  NP = Bn(BP),
  MP = tt({}, Na, { data: 0 }),
  e1 = Bn(MP),
  LP = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  FP = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  jP = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function UP(e) {
  var t = this.nativeEvent;
  return t.getModifierState ? t.getModifierState(e) : (e = jP[e]) ? !!t[e] : !1;
}
function ov() {
  return UP;
}
var $P = tt({}, nl, {
    key: function (e) {
      if (e.key) {
        var t = LP[e.key] || e.key;
        if (t !== "Unidentified") return t;
      }
      return e.type === "keypress"
        ? ((e = dd(e)), e === 13 ? "Enter" : String.fromCharCode(e))
        : e.type === "keydown" || e.type === "keyup"
        ? FP[e.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: ov,
    charCode: function (e) {
      return e.type === "keypress" ? dd(e) : 0;
    },
    keyCode: function (e) {
      return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0;
    },
    which: function (e) {
      return e.type === "keypress"
        ? dd(e)
        : e.type === "keydown" || e.type === "keyup"
        ? e.keyCode
        : 0;
    },
  }),
  HP = Bn($P),
  zP = tt({}, Eh, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  t1 = Bn(zP),
  GP = tt({}, nl, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: ov,
  }),
  qP = Bn(GP),
  WP = tt({}, Na, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  QP = Bn(WP),
  VP = tt({}, Eh, {
    deltaX: function (e) {
      return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0;
    },
    deltaY: function (e) {
      return "deltaY" in e
        ? e.deltaY
        : "wheelDeltaY" in e
        ? -e.wheelDeltaY
        : "wheelDelta" in e
        ? -e.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  KP = Bn(VP),
  ZP = [9, 13, 27, 32],
  av = ai && "CompositionEvent" in window,
  ku = null;
ai && "documentMode" in document && (ku = document.documentMode);
var JP = ai && "TextEvent" in window && !ku,
  CA = ai && (!av || (ku && 8 < ku && 11 >= ku)),
  n1 = " ",
  r1 = !1;
function TA(e, t) {
  switch (e) {
    case "keyup":
      return ZP.indexOf(t.keyCode) !== -1;
    case "keydown":
      return t.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function IA(e) {
  return (e = e.detail), typeof e == "object" && "data" in e ? e.data : null;
}
var Mo = !1;
function YP(e, t) {
  switch (e) {
    case "compositionend":
      return IA(t);
    case "keypress":
      return t.which !== 32 ? null : ((r1 = !0), n1);
    case "textInput":
      return (e = t.data), e === n1 && r1 ? null : e;
    default:
      return null;
  }
}
function XP(e, t) {
  if (Mo)
    return e === "compositionend" || (!av && TA(e, t))
      ? ((e = SA()), (ld = iv = Fi = null), (Mo = !1), e)
      : null;
  switch (e) {
    case "paste":
      return null;
    case "keypress":
      if (!(t.ctrlKey || t.altKey || t.metaKey) || (t.ctrlKey && t.altKey)) {
        if (t.char && 1 < t.char.length) return t.char;
        if (t.which) return String.fromCharCode(t.which);
      }
      return null;
    case "compositionend":
      return CA && t.locale !== "ko" ? null : t.data;
    default:
      return null;
  }
}
var e6 = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function i1(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return t === "input" ? !!e6[e.type] : t === "textarea";
}
function kA(e, t, n, r) {
  oA(r),
    (t = Wd(t, "onChange")),
    0 < t.length &&
      ((n = new sv("onChange", "change", null, n, r)),
      e.push({ event: n, listeners: t }));
}
var Pu = null,
  Ju = null;
function t6(e) {
  UA(e, 0);
}
function _h(e) {
  var t = jo(e);
  if (X2(t)) return e;
}
function n6(e, t) {
  if (e === "change") return t;
}
var PA = !1;
if (ai) {
  var Xp;
  if (ai) {
    var em = "oninput" in document;
    if (!em) {
      var s1 = document.createElement("div");
      s1.setAttribute("oninput", "return;"),
        (em = typeof s1.oninput == "function");
    }
    Xp = em;
  } else Xp = !1;
  PA = Xp && (!document.documentMode || 9 < document.documentMode);
}
function o1() {
  Pu && (Pu.detachEvent("onpropertychange", DA), (Ju = Pu = null));
}
function DA(e) {
  if (e.propertyName === "value" && _h(Ju)) {
    var t = [];
    kA(t, Ju, e, Xg(e)), lA(t6, t);
  }
}
function r6(e, t, n) {
  e === "focusin"
    ? (o1(), (Pu = t), (Ju = n), Pu.attachEvent("onpropertychange", DA))
    : e === "focusout" && o1();
}
function i6(e) {
  if (e === "selectionchange" || e === "keyup" || e === "keydown")
    return _h(Ju);
}
function s6(e, t) {
  if (e === "click") return _h(t);
}
function o6(e, t) {
  if (e === "input" || e === "change") return _h(t);
}
function a6(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t);
}
var hr = typeof Object.is == "function" ? Object.is : a6;
function Yu(e, t) {
  if (hr(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  var n = Object.keys(e),
    r = Object.keys(t);
  if (n.length !== r.length) return !1;
  for (r = 0; r < n.length; r++) {
    var i = n[r];
    if (!d0.call(t, i) || !hr(e[i], t[i])) return !1;
  }
  return !0;
}
function a1(e) {
  for (; e && e.firstChild; ) e = e.firstChild;
  return e;
}
function u1(e, t) {
  var n = a1(e);
  e = 0;
  for (var r; n; ) {
    if (n.nodeType === 3) {
      if (((r = e + n.textContent.length), e <= t && r >= t))
        return { node: n, offset: t - e };
      e = r;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = a1(n);
  }
}
function OA(e, t) {
  return e && t
    ? e === t
      ? !0
      : e && e.nodeType === 3
      ? !1
      : t && t.nodeType === 3
      ? OA(e, t.parentNode)
      : "contains" in e
      ? e.contains(t)
      : e.compareDocumentPosition
      ? !!(e.compareDocumentPosition(t) & 16)
      : !1
    : !1;
}
function RA() {
  for (var e = window, t = jd(); t instanceof e.HTMLIFrameElement; ) {
    try {
      var n = typeof t.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) e = t.contentWindow;
    else break;
    t = jd(e.document);
  }
  return t;
}
function uv(e) {
  var t = e && e.nodeName && e.nodeName.toLowerCase();
  return (
    t &&
    ((t === "input" &&
      (e.type === "text" ||
        e.type === "search" ||
        e.type === "tel" ||
        e.type === "url" ||
        e.type === "password")) ||
      t === "textarea" ||
      e.contentEditable === "true")
  );
}
function u6(e) {
  var t = RA(),
    n = e.focusedElem,
    r = e.selectionRange;
  if (
    t !== n &&
    n &&
    n.ownerDocument &&
    OA(n.ownerDocument.documentElement, n)
  ) {
    if (r !== null && uv(n)) {
      if (
        ((t = r.start),
        (e = r.end),
        e === void 0 && (e = t),
        "selectionStart" in n)
      )
        (n.selectionStart = t), (n.selectionEnd = Math.min(e, n.value.length));
      else if (
        ((e = ((t = n.ownerDocument || document) && t.defaultView) || window),
        e.getSelection)
      ) {
        e = e.getSelection();
        var i = n.textContent.length,
          s = Math.min(r.start, i);
        (r = r.end === void 0 ? s : Math.min(r.end, i)),
          !e.extend && s > r && ((i = r), (r = s), (s = i)),
          (i = u1(n, s));
        var o = u1(n, r);
        i &&
          o &&
          (e.rangeCount !== 1 ||
            e.anchorNode !== i.node ||
            e.anchorOffset !== i.offset ||
            e.focusNode !== o.node ||
            e.focusOffset !== o.offset) &&
          ((t = t.createRange()),
          t.setStart(i.node, i.offset),
          e.removeAllRanges(),
          s > r
            ? (e.addRange(t), e.extend(o.node, o.offset))
            : (t.setEnd(o.node, o.offset), e.addRange(t)));
      }
    }
    for (t = [], e = n; (e = e.parentNode); )
      e.nodeType === 1 &&
        t.push({ element: e, left: e.scrollLeft, top: e.scrollTop });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)
      (e = t[n]),
        (e.element.scrollLeft = e.left),
        (e.element.scrollTop = e.top);
  }
}
var c6 = ai && "documentMode" in document && 11 >= document.documentMode,
  Lo = null,
  P0 = null,
  Du = null,
  D0 = !1;
function c1(e, t, n) {
  var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  D0 ||
    Lo == null ||
    Lo !== jd(r) ||
    ((r = Lo),
    "selectionStart" in r && uv(r)
      ? (r = { start: r.selectionStart, end: r.selectionEnd })
      : ((r = (
          (r.ownerDocument && r.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (r = {
          anchorNode: r.anchorNode,
          anchorOffset: r.anchorOffset,
          focusNode: r.focusNode,
          focusOffset: r.focusOffset,
        })),
    (Du && Yu(Du, r)) ||
      ((Du = r),
      (r = Wd(P0, "onSelect")),
      0 < r.length &&
        ((t = new sv("onSelect", "select", null, t, n)),
        e.push({ event: t, listeners: r }),
        (t.target = Lo))));
}
function Nl(e, t) {
  var n = {};
  return (
    (n[e.toLowerCase()] = t.toLowerCase()),
    (n["Webkit" + e] = "webkit" + t),
    (n["Moz" + e] = "moz" + t),
    n
  );
}
var Fo = {
    animationend: Nl("Animation", "AnimationEnd"),
    animationiteration: Nl("Animation", "AnimationIteration"),
    animationstart: Nl("Animation", "AnimationStart"),
    transitionend: Nl("Transition", "TransitionEnd"),
  },
  tm = {},
  BA = {};
ai &&
  ((BA = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete Fo.animationend.animation,
    delete Fo.animationiteration.animation,
    delete Fo.animationstart.animation),
  "TransitionEvent" in window || delete Fo.transitionend.transition);
function Ah(e) {
  if (tm[e]) return tm[e];
  if (!Fo[e]) return e;
  var t = Fo[e],
    n;
  for (n in t) if (t.hasOwnProperty(n) && n in BA) return (tm[e] = t[n]);
  return e;
}
var NA = Ah("animationend"),
  MA = Ah("animationiteration"),
  LA = Ah("animationstart"),
  FA = Ah("transitionend"),
  jA = new Map(),
  l1 =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function ds(e, t) {
  jA.set(e, t), ho(t, [e]);
}
for (var nm = 0; nm < l1.length; nm++) {
  var rm = l1[nm],
    l6 = rm.toLowerCase(),
    d6 = rm[0].toUpperCase() + rm.slice(1);
  ds(l6, "on" + d6);
}
ds(NA, "onAnimationEnd");
ds(MA, "onAnimationIteration");
ds(LA, "onAnimationStart");
ds("dblclick", "onDoubleClick");
ds("focusin", "onFocus");
ds("focusout", "onBlur");
ds(FA, "onTransitionEnd");
la("onMouseEnter", ["mouseout", "mouseover"]);
la("onMouseLeave", ["mouseout", "mouseover"]);
la("onPointerEnter", ["pointerout", "pointerover"]);
la("onPointerLeave", ["pointerout", "pointerover"]);
ho(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
ho(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
ho("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ho(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
ho(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
ho(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var vu =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  f6 = new Set("cancel close invalid load scroll toggle".split(" ").concat(vu));
function d1(e, t, n) {
  var r = e.type || "unknown-event";
  (e.currentTarget = n), lP(r, t, void 0, e), (e.currentTarget = null);
}
function UA(e, t) {
  t = (t & 4) !== 0;
  for (var n = 0; n < e.length; n++) {
    var r = e[n],
      i = r.event;
    r = r.listeners;
    e: {
      var s = void 0;
      if (t)
        for (var o = r.length - 1; 0 <= o; o--) {
          var a = r[o],
            u = a.instance,
            l = a.currentTarget;
          if (((a = a.listener), u !== s && i.isPropagationStopped())) break e;
          d1(i, a, l), (s = u);
        }
      else
        for (o = 0; o < r.length; o++) {
          if (
            ((a = r[o]),
            (u = a.instance),
            (l = a.currentTarget),
            (a = a.listener),
            u !== s && i.isPropagationStopped())
          )
            break e;
          d1(i, a, l), (s = u);
        }
    }
  }
  if ($d) throw ((e = C0), ($d = !1), (C0 = null), e);
}
function Ge(e, t) {
  var n = t[M0];
  n === void 0 && (n = t[M0] = new Set());
  var r = e + "__bubble";
  n.has(r) || ($A(t, e, 2, !1), n.add(r));
}
function im(e, t, n) {
  var r = 0;
  t && (r |= 4), $A(n, e, r, t);
}
var Ml = "_reactListening" + Math.random().toString(36).slice(2);
function Xu(e) {
  if (!e[Ml]) {
    (e[Ml] = !0),
      V2.forEach(function (n) {
        n !== "selectionchange" && (f6.has(n) || im(n, !1, e), im(n, !0, e));
      });
    var t = e.nodeType === 9 ? e : e.ownerDocument;
    t === null || t[Ml] || ((t[Ml] = !0), im("selectionchange", !1, t));
  }
}
function $A(e, t, n, r) {
  switch (xA(t)) {
    case 1:
      var i = CP;
      break;
    case 4:
      i = TP;
      break;
    default:
      i = rv;
  }
  (n = i.bind(null, t, n, e)),
    (i = void 0),
    !S0 ||
      (t !== "touchstart" && t !== "touchmove" && t !== "wheel") ||
      (i = !0),
    r
      ? i !== void 0
        ? e.addEventListener(t, n, { capture: !0, passive: i })
        : e.addEventListener(t, n, !0)
      : i !== void 0
      ? e.addEventListener(t, n, { passive: i })
      : e.addEventListener(t, n, !1);
}
function sm(e, t, n, r, i) {
  var s = r;
  if (!(t & 1) && !(t & 2) && r !== null)
    e: for (;;) {
      if (r === null) return;
      var o = r.tag;
      if (o === 3 || o === 4) {
        var a = r.stateNode.containerInfo;
        if (a === i || (a.nodeType === 8 && a.parentNode === i)) break;
        if (o === 4)
          for (o = r.return; o !== null; ) {
            var u = o.tag;
            if (
              (u === 3 || u === 4) &&
              ((u = o.stateNode.containerInfo),
              u === i || (u.nodeType === 8 && u.parentNode === i))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = Ps(a)), o === null)) return;
          if (((u = o.tag), u === 5 || u === 6)) {
            r = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      r = r.return;
    }
  lA(function () {
    var l = s,
      c = Xg(n),
      d = [];
    e: {
      var f = jA.get(e);
      if (f !== void 0) {
        var p = sv,
          m = e;
        switch (e) {
          case "keypress":
            if (dd(n) === 0) break e;
          case "keydown":
          case "keyup":
            p = HP;
            break;
          case "focusin":
            (m = "focus"), (p = Yp);
            break;
          case "focusout":
            (m = "blur"), (p = Yp);
            break;
          case "beforeblur":
          case "afterblur":
            p = Yp;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = Xw;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = PP;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = qP;
            break;
          case NA:
          case MA:
          case LA:
            p = RP;
            break;
          case FA:
            p = QP;
            break;
          case "scroll":
            p = IP;
            break;
          case "wheel":
            p = KP;
            break;
          case "copy":
          case "cut":
          case "paste":
            p = NP;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = t1;
        }
        var g = (t & 4) !== 0,
          w = !g && e === "scroll",
          v = g ? (f !== null ? f + "Capture" : null) : f;
        g = [];
        for (var y = l, b; y !== null; ) {
          b = y;
          var _ = b.stateNode;
          if (
            (b.tag === 5 &&
              _ !== null &&
              ((b = _),
              v !== null && ((_ = Qu(y, v)), _ != null && g.push(ec(y, _, b)))),
            w)
          )
            break;
          y = y.return;
        }
        0 < g.length &&
          ((f = new p(f, m, null, n, c)), d.push({ event: f, listeners: g }));
      }
    }
    if (!(t & 7)) {
      e: {
        if (
          ((f = e === "mouseover" || e === "pointerover"),
          (p = e === "mouseout" || e === "pointerout"),
          f &&
            n !== A0 &&
            (m = n.relatedTarget || n.fromElement) &&
            (Ps(m) || m[ui]))
        )
          break e;
        if (
          (p || f) &&
          ((f =
            c.window === c
              ? c
              : (f = c.ownerDocument)
              ? f.defaultView || f.parentWindow
              : window),
          p
            ? ((m = n.relatedTarget || n.toElement),
              (p = l),
              (m = m ? Ps(m) : null),
              m !== null &&
                ((w = po(m)), m !== w || (m.tag !== 5 && m.tag !== 6)) &&
                (m = null))
            : ((p = null), (m = l)),
          p !== m)
        ) {
          if (
            ((g = Xw),
            (_ = "onMouseLeave"),
            (v = "onMouseEnter"),
            (y = "mouse"),
            (e === "pointerout" || e === "pointerover") &&
              ((g = t1),
              (_ = "onPointerLeave"),
              (v = "onPointerEnter"),
              (y = "pointer")),
            (w = p == null ? f : jo(p)),
            (b = m == null ? f : jo(m)),
            (f = new g(_, y + "leave", p, n, c)),
            (f.target = w),
            (f.relatedTarget = b),
            (_ = null),
            Ps(c) === l &&
              ((g = new g(v, y + "enter", m, n, c)),
              (g.target = b),
              (g.relatedTarget = w),
              (_ = g)),
            (w = _),
            p && m)
          )
            t: {
              for (g = p, v = m, y = 0, b = g; b; b = bo(b)) y++;
              for (b = 0, _ = v; _; _ = bo(_)) b++;
              for (; 0 < y - b; ) (g = bo(g)), y--;
              for (; 0 < b - y; ) (v = bo(v)), b--;
              for (; y--; ) {
                if (g === v || (v !== null && g === v.alternate)) break t;
                (g = bo(g)), (v = bo(v));
              }
              g = null;
            }
          else g = null;
          p !== null && f1(d, f, p, g, !1),
            m !== null && w !== null && f1(d, w, m, g, !0);
        }
      }
      e: {
        if (
          ((f = l ? jo(l) : window),
          (p = f.nodeName && f.nodeName.toLowerCase()),
          p === "select" || (p === "input" && f.type === "file"))
        )
          var A = n6;
        else if (i1(f))
          if (PA) A = o6;
          else {
            A = i6;
            var x = r6;
          }
        else
          (p = f.nodeName) &&
            p.toLowerCase() === "input" &&
            (f.type === "checkbox" || f.type === "radio") &&
            (A = s6);
        if (A && (A = A(e, l))) {
          kA(d, A, n, c);
          break e;
        }
        x && x(e, f, l),
          e === "focusout" &&
            (x = f._wrapperState) &&
            x.controlled &&
            f.type === "number" &&
            v0(f, "number", f.value);
      }
      switch (((x = l ? jo(l) : window), e)) {
        case "focusin":
          (i1(x) || x.contentEditable === "true") &&
            ((Lo = x), (P0 = l), (Du = null));
          break;
        case "focusout":
          Du = P0 = Lo = null;
          break;
        case "mousedown":
          D0 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (D0 = !1), c1(d, n, c);
          break;
        case "selectionchange":
          if (c6) break;
        case "keydown":
        case "keyup":
          c1(d, n, c);
      }
      var h;
      if (av)
        e: {
          switch (e) {
            case "compositionstart":
              var E = "onCompositionStart";
              break e;
            case "compositionend":
              E = "onCompositionEnd";
              break e;
            case "compositionupdate":
              E = "onCompositionUpdate";
              break e;
          }
          E = void 0;
        }
      else
        Mo
          ? TA(e, n) && (E = "onCompositionEnd")
          : e === "keydown" && n.keyCode === 229 && (E = "onCompositionStart");
      E &&
        (CA &&
          n.locale !== "ko" &&
          (Mo || E !== "onCompositionStart"
            ? E === "onCompositionEnd" && Mo && (h = SA())
            : ((Fi = c),
              (iv = "value" in Fi ? Fi.value : Fi.textContent),
              (Mo = !0))),
        (x = Wd(l, E)),
        0 < x.length &&
          ((E = new e1(E, e, null, n, c)),
          d.push({ event: E, listeners: x }),
          h ? (E.data = h) : ((h = IA(n)), h !== null && (E.data = h)))),
        (h = JP ? YP(e, n) : XP(e, n)) &&
          ((l = Wd(l, "onBeforeInput")),
          0 < l.length &&
            ((c = new e1("onBeforeInput", "beforeinput", null, n, c)),
            d.push({ event: c, listeners: l }),
            (c.data = h)));
    }
    UA(d, t);
  });
}
function ec(e, t, n) {
  return { instance: e, listener: t, currentTarget: n };
}
function Wd(e, t) {
  for (var n = t + "Capture", r = []; e !== null; ) {
    var i = e,
      s = i.stateNode;
    i.tag === 5 &&
      s !== null &&
      ((i = s),
      (s = Qu(e, n)),
      s != null && r.unshift(ec(e, s, i)),
      (s = Qu(e, t)),
      s != null && r.push(ec(e, s, i))),
      (e = e.return);
  }
  return r;
}
function bo(e) {
  if (e === null) return null;
  do e = e.return;
  while (e && e.tag !== 5);
  return e || null;
}
function f1(e, t, n, r, i) {
  for (var s = t._reactName, o = []; n !== null && n !== r; ) {
    var a = n,
      u = a.alternate,
      l = a.stateNode;
    if (u !== null && u === r) break;
    a.tag === 5 &&
      l !== null &&
      ((a = l),
      i
        ? ((u = Qu(n, s)), u != null && o.unshift(ec(n, u, a)))
        : i || ((u = Qu(n, s)), u != null && o.push(ec(n, u, a)))),
      (n = n.return);
  }
  o.length !== 0 && e.push({ event: t, listeners: o });
}
var h6 = /\r\n?/g,
  p6 = /\u0000|\uFFFD/g;
function h1(e) {
  return (typeof e == "string" ? e : "" + e)
    .replace(
      h6,
      `
`
    )
    .replace(p6, "");
}
function Ll(e, t, n) {
  if (((t = h1(t)), h1(e) !== t && n)) throw Error(U(425));
}
function Qd() {}
var O0 = null,
  R0 = null;
function B0(e, t) {
  return (
    e === "textarea" ||
    e === "noscript" ||
    typeof t.children == "string" ||
    typeof t.children == "number" ||
    (typeof t.dangerouslySetInnerHTML == "object" &&
      t.dangerouslySetInnerHTML !== null &&
      t.dangerouslySetInnerHTML.__html != null)
  );
}
var N0 = typeof setTimeout == "function" ? setTimeout : void 0,
  m6 = typeof clearTimeout == "function" ? clearTimeout : void 0,
  p1 = typeof Promise == "function" ? Promise : void 0,
  y6 =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof p1 < "u"
      ? function (e) {
          return p1.resolve(null).then(e).catch(g6);
        }
      : N0;
function g6(e) {
  setTimeout(function () {
    throw e;
  });
}
function om(e, t) {
  var n = t,
    r = 0;
  do {
    var i = n.nextSibling;
    if ((e.removeChild(n), i && i.nodeType === 8))
      if (((n = i.data), n === "/$")) {
        if (r === 0) {
          e.removeChild(i), Zu(t);
          return;
        }
        r--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || r++;
    n = i;
  } while (n);
  Zu(t);
}
function Wi(e) {
  for (; e != null; e = e.nextSibling) {
    var t = e.nodeType;
    if (t === 1 || t === 3) break;
    if (t === 8) {
      if (((t = e.data), t === "$" || t === "$!" || t === "$?")) break;
      if (t === "/$") return null;
    }
  }
  return e;
}
function m1(e) {
  e = e.previousSibling;
  for (var t = 0; e; ) {
    if (e.nodeType === 8) {
      var n = e.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (t === 0) return e;
        t--;
      } else n === "/$" && t++;
    }
    e = e.previousSibling;
  }
  return null;
}
var Ma = Math.random().toString(36).slice(2),
  xr = "__reactFiber$" + Ma,
  tc = "__reactProps$" + Ma,
  ui = "__reactContainer$" + Ma,
  M0 = "__reactEvents$" + Ma,
  v6 = "__reactListeners$" + Ma,
  b6 = "__reactHandles$" + Ma;
function Ps(e) {
  var t = e[xr];
  if (t) return t;
  for (var n = e.parentNode; n; ) {
    if ((t = n[ui] || n[xr])) {
      if (
        ((n = t.alternate),
        t.child !== null || (n !== null && n.child !== null))
      )
        for (e = m1(e); e !== null; ) {
          if ((n = e[xr])) return n;
          e = m1(e);
        }
      return t;
    }
    (e = n), (n = e.parentNode);
  }
  return null;
}
function rl(e) {
  return (
    (e = e[xr] || e[ui]),
    !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  );
}
function jo(e) {
  if (e.tag === 5 || e.tag === 6) return e.stateNode;
  throw Error(U(33));
}
function xh(e) {
  return e[tc] || null;
}
var L0 = [],
  Uo = -1;
function fs(e) {
  return { current: e };
}
function We(e) {
  0 > Uo || ((e.current = L0[Uo]), (L0[Uo] = null), Uo--);
}
function ze(e, t) {
  Uo++, (L0[Uo] = e.current), (e.current = t);
}
var es = {},
  Yt = fs(es),
  vn = fs(!1),
  Vs = es;
function da(e, t) {
  var n = e.type.contextTypes;
  if (!n) return es;
  var r = e.stateNode;
  if (r && r.__reactInternalMemoizedUnmaskedChildContext === t)
    return r.__reactInternalMemoizedMaskedChildContext;
  var i = {},
    s;
  for (s in n) i[s] = t[s];
  return (
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = t),
      (e.__reactInternalMemoizedMaskedChildContext = i)),
    i
  );
}
function bn(e) {
  return (e = e.childContextTypes), e != null;
}
function Vd() {
  We(vn), We(Yt);
}
function y1(e, t, n) {
  if (Yt.current !== es) throw Error(U(168));
  ze(Yt, t), ze(vn, n);
}
function HA(e, t, n) {
  var r = e.stateNode;
  if (((t = t.childContextTypes), typeof r.getChildContext != "function"))
    return n;
  r = r.getChildContext();
  for (var i in r) if (!(i in t)) throw Error(U(108, rP(e) || "Unknown", i));
  return tt({}, n, r);
}
function Kd(e) {
  return (
    (e =
      ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || es),
    (Vs = Yt.current),
    ze(Yt, e),
    ze(vn, vn.current),
    !0
  );
}
function g1(e, t, n) {
  var r = e.stateNode;
  if (!r) throw Error(U(169));
  n
    ? ((e = HA(e, t, Vs)),
      (r.__reactInternalMemoizedMergedChildContext = e),
      We(vn),
      We(Yt),
      ze(Yt, e))
    : We(vn),
    ze(vn, n);
}
var Wr = null,
  Sh = !1,
  am = !1;
function zA(e) {
  Wr === null ? (Wr = [e]) : Wr.push(e);
}
function w6(e) {
  (Sh = !0), zA(e);
}
function hs() {
  if (!am && Wr !== null) {
    am = !0;
    var e = 0,
      t = Re;
    try {
      var n = Wr;
      for (Re = 1; e < n.length; e++) {
        var r = n[e];
        do r = r(!0);
        while (r !== null);
      }
      (Wr = null), (Sh = !1);
    } catch (i) {
      throw (Wr !== null && (Wr = Wr.slice(e + 1)), pA(ev, hs), i);
    } finally {
      (Re = t), (am = !1);
    }
  }
  return null;
}
var $o = [],
  Ho = 0,
  Zd = null,
  Jd = 0,
  Gn = [],
  qn = 0,
  Ks = null,
  Yr = 1,
  Xr = "";
function Ss(e, t) {
  ($o[Ho++] = Jd), ($o[Ho++] = Zd), (Zd = e), (Jd = t);
}
function GA(e, t, n) {
  (Gn[qn++] = Yr), (Gn[qn++] = Xr), (Gn[qn++] = Ks), (Ks = e);
  var r = Yr;
  e = Xr;
  var i = 32 - cr(r) - 1;
  (r &= ~(1 << i)), (n += 1);
  var s = 32 - cr(t) + i;
  if (30 < s) {
    var o = i - (i % 5);
    (s = (r & ((1 << o) - 1)).toString(32)),
      (r >>= o),
      (i -= o),
      (Yr = (1 << (32 - cr(t) + i)) | (n << i) | r),
      (Xr = s + e);
  } else (Yr = (1 << s) | (n << i) | r), (Xr = e);
}
function cv(e) {
  e.return !== null && (Ss(e, 1), GA(e, 1, 0));
}
function lv(e) {
  for (; e === Zd; )
    (Zd = $o[--Ho]), ($o[Ho] = null), (Jd = $o[--Ho]), ($o[Ho] = null);
  for (; e === Ks; )
    (Ks = Gn[--qn]),
      (Gn[qn] = null),
      (Xr = Gn[--qn]),
      (Gn[qn] = null),
      (Yr = Gn[--qn]),
      (Gn[qn] = null);
}
var In = null,
  Cn = null,
  Ke = !1,
  ar = null;
function qA(e, t) {
  var n = Qn(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = t),
    (n.return = e),
    (t = e.deletions),
    t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n);
}
function v1(e, t) {
  switch (e.tag) {
    case 5:
      var n = e.type;
      return (
        (t =
          t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase()
            ? null
            : t),
        t !== null
          ? ((e.stateNode = t), (In = e), (Cn = Wi(t.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (t = e.pendingProps === "" || t.nodeType !== 3 ? null : t),
        t !== null ? ((e.stateNode = t), (In = e), (Cn = null), !0) : !1
      );
    case 13:
      return (
        (t = t.nodeType !== 8 ? null : t),
        t !== null
          ? ((n = Ks !== null ? { id: Yr, overflow: Xr } : null),
            (e.memoizedState = {
              dehydrated: t,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = Qn(18, null, null, 0)),
            (n.stateNode = t),
            (n.return = e),
            (e.child = n),
            (In = e),
            (Cn = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function F0(e) {
  return (e.mode & 1) !== 0 && (e.flags & 128) === 0;
}
function j0(e) {
  if (Ke) {
    var t = Cn;
    if (t) {
      var n = t;
      if (!v1(e, t)) {
        if (F0(e)) throw Error(U(418));
        t = Wi(n.nextSibling);
        var r = In;
        t && v1(e, t)
          ? qA(r, n)
          : ((e.flags = (e.flags & -4097) | 2), (Ke = !1), (In = e));
      }
    } else {
      if (F0(e)) throw Error(U(418));
      (e.flags = (e.flags & -4097) | 2), (Ke = !1), (In = e);
    }
  }
}
function b1(e) {
  for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; )
    e = e.return;
  In = e;
}
function Fl(e) {
  if (e !== In) return !1;
  if (!Ke) return b1(e), (Ke = !0), !1;
  var t;
  if (
    ((t = e.tag !== 3) &&
      !(t = e.tag !== 5) &&
      ((t = e.type),
      (t = t !== "head" && t !== "body" && !B0(e.type, e.memoizedProps))),
    t && (t = Cn))
  ) {
    if (F0(e)) throw (WA(), Error(U(418)));
    for (; t; ) qA(e, t), (t = Wi(t.nextSibling));
  }
  if ((b1(e), e.tag === 13)) {
    if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e))
      throw Error(U(317));
    e: {
      for (e = e.nextSibling, t = 0; e; ) {
        if (e.nodeType === 8) {
          var n = e.data;
          if (n === "/$") {
            if (t === 0) {
              Cn = Wi(e.nextSibling);
              break e;
            }
            t--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || t++;
        }
        e = e.nextSibling;
      }
      Cn = null;
    }
  } else Cn = In ? Wi(e.stateNode.nextSibling) : null;
  return !0;
}
function WA() {
  for (var e = Cn; e; ) e = Wi(e.nextSibling);
}
function fa() {
  (Cn = In = null), (Ke = !1);
}
function dv(e) {
  ar === null ? (ar = [e]) : ar.push(e);
}
var E6 = yi.ReactCurrentBatchConfig;
function rr(e, t) {
  if (e && e.defaultProps) {
    (t = tt({}, t)), (e = e.defaultProps);
    for (var n in e) t[n] === void 0 && (t[n] = e[n]);
    return t;
  }
  return t;
}
var Yd = fs(null),
  Xd = null,
  zo = null,
  fv = null;
function hv() {
  fv = zo = Xd = null;
}
function pv(e) {
  var t = Yd.current;
  We(Yd), (e._currentValue = t);
}
function U0(e, t, n) {
  for (; e !== null; ) {
    var r = e.alternate;
    if (
      ((e.childLanes & t) !== t
        ? ((e.childLanes |= t), r !== null && (r.childLanes |= t))
        : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t),
      e === n)
    )
      break;
    e = e.return;
  }
}
function ea(e, t) {
  (Xd = e),
    (fv = zo = null),
    (e = e.dependencies),
    e !== null &&
      e.firstContext !== null &&
      (e.lanes & t && (pn = !0), (e.firstContext = null));
}
function Yn(e) {
  var t = e._currentValue;
  if (fv !== e)
    if (((e = { context: e, memoizedValue: t, next: null }), zo === null)) {
      if (Xd === null) throw Error(U(308));
      (zo = e), (Xd.dependencies = { lanes: 0, firstContext: e });
    } else zo = zo.next = e;
  return t;
}
var Ds = null;
function mv(e) {
  Ds === null ? (Ds = [e]) : Ds.push(e);
}
function QA(e, t, n, r) {
  var i = t.interleaved;
  return (
    i === null ? ((n.next = n), mv(t)) : ((n.next = i.next), (i.next = n)),
    (t.interleaved = n),
    ci(e, r)
  );
}
function ci(e, t) {
  e.lanes |= t;
  var n = e.alternate;
  for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null; )
    (e.childLanes |= t),
      (n = e.alternate),
      n !== null && (n.childLanes |= t),
      (n = e),
      (e = e.return);
  return n.tag === 3 ? n.stateNode : null;
}
var Oi = !1;
function yv(e) {
  e.updateQueue = {
    baseState: e.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function VA(e, t) {
  (e = e.updateQueue),
    t.updateQueue === e &&
      (t.updateQueue = {
        baseState: e.baseState,
        firstBaseUpdate: e.firstBaseUpdate,
        lastBaseUpdate: e.lastBaseUpdate,
        shared: e.shared,
        effects: e.effects,
      });
}
function ri(e, t) {
  return {
    eventTime: e,
    lane: t,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Qi(e, t, n) {
  var r = e.updateQueue;
  if (r === null) return null;
  if (((r = r.shared), Ce & 2)) {
    var i = r.pending;
    return (
      i === null ? (t.next = t) : ((t.next = i.next), (i.next = t)),
      (r.pending = t),
      ci(e, n)
    );
  }
  return (
    (i = r.interleaved),
    i === null ? ((t.next = t), mv(r)) : ((t.next = i.next), (i.next = t)),
    (r.interleaved = t),
    ci(e, n)
  );
}
function fd(e, t, n) {
  if (
    ((t = t.updateQueue), t !== null && ((t = t.shared), (n & 4194240) !== 0))
  ) {
    var r = t.lanes;
    (r &= e.pendingLanes), (n |= r), (t.lanes = n), tv(e, n);
  }
}
function w1(e, t) {
  var n = e.updateQueue,
    r = e.alternate;
  if (r !== null && ((r = r.updateQueue), n === r)) {
    var i = null,
      s = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var o = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        s === null ? (i = s = o) : (s = s.next = o), (n = n.next);
      } while (n !== null);
      s === null ? (i = s = t) : (s = s.next = t);
    } else i = s = t;
    (n = {
      baseState: r.baseState,
      firstBaseUpdate: i,
      lastBaseUpdate: s,
      shared: r.shared,
      effects: r.effects,
    }),
      (e.updateQueue = n);
    return;
  }
  (e = n.lastBaseUpdate),
    e === null ? (n.firstBaseUpdate = t) : (e.next = t),
    (n.lastBaseUpdate = t);
}
function ef(e, t, n, r) {
  var i = e.updateQueue;
  Oi = !1;
  var s = i.firstBaseUpdate,
    o = i.lastBaseUpdate,
    a = i.shared.pending;
  if (a !== null) {
    i.shared.pending = null;
    var u = a,
      l = u.next;
    (u.next = null), o === null ? (s = l) : (o.next = l), (o = u);
    var c = e.alternate;
    c !== null &&
      ((c = c.updateQueue),
      (a = c.lastBaseUpdate),
      a !== o &&
        (a === null ? (c.firstBaseUpdate = l) : (a.next = l),
        (c.lastBaseUpdate = u)));
  }
  if (s !== null) {
    var d = i.baseState;
    (o = 0), (c = l = u = null), (a = s);
    do {
      var f = a.lane,
        p = a.eventTime;
      if ((r & f) === f) {
        c !== null &&
          (c = c.next =
            {
              eventTime: p,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var m = e,
            g = a;
          switch (((f = t), (p = n), g.tag)) {
            case 1:
              if (((m = g.payload), typeof m == "function")) {
                d = m.call(p, d, f);
                break e;
              }
              d = m;
              break e;
            case 3:
              m.flags = (m.flags & -65537) | 128;
            case 0:
              if (
                ((m = g.payload),
                (f = typeof m == "function" ? m.call(p, d, f) : m),
                f == null)
              )
                break e;
              d = tt({}, d, f);
              break e;
            case 2:
              Oi = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((e.flags |= 64),
          (f = i.effects),
          f === null ? (i.effects = [a]) : f.push(a));
      } else
        (p = {
          eventTime: p,
          lane: f,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          c === null ? ((l = c = p), (u = d)) : (c = c.next = p),
          (o |= f);
      if (((a = a.next), a === null)) {
        if (((a = i.shared.pending), a === null)) break;
        (f = a),
          (a = f.next),
          (f.next = null),
          (i.lastBaseUpdate = f),
          (i.shared.pending = null);
      }
    } while (!0);
    if (
      (c === null && (u = d),
      (i.baseState = u),
      (i.firstBaseUpdate = l),
      (i.lastBaseUpdate = c),
      (t = i.shared.interleaved),
      t !== null)
    ) {
      i = t;
      do (o |= i.lane), (i = i.next);
      while (i !== t);
    } else s === null && (i.shared.lanes = 0);
    (Js |= o), (e.lanes = o), (e.memoizedState = d);
  }
}
function E1(e, t, n) {
  if (((e = t.effects), (t.effects = null), e !== null))
    for (t = 0; t < e.length; t++) {
      var r = e[t],
        i = r.callback;
      if (i !== null) {
        if (((r.callback = null), (r = n), typeof i != "function"))
          throw Error(U(191, i));
        i.call(r);
      }
    }
}
var KA = new Q2.Component().refs;
function $0(e, t, n, r) {
  (t = e.memoizedState),
    (n = n(r, t)),
    (n = n == null ? t : tt({}, t, n)),
    (e.memoizedState = n),
    e.lanes === 0 && (e.updateQueue.baseState = n);
}
var Ch = {
  isMounted: function (e) {
    return (e = e._reactInternals) ? po(e) === e : !1;
  },
  enqueueSetState: function (e, t, n) {
    e = e._reactInternals;
    var r = nn(),
      i = Ki(e),
      s = ri(r, i);
    (s.payload = t),
      n != null && (s.callback = n),
      (t = Qi(e, s, i)),
      t !== null && (lr(t, e, i, r), fd(t, e, i));
  },
  enqueueReplaceState: function (e, t, n) {
    e = e._reactInternals;
    var r = nn(),
      i = Ki(e),
      s = ri(r, i);
    (s.tag = 1),
      (s.payload = t),
      n != null && (s.callback = n),
      (t = Qi(e, s, i)),
      t !== null && (lr(t, e, i, r), fd(t, e, i));
  },
  enqueueForceUpdate: function (e, t) {
    e = e._reactInternals;
    var n = nn(),
      r = Ki(e),
      i = ri(n, r);
    (i.tag = 2),
      t != null && (i.callback = t),
      (t = Qi(e, i, r)),
      t !== null && (lr(t, e, r, n), fd(t, e, r));
  },
};
function _1(e, t, n, r, i, s, o) {
  return (
    (e = e.stateNode),
    typeof e.shouldComponentUpdate == "function"
      ? e.shouldComponentUpdate(r, s, o)
      : t.prototype && t.prototype.isPureReactComponent
      ? !Yu(n, r) || !Yu(i, s)
      : !0
  );
}
function ZA(e, t, n) {
  var r = !1,
    i = es,
    s = t.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = Yn(s))
      : ((i = bn(t) ? Vs : Yt.current),
        (r = t.contextTypes),
        (s = (r = r != null) ? da(e, i) : es)),
    (t = new t(n, s)),
    (e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null),
    (t.updater = Ch),
    (e.stateNode = t),
    (t._reactInternals = e),
    r &&
      ((e = e.stateNode),
      (e.__reactInternalMemoizedUnmaskedChildContext = i),
      (e.__reactInternalMemoizedMaskedChildContext = s)),
    t
  );
}
function A1(e, t, n, r) {
  (e = t.state),
    typeof t.componentWillReceiveProps == "function" &&
      t.componentWillReceiveProps(n, r),
    typeof t.UNSAFE_componentWillReceiveProps == "function" &&
      t.UNSAFE_componentWillReceiveProps(n, r),
    t.state !== e && Ch.enqueueReplaceState(t, t.state, null);
}
function H0(e, t, n, r) {
  var i = e.stateNode;
  (i.props = n), (i.state = e.memoizedState), (i.refs = KA), yv(e);
  var s = t.contextType;
  typeof s == "object" && s !== null
    ? (i.context = Yn(s))
    : ((s = bn(t) ? Vs : Yt.current), (i.context = da(e, s))),
    (i.state = e.memoizedState),
    (s = t.getDerivedStateFromProps),
    typeof s == "function" && ($0(e, t, s, n), (i.state = e.memoizedState)),
    typeof t.getDerivedStateFromProps == "function" ||
      typeof i.getSnapshotBeforeUpdate == "function" ||
      (typeof i.UNSAFE_componentWillMount != "function" &&
        typeof i.componentWillMount != "function") ||
      ((t = i.state),
      typeof i.componentWillMount == "function" && i.componentWillMount(),
      typeof i.UNSAFE_componentWillMount == "function" &&
        i.UNSAFE_componentWillMount(),
      t !== i.state && Ch.enqueueReplaceState(i, i.state, null),
      ef(e, n, i, r),
      (i.state = e.memoizedState)),
    typeof i.componentDidMount == "function" && (e.flags |= 4194308);
}
function eu(e, t, n) {
  if (
    ((e = n.ref), e !== null && typeof e != "function" && typeof e != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(U(309));
        var r = n.stateNode;
      }
      if (!r) throw Error(U(147, e));
      var i = r,
        s = "" + e;
      return t !== null &&
        t.ref !== null &&
        typeof t.ref == "function" &&
        t.ref._stringRef === s
        ? t.ref
        : ((t = function (o) {
            var a = i.refs;
            a === KA && (a = i.refs = {}),
              o === null ? delete a[s] : (a[s] = o);
          }),
          (t._stringRef = s),
          t);
    }
    if (typeof e != "string") throw Error(U(284));
    if (!n._owner) throw Error(U(290, e));
  }
  return e;
}
function jl(e, t) {
  throw (
    ((e = Object.prototype.toString.call(t)),
    Error(
      U(
        31,
        e === "[object Object]"
          ? "object with keys {" + Object.keys(t).join(", ") + "}"
          : e
      )
    ))
  );
}
function x1(e) {
  var t = e._init;
  return t(e._payload);
}
function JA(e) {
  function t(v, y) {
    if (e) {
      var b = v.deletions;
      b === null ? ((v.deletions = [y]), (v.flags |= 16)) : b.push(y);
    }
  }
  function n(v, y) {
    if (!e) return null;
    for (; y !== null; ) t(v, y), (y = y.sibling);
    return null;
  }
  function r(v, y) {
    for (v = new Map(); y !== null; )
      y.key !== null ? v.set(y.key, y) : v.set(y.index, y), (y = y.sibling);
    return v;
  }
  function i(v, y) {
    return (v = Zi(v, y)), (v.index = 0), (v.sibling = null), v;
  }
  function s(v, y, b) {
    return (
      (v.index = b),
      e
        ? ((b = v.alternate),
          b !== null
            ? ((b = b.index), b < y ? ((v.flags |= 2), y) : b)
            : ((v.flags |= 2), y))
        : ((v.flags |= 1048576), y)
    );
  }
  function o(v) {
    return e && v.alternate === null && (v.flags |= 2), v;
  }
  function a(v, y, b, _) {
    return y === null || y.tag !== 6
      ? ((y = pm(b, v.mode, _)), (y.return = v), y)
      : ((y = i(y, b)), (y.return = v), y);
  }
  function u(v, y, b, _) {
    var A = b.type;
    return A === No
      ? c(v, y, b.props.children, _, b.key)
      : y !== null &&
        (y.elementType === A ||
          (typeof A == "object" &&
            A !== null &&
            A.$$typeof === Di &&
            x1(A) === y.type))
      ? ((_ = i(y, b.props)), (_.ref = eu(v, y, b)), (_.return = v), _)
      : ((_ = vd(b.type, b.key, b.props, null, v.mode, _)),
        (_.ref = eu(v, y, b)),
        (_.return = v),
        _);
  }
  function l(v, y, b, _) {
    return y === null ||
      y.tag !== 4 ||
      y.stateNode.containerInfo !== b.containerInfo ||
      y.stateNode.implementation !== b.implementation
      ? ((y = mm(b, v.mode, _)), (y.return = v), y)
      : ((y = i(y, b.children || [])), (y.return = v), y);
  }
  function c(v, y, b, _, A) {
    return y === null || y.tag !== 7
      ? ((y = $s(b, v.mode, _, A)), (y.return = v), y)
      : ((y = i(y, b)), (y.return = v), y);
  }
  function d(v, y, b) {
    if ((typeof y == "string" && y !== "") || typeof y == "number")
      return (y = pm("" + y, v.mode, b)), (y.return = v), y;
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case Il:
          return (
            (b = vd(y.type, y.key, y.props, null, v.mode, b)),
            (b.ref = eu(v, null, y)),
            (b.return = v),
            b
          );
        case Bo:
          return (y = mm(y, v.mode, b)), (y.return = v), y;
        case Di:
          var _ = y._init;
          return d(v, _(y._payload), b);
      }
      if (yu(y) || Ka(y))
        return (y = $s(y, v.mode, b, null)), (y.return = v), y;
      jl(v, y);
    }
    return null;
  }
  function f(v, y, b, _) {
    var A = y !== null ? y.key : null;
    if ((typeof b == "string" && b !== "") || typeof b == "number")
      return A !== null ? null : a(v, y, "" + b, _);
    if (typeof b == "object" && b !== null) {
      switch (b.$$typeof) {
        case Il:
          return b.key === A ? u(v, y, b, _) : null;
        case Bo:
          return b.key === A ? l(v, y, b, _) : null;
        case Di:
          return (A = b._init), f(v, y, A(b._payload), _);
      }
      if (yu(b) || Ka(b)) return A !== null ? null : c(v, y, b, _, null);
      jl(v, b);
    }
    return null;
  }
  function p(v, y, b, _, A) {
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return (v = v.get(b) || null), a(y, v, "" + _, A);
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Il:
          return (v = v.get(_.key === null ? b : _.key) || null), u(y, v, _, A);
        case Bo:
          return (v = v.get(_.key === null ? b : _.key) || null), l(y, v, _, A);
        case Di:
          var x = _._init;
          return p(v, y, b, x(_._payload), A);
      }
      if (yu(_) || Ka(_)) return (v = v.get(b) || null), c(y, v, _, A, null);
      jl(y, _);
    }
    return null;
  }
  function m(v, y, b, _) {
    for (
      var A = null, x = null, h = y, E = (y = 0), I = null;
      h !== null && E < b.length;
      E++
    ) {
      h.index > E ? ((I = h), (h = null)) : (I = h.sibling);
      var C = f(v, h, b[E], _);
      if (C === null) {
        h === null && (h = I);
        break;
      }
      e && h && C.alternate === null && t(v, h),
        (y = s(C, y, E)),
        x === null ? (A = C) : (x.sibling = C),
        (x = C),
        (h = I);
    }
    if (E === b.length) return n(v, h), Ke && Ss(v, E), A;
    if (h === null) {
      for (; E < b.length; E++)
        (h = d(v, b[E], _)),
          h !== null &&
            ((y = s(h, y, E)), x === null ? (A = h) : (x.sibling = h), (x = h));
      return Ke && Ss(v, E), A;
    }
    for (h = r(v, h); E < b.length; E++)
      (I = p(h, v, E, b[E], _)),
        I !== null &&
          (e && I.alternate !== null && h.delete(I.key === null ? E : I.key),
          (y = s(I, y, E)),
          x === null ? (A = I) : (x.sibling = I),
          (x = I));
    return (
      e &&
        h.forEach(function (k) {
          return t(v, k);
        }),
      Ke && Ss(v, E),
      A
    );
  }
  function g(v, y, b, _) {
    var A = Ka(b);
    if (typeof A != "function") throw Error(U(150));
    if (((b = A.call(b)), b == null)) throw Error(U(151));
    for (
      var x = (A = null), h = y, E = (y = 0), I = null, C = b.next();
      h !== null && !C.done;
      E++, C = b.next()
    ) {
      h.index > E ? ((I = h), (h = null)) : (I = h.sibling);
      var k = f(v, h, C.value, _);
      if (k === null) {
        h === null && (h = I);
        break;
      }
      e && h && k.alternate === null && t(v, h),
        (y = s(k, y, E)),
        x === null ? (A = k) : (x.sibling = k),
        (x = k),
        (h = I);
    }
    if (C.done) return n(v, h), Ke && Ss(v, E), A;
    if (h === null) {
      for (; !C.done; E++, C = b.next())
        (C = d(v, C.value, _)),
          C !== null &&
            ((y = s(C, y, E)), x === null ? (A = C) : (x.sibling = C), (x = C));
      return Ke && Ss(v, E), A;
    }
    for (h = r(v, h); !C.done; E++, C = b.next())
      (C = p(h, v, E, C.value, _)),
        C !== null &&
          (e && C.alternate !== null && h.delete(C.key === null ? E : C.key),
          (y = s(C, y, E)),
          x === null ? (A = C) : (x.sibling = C),
          (x = C));
    return (
      e &&
        h.forEach(function (O) {
          return t(v, O);
        }),
      Ke && Ss(v, E),
      A
    );
  }
  function w(v, y, b, _) {
    if (
      (typeof b == "object" &&
        b !== null &&
        b.type === No &&
        b.key === null &&
        (b = b.props.children),
      typeof b == "object" && b !== null)
    ) {
      switch (b.$$typeof) {
        case Il:
          e: {
            for (var A = b.key, x = y; x !== null; ) {
              if (x.key === A) {
                if (((A = b.type), A === No)) {
                  if (x.tag === 7) {
                    n(v, x.sibling),
                      (y = i(x, b.props.children)),
                      (y.return = v),
                      (v = y);
                    break e;
                  }
                } else if (
                  x.elementType === A ||
                  (typeof A == "object" &&
                    A !== null &&
                    A.$$typeof === Di &&
                    x1(A) === x.type)
                ) {
                  n(v, x.sibling),
                    (y = i(x, b.props)),
                    (y.ref = eu(v, x, b)),
                    (y.return = v),
                    (v = y);
                  break e;
                }
                n(v, x);
                break;
              } else t(v, x);
              x = x.sibling;
            }
            b.type === No
              ? ((y = $s(b.props.children, v.mode, _, b.key)),
                (y.return = v),
                (v = y))
              : ((_ = vd(b.type, b.key, b.props, null, v.mode, _)),
                (_.ref = eu(v, y, b)),
                (_.return = v),
                (v = _));
          }
          return o(v);
        case Bo:
          e: {
            for (x = b.key; y !== null; ) {
              if (y.key === x)
                if (
                  y.tag === 4 &&
                  y.stateNode.containerInfo === b.containerInfo &&
                  y.stateNode.implementation === b.implementation
                ) {
                  n(v, y.sibling),
                    (y = i(y, b.children || [])),
                    (y.return = v),
                    (v = y);
                  break e;
                } else {
                  n(v, y);
                  break;
                }
              else t(v, y);
              y = y.sibling;
            }
            (y = mm(b, v.mode, _)), (y.return = v), (v = y);
          }
          return o(v);
        case Di:
          return (x = b._init), w(v, y, x(b._payload), _);
      }
      if (yu(b)) return m(v, y, b, _);
      if (Ka(b)) return g(v, y, b, _);
      jl(v, b);
    }
    return (typeof b == "string" && b !== "") || typeof b == "number"
      ? ((b = "" + b),
        y !== null && y.tag === 6
          ? (n(v, y.sibling), (y = i(y, b)), (y.return = v), (v = y))
          : (n(v, y), (y = pm(b, v.mode, _)), (y.return = v), (v = y)),
        o(v))
      : n(v, y);
  }
  return w;
}
var ha = JA(!0),
  YA = JA(!1),
  il = {},
  Pr = fs(il),
  nc = fs(il),
  rc = fs(il);
function Os(e) {
  if (e === il) throw Error(U(174));
  return e;
}
function gv(e, t) {
  switch ((ze(rc, t), ze(nc, e), ze(Pr, il), (e = t.nodeType), e)) {
    case 9:
    case 11:
      t = (t = t.documentElement) ? t.namespaceURI : w0(null, "");
      break;
    default:
      (e = e === 8 ? t.parentNode : t),
        (t = e.namespaceURI || null),
        (e = e.tagName),
        (t = w0(t, e));
  }
  We(Pr), ze(Pr, t);
}
function pa() {
  We(Pr), We(nc), We(rc);
}
function XA(e) {
  Os(rc.current);
  var t = Os(Pr.current),
    n = w0(t, e.type);
  t !== n && (ze(nc, e), ze(Pr, n));
}
function vv(e) {
  nc.current === e && (We(Pr), We(nc));
}
var Je = fs(0);
function tf(e) {
  for (var t = e; t !== null; ) {
    if (t.tag === 13) {
      var n = t.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return t;
    } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) {
      if (t.flags & 128) return t;
    } else if (t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return null;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
  return null;
}
var um = [];
function bv() {
  for (var e = 0; e < um.length; e++)
    um[e]._workInProgressVersionPrimary = null;
  um.length = 0;
}
var hd = yi.ReactCurrentDispatcher,
  cm = yi.ReactCurrentBatchConfig,
  Zs = 0,
  et = null,
  ft = null,
  bt = null,
  nf = !1,
  Ou = !1,
  ic = 0,
  _6 = 0;
function zt() {
  throw Error(U(321));
}
function wv(e, t) {
  if (t === null) return !1;
  for (var n = 0; n < t.length && n < e.length; n++)
    if (!hr(e[n], t[n])) return !1;
  return !0;
}
function Ev(e, t, n, r, i, s) {
  if (
    ((Zs = s),
    (et = t),
    (t.memoizedState = null),
    (t.updateQueue = null),
    (t.lanes = 0),
    (hd.current = e === null || e.memoizedState === null ? C6 : T6),
    (e = n(r, i)),
    Ou)
  ) {
    s = 0;
    do {
      if (((Ou = !1), (ic = 0), 25 <= s)) throw Error(U(301));
      (s += 1),
        (bt = ft = null),
        (t.updateQueue = null),
        (hd.current = I6),
        (e = n(r, i));
    } while (Ou);
  }
  if (
    ((hd.current = rf),
    (t = ft !== null && ft.next !== null),
    (Zs = 0),
    (bt = ft = et = null),
    (nf = !1),
    t)
  )
    throw Error(U(300));
  return e;
}
function _v() {
  var e = ic !== 0;
  return (ic = 0), e;
}
function Ar() {
  var e = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return bt === null ? (et.memoizedState = bt = e) : (bt = bt.next = e), bt;
}
function Xn() {
  if (ft === null) {
    var e = et.alternate;
    e = e !== null ? e.memoizedState : null;
  } else e = ft.next;
  var t = bt === null ? et.memoizedState : bt.next;
  if (t !== null) (bt = t), (ft = e);
  else {
    if (e === null) throw Error(U(310));
    (ft = e),
      (e = {
        memoizedState: ft.memoizedState,
        baseState: ft.baseState,
        baseQueue: ft.baseQueue,
        queue: ft.queue,
        next: null,
      }),
      bt === null ? (et.memoizedState = bt = e) : (bt = bt.next = e);
  }
  return bt;
}
function sc(e, t) {
  return typeof t == "function" ? t(e) : t;
}
function lm(e) {
  var t = Xn(),
    n = t.queue;
  if (n === null) throw Error(U(311));
  n.lastRenderedReducer = e;
  var r = ft,
    i = r.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (i !== null) {
      var o = i.next;
      (i.next = s.next), (s.next = o);
    }
    (r.baseQueue = i = s), (n.pending = null);
  }
  if (i !== null) {
    (s = i.next), (r = r.baseState);
    var a = (o = null),
      u = null,
      l = s;
    do {
      var c = l.lane;
      if ((Zs & c) === c)
        u !== null &&
          (u = u.next =
            {
              lane: 0,
              action: l.action,
              hasEagerState: l.hasEagerState,
              eagerState: l.eagerState,
              next: null,
            }),
          (r = l.hasEagerState ? l.eagerState : e(r, l.action));
      else {
        var d = {
          lane: c,
          action: l.action,
          hasEagerState: l.hasEagerState,
          eagerState: l.eagerState,
          next: null,
        };
        u === null ? ((a = u = d), (o = r)) : (u = u.next = d),
          (et.lanes |= c),
          (Js |= c);
      }
      l = l.next;
    } while (l !== null && l !== s);
    u === null ? (o = r) : (u.next = a),
      hr(r, t.memoizedState) || (pn = !0),
      (t.memoizedState = r),
      (t.baseState = o),
      (t.baseQueue = u),
      (n.lastRenderedState = r);
  }
  if (((e = n.interleaved), e !== null)) {
    i = e;
    do (s = i.lane), (et.lanes |= s), (Js |= s), (i = i.next);
    while (i !== e);
  } else i === null && (n.lanes = 0);
  return [t.memoizedState, n.dispatch];
}
function dm(e) {
  var t = Xn(),
    n = t.queue;
  if (n === null) throw Error(U(311));
  n.lastRenderedReducer = e;
  var r = n.dispatch,
    i = n.pending,
    s = t.memoizedState;
  if (i !== null) {
    n.pending = null;
    var o = (i = i.next);
    do (s = e(s, o.action)), (o = o.next);
    while (o !== i);
    hr(s, t.memoizedState) || (pn = !0),
      (t.memoizedState = s),
      t.baseQueue === null && (t.baseState = s),
      (n.lastRenderedState = s);
  }
  return [s, r];
}
function ex() {}
function tx(e, t) {
  var n = et,
    r = Xn(),
    i = t(),
    s = !hr(r.memoizedState, i);
  if (
    (s && ((r.memoizedState = i), (pn = !0)),
    (r = r.queue),
    Av(ix.bind(null, n, r, e), [e]),
    r.getSnapshot !== t || s || (bt !== null && bt.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      oc(9, rx.bind(null, n, r, i, t), void 0, null),
      Et === null)
    )
      throw Error(U(349));
    Zs & 30 || nx(n, t, i);
  }
  return i;
}
function nx(e, t, n) {
  (e.flags |= 16384),
    (e = { getSnapshot: t, value: n }),
    (t = et.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (et.updateQueue = t),
        (t.stores = [e]))
      : ((n = t.stores), n === null ? (t.stores = [e]) : n.push(e));
}
function rx(e, t, n, r) {
  (t.value = n), (t.getSnapshot = r), sx(t) && ox(e);
}
function ix(e, t, n) {
  return n(function () {
    sx(t) && ox(e);
  });
}
function sx(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !hr(e, n);
  } catch {
    return !0;
  }
}
function ox(e) {
  var t = ci(e, 1);
  t !== null && lr(t, e, 1, -1);
}
function S1(e) {
  var t = Ar();
  return (
    typeof e == "function" && (e = e()),
    (t.memoizedState = t.baseState = e),
    (e = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: sc,
      lastRenderedState: e,
    }),
    (t.queue = e),
    (e = e.dispatch = S6.bind(null, et, e)),
    [t.memoizedState, e]
  );
}
function oc(e, t, n, r) {
  return (
    (e = { tag: e, create: t, destroy: n, deps: r, next: null }),
    (t = et.updateQueue),
    t === null
      ? ((t = { lastEffect: null, stores: null }),
        (et.updateQueue = t),
        (t.lastEffect = e.next = e))
      : ((n = t.lastEffect),
        n === null
          ? (t.lastEffect = e.next = e)
          : ((r = n.next), (n.next = e), (e.next = r), (t.lastEffect = e))),
    e
  );
}
function ax() {
  return Xn().memoizedState;
}
function pd(e, t, n, r) {
  var i = Ar();
  (et.flags |= e),
    (i.memoizedState = oc(1 | t, n, void 0, r === void 0 ? null : r));
}
function Th(e, t, n, r) {
  var i = Xn();
  r = r === void 0 ? null : r;
  var s = void 0;
  if (ft !== null) {
    var o = ft.memoizedState;
    if (((s = o.destroy), r !== null && wv(r, o.deps))) {
      i.memoizedState = oc(t, n, s, r);
      return;
    }
  }
  (et.flags |= e), (i.memoizedState = oc(1 | t, n, s, r));
}
function C1(e, t) {
  return pd(8390656, 8, e, t);
}
function Av(e, t) {
  return Th(2048, 8, e, t);
}
function ux(e, t) {
  return Th(4, 2, e, t);
}
function cx(e, t) {
  return Th(4, 4, e, t);
}
function lx(e, t) {
  if (typeof t == "function")
    return (
      (e = e()),
      t(e),
      function () {
        t(null);
      }
    );
  if (t != null)
    return (
      (e = e()),
      (t.current = e),
      function () {
        t.current = null;
      }
    );
}
function dx(e, t, n) {
  return (
    (n = n != null ? n.concat([e]) : null), Th(4, 4, lx.bind(null, t, e), n)
  );
}
function xv() {}
function fx(e, t) {
  var n = Xn();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && wv(t, r[1])
    ? r[0]
    : ((n.memoizedState = [e, t]), e);
}
function hx(e, t) {
  var n = Xn();
  t = t === void 0 ? null : t;
  var r = n.memoizedState;
  return r !== null && t !== null && wv(t, r[1])
    ? r[0]
    : ((e = e()), (n.memoizedState = [e, t]), e);
}
function px(e, t, n) {
  return Zs & 21
    ? (hr(n, t) || ((n = gA()), (et.lanes |= n), (Js |= n), (e.baseState = !0)),
      t)
    : (e.baseState && ((e.baseState = !1), (pn = !0)), (e.memoizedState = n));
}
function A6(e, t) {
  var n = Re;
  (Re = n !== 0 && 4 > n ? n : 4), e(!0);
  var r = cm.transition;
  cm.transition = {};
  try {
    e(!1), t();
  } finally {
    (Re = n), (cm.transition = r);
  }
}
function mx() {
  return Xn().memoizedState;
}
function x6(e, t, n) {
  var r = Ki(e);
  if (
    ((n = {
      lane: r,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    yx(e))
  )
    gx(t, n);
  else if (((n = QA(e, t, n, r)), n !== null)) {
    var i = nn();
    lr(n, e, r, i), vx(n, t, r);
  }
}
function S6(e, t, n) {
  var r = Ki(e),
    i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null };
  if (yx(e)) gx(t, i);
  else {
    var s = e.alternate;
    if (
      e.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = t.lastRenderedReducer), s !== null)
    )
      try {
        var o = t.lastRenderedState,
          a = s(o, n);
        if (((i.hasEagerState = !0), (i.eagerState = a), hr(a, o))) {
          var u = t.interleaved;
          u === null
            ? ((i.next = i), mv(t))
            : ((i.next = u.next), (u.next = i)),
            (t.interleaved = i);
          return;
        }
      } catch {
      } finally {
      }
    (n = QA(e, t, i, r)),
      n !== null && ((i = nn()), lr(n, e, r, i), vx(n, t, r));
  }
}
function yx(e) {
  var t = e.alternate;
  return e === et || (t !== null && t === et);
}
function gx(e, t) {
  Ou = nf = !0;
  var n = e.pending;
  n === null ? (t.next = t) : ((t.next = n.next), (n.next = t)),
    (e.pending = t);
}
function vx(e, t, n) {
  if (n & 4194240) {
    var r = t.lanes;
    (r &= e.pendingLanes), (n |= r), (t.lanes = n), tv(e, n);
  }
}
var rf = {
    readContext: Yn,
    useCallback: zt,
    useContext: zt,
    useEffect: zt,
    useImperativeHandle: zt,
    useInsertionEffect: zt,
    useLayoutEffect: zt,
    useMemo: zt,
    useReducer: zt,
    useRef: zt,
    useState: zt,
    useDebugValue: zt,
    useDeferredValue: zt,
    useTransition: zt,
    useMutableSource: zt,
    useSyncExternalStore: zt,
    useId: zt,
    unstable_isNewReconciler: !1,
  },
  C6 = {
    readContext: Yn,
    useCallback: function (e, t) {
      return (Ar().memoizedState = [e, t === void 0 ? null : t]), e;
    },
    useContext: Yn,
    useEffect: C1,
    useImperativeHandle: function (e, t, n) {
      return (
        (n = n != null ? n.concat([e]) : null),
        pd(4194308, 4, lx.bind(null, t, e), n)
      );
    },
    useLayoutEffect: function (e, t) {
      return pd(4194308, 4, e, t);
    },
    useInsertionEffect: function (e, t) {
      return pd(4, 2, e, t);
    },
    useMemo: function (e, t) {
      var n = Ar();
      return (
        (t = t === void 0 ? null : t), (e = e()), (n.memoizedState = [e, t]), e
      );
    },
    useReducer: function (e, t, n) {
      var r = Ar();
      return (
        (t = n !== void 0 ? n(t) : t),
        (r.memoizedState = r.baseState = t),
        (e = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: e,
          lastRenderedState: t,
        }),
        (r.queue = e),
        (e = e.dispatch = x6.bind(null, et, e)),
        [r.memoizedState, e]
      );
    },
    useRef: function (e) {
      var t = Ar();
      return (e = { current: e }), (t.memoizedState = e);
    },
    useState: S1,
    useDebugValue: xv,
    useDeferredValue: function (e) {
      return (Ar().memoizedState = e);
    },
    useTransition: function () {
      var e = S1(!1),
        t = e[0];
      return (e = A6.bind(null, e[1])), (Ar().memoizedState = e), [t, e];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (e, t, n) {
      var r = et,
        i = Ar();
      if (Ke) {
        if (n === void 0) throw Error(U(407));
        n = n();
      } else {
        if (((n = t()), Et === null)) throw Error(U(349));
        Zs & 30 || nx(r, t, n);
      }
      i.memoizedState = n;
      var s = { value: n, getSnapshot: t };
      return (
        (i.queue = s),
        C1(ix.bind(null, r, s, e), [e]),
        (r.flags |= 2048),
        oc(9, rx.bind(null, r, s, n, t), void 0, null),
        n
      );
    },
    useId: function () {
      var e = Ar(),
        t = Et.identifierPrefix;
      if (Ke) {
        var n = Xr,
          r = Yr;
        (n = (r & ~(1 << (32 - cr(r) - 1))).toString(32) + n),
          (t = ":" + t + "R" + n),
          (n = ic++),
          0 < n && (t += "H" + n.toString(32)),
          (t += ":");
      } else (n = _6++), (t = ":" + t + "r" + n.toString(32) + ":");
      return (e.memoizedState = t);
    },
    unstable_isNewReconciler: !1,
  },
  T6 = {
    readContext: Yn,
    useCallback: fx,
    useContext: Yn,
    useEffect: Av,
    useImperativeHandle: dx,
    useInsertionEffect: ux,
    useLayoutEffect: cx,
    useMemo: hx,
    useReducer: lm,
    useRef: ax,
    useState: function () {
      return lm(sc);
    },
    useDebugValue: xv,
    useDeferredValue: function (e) {
      var t = Xn();
      return px(t, ft.memoizedState, e);
    },
    useTransition: function () {
      var e = lm(sc)[0],
        t = Xn().memoizedState;
      return [e, t];
    },
    useMutableSource: ex,
    useSyncExternalStore: tx,
    useId: mx,
    unstable_isNewReconciler: !1,
  },
  I6 = {
    readContext: Yn,
    useCallback: fx,
    useContext: Yn,
    useEffect: Av,
    useImperativeHandle: dx,
    useInsertionEffect: ux,
    useLayoutEffect: cx,
    useMemo: hx,
    useReducer: dm,
    useRef: ax,
    useState: function () {
      return dm(sc);
    },
    useDebugValue: xv,
    useDeferredValue: function (e) {
      var t = Xn();
      return ft === null ? (t.memoizedState = e) : px(t, ft.memoizedState, e);
    },
    useTransition: function () {
      var e = dm(sc)[0],
        t = Xn().memoizedState;
      return [e, t];
    },
    useMutableSource: ex,
    useSyncExternalStore: tx,
    useId: mx,
    unstable_isNewReconciler: !1,
  };
function ma(e, t) {
  try {
    var n = "",
      r = t;
    do (n += nP(r)), (r = r.return);
    while (r);
    var i = n;
  } catch (s) {
    i =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: e, source: t, stack: i, digest: null };
}
function fm(e, t, n) {
  return { value: e, source: null, stack: n ?? null, digest: t ?? null };
}
function z0(e, t) {
  try {
    console.error(t.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var k6 = typeof WeakMap == "function" ? WeakMap : Map;
function bx(e, t, n) {
  (n = ri(-1, n)), (n.tag = 3), (n.payload = { element: null });
  var r = t.value;
  return (
    (n.callback = function () {
      of || ((of = !0), (X0 = r)), z0(e, t);
    }),
    n
  );
}
function wx(e, t, n) {
  (n = ri(-1, n)), (n.tag = 3);
  var r = e.type.getDerivedStateFromError;
  if (typeof r == "function") {
    var i = t.value;
    (n.payload = function () {
      return r(i);
    }),
      (n.callback = function () {
        z0(e, t);
      });
  }
  var s = e.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (n.callback = function () {
        z0(e, t),
          typeof r != "function" &&
            (Vi === null ? (Vi = new Set([this])) : Vi.add(this));
        var o = t.stack;
        this.componentDidCatch(t.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    n
  );
}
function T1(e, t, n) {
  var r = e.pingCache;
  if (r === null) {
    r = e.pingCache = new k6();
    var i = new Set();
    r.set(t, i);
  } else (i = r.get(t)), i === void 0 && ((i = new Set()), r.set(t, i));
  i.has(n) || (i.add(n), (e = z6.bind(null, e, t, n)), t.then(e, e));
}
function I1(e) {
  do {
    var t;
    if (
      ((t = e.tag === 13) &&
        ((t = e.memoizedState), (t = t !== null ? t.dehydrated !== null : !0)),
      t)
    )
      return e;
    e = e.return;
  } while (e !== null);
  return null;
}
function k1(e, t, n, r, i) {
  return e.mode & 1
    ? ((e.flags |= 65536), (e.lanes = i), e)
    : (e === t
        ? (e.flags |= 65536)
        : ((e.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((t = ri(-1, 1)), (t.tag = 2), Qi(n, t, 1))),
          (n.lanes |= 1)),
      e);
}
var P6 = yi.ReactCurrentOwner,
  pn = !1;
function en(e, t, n, r) {
  t.child = e === null ? YA(t, null, n, r) : ha(t, e.child, n, r);
}
function P1(e, t, n, r, i) {
  n = n.render;
  var s = t.ref;
  return (
    ea(t, i),
    (r = Ev(e, t, n, r, s, i)),
    (n = _v()),
    e !== null && !pn
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~i),
        li(e, t, i))
      : (Ke && n && cv(t), (t.flags |= 1), en(e, t, r, i), t.child)
  );
}
function D1(e, t, n, r, i) {
  if (e === null) {
    var s = n.type;
    return typeof s == "function" &&
      !Ov(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((t.tag = 15), (t.type = s), Ex(e, t, s, r, i))
      : ((e = vd(n.type, null, r, t, t.mode, i)),
        (e.ref = t.ref),
        (e.return = t),
        (t.child = e));
  }
  if (((s = e.child), !(e.lanes & i))) {
    var o = s.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : Yu), n(o, r) && e.ref === t.ref)
    )
      return li(e, t, i);
  }
  return (
    (t.flags |= 1),
    (e = Zi(s, r)),
    (e.ref = t.ref),
    (e.return = t),
    (t.child = e)
  );
}
function Ex(e, t, n, r, i) {
  if (e !== null) {
    var s = e.memoizedProps;
    if (Yu(s, r) && e.ref === t.ref)
      if (((pn = !1), (t.pendingProps = r = s), (e.lanes & i) !== 0))
        e.flags & 131072 && (pn = !0);
      else return (t.lanes = e.lanes), li(e, t, i);
  }
  return G0(e, t, n, r, i);
}
function _x(e, t, n) {
  var r = t.pendingProps,
    i = r.children,
    s = e !== null ? e.memoizedState : null;
  if (r.mode === "hidden")
    if (!(t.mode & 1))
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        ze(qo, xn),
        (xn |= n);
    else {
      if (!(n & 1073741824))
        return (
          (e = s !== null ? s.baseLanes | n : n),
          (t.lanes = t.childLanes = 1073741824),
          (t.memoizedState = {
            baseLanes: e,
            cachePool: null,
            transitions: null,
          }),
          (t.updateQueue = null),
          ze(qo, xn),
          (xn |= e),
          null
        );
      (t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (r = s !== null ? s.baseLanes : n),
        ze(qo, xn),
        (xn |= r);
    }
  else
    s !== null ? ((r = s.baseLanes | n), (t.memoizedState = null)) : (r = n),
      ze(qo, xn),
      (xn |= r);
  return en(e, t, i, n), t.child;
}
function Ax(e, t) {
  var n = t.ref;
  ((e === null && n !== null) || (e !== null && e.ref !== n)) &&
    ((t.flags |= 512), (t.flags |= 2097152));
}
function G0(e, t, n, r, i) {
  var s = bn(n) ? Vs : Yt.current;
  return (
    (s = da(t, s)),
    ea(t, i),
    (n = Ev(e, t, n, r, s, i)),
    (r = _v()),
    e !== null && !pn
      ? ((t.updateQueue = e.updateQueue),
        (t.flags &= -2053),
        (e.lanes &= ~i),
        li(e, t, i))
      : (Ke && r && cv(t), (t.flags |= 1), en(e, t, n, i), t.child)
  );
}
function O1(e, t, n, r, i) {
  if (bn(n)) {
    var s = !0;
    Kd(t);
  } else s = !1;
  if ((ea(t, i), t.stateNode === null))
    md(e, t), ZA(t, n, r), H0(t, n, r, i), (r = !0);
  else if (e === null) {
    var o = t.stateNode,
      a = t.memoizedProps;
    o.props = a;
    var u = o.context,
      l = n.contextType;
    typeof l == "object" && l !== null
      ? (l = Yn(l))
      : ((l = bn(n) ? Vs : Yt.current), (l = da(t, l)));
    var c = n.getDerivedStateFromProps,
      d =
        typeof c == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== r || u !== l) && A1(t, o, r, l)),
      (Oi = !1);
    var f = t.memoizedState;
    (o.state = f),
      ef(t, r, o, i),
      (u = t.memoizedState),
      a !== r || f !== u || vn.current || Oi
        ? (typeof c == "function" && ($0(t, n, c, r), (u = t.memoizedState)),
          (a = Oi || _1(t, n, a, r, f, u, l))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (t.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
              (t.memoizedProps = r),
              (t.memoizedState = u)),
          (o.props = r),
          (o.state = u),
          (o.context = l),
          (r = a))
        : (typeof o.componentDidMount == "function" && (t.flags |= 4194308),
          (r = !1));
  } else {
    (o = t.stateNode),
      VA(e, t),
      (a = t.memoizedProps),
      (l = t.type === t.elementType ? a : rr(t.type, a)),
      (o.props = l),
      (d = t.pendingProps),
      (f = o.context),
      (u = n.contextType),
      typeof u == "object" && u !== null
        ? (u = Yn(u))
        : ((u = bn(n) ? Vs : Yt.current), (u = da(t, u)));
    var p = n.getDerivedStateFromProps;
    (c =
      typeof p == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || f !== u) && A1(t, o, r, u)),
      (Oi = !1),
      (f = t.memoizedState),
      (o.state = f),
      ef(t, r, o, i);
    var m = t.memoizedState;
    a !== d || f !== m || vn.current || Oi
      ? (typeof p == "function" && ($0(t, n, p, r), (m = t.memoizedState)),
        (l = Oi || _1(t, n, l, r, f, m, u) || !1)
          ? (c ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(r, m, u),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(r, m, u)),
            typeof o.componentDidUpdate == "function" && (t.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === e.memoizedProps && f === e.memoizedState) ||
              (t.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === e.memoizedProps && f === e.memoizedState) ||
              (t.flags |= 1024),
            (t.memoizedProps = r),
            (t.memoizedState = m)),
        (o.props = r),
        (o.state = m),
        (o.context = u),
        (r = l))
      : (typeof o.componentDidUpdate != "function" ||
          (a === e.memoizedProps && f === e.memoizedState) ||
          (t.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === e.memoizedProps && f === e.memoizedState) ||
          (t.flags |= 1024),
        (r = !1));
  }
  return q0(e, t, n, r, s, i);
}
function q0(e, t, n, r, i, s) {
  Ax(e, t);
  var o = (t.flags & 128) !== 0;
  if (!r && !o) return i && g1(t, n, !1), li(e, t, s);
  (r = t.stateNode), (P6.current = t);
  var a =
    o && typeof n.getDerivedStateFromError != "function" ? null : r.render();
  return (
    (t.flags |= 1),
    e !== null && o
      ? ((t.child = ha(t, e.child, null, s)), (t.child = ha(t, null, a, s)))
      : en(e, t, a, s),
    (t.memoizedState = r.state),
    i && g1(t, n, !0),
    t.child
  );
}
function xx(e) {
  var t = e.stateNode;
  t.pendingContext
    ? y1(e, t.pendingContext, t.pendingContext !== t.context)
    : t.context && y1(e, t.context, !1),
    gv(e, t.containerInfo);
}
function R1(e, t, n, r, i) {
  return fa(), dv(i), (t.flags |= 256), en(e, t, n, r), t.child;
}
var W0 = { dehydrated: null, treeContext: null, retryLane: 0 };
function Q0(e) {
  return { baseLanes: e, cachePool: null, transitions: null };
}
function Sx(e, t, n) {
  var r = t.pendingProps,
    i = Je.current,
    s = !1,
    o = (t.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0),
    a
      ? ((s = !0), (t.flags &= -129))
      : (e === null || e.memoizedState !== null) && (i |= 1),
    ze(Je, i & 1),
    e === null)
  )
    return (
      j0(t),
      (e = t.memoizedState),
      e !== null && ((e = e.dehydrated), e !== null)
        ? (t.mode & 1
            ? e.data === "$!"
              ? (t.lanes = 8)
              : (t.lanes = 1073741824)
            : (t.lanes = 1),
          null)
        : ((o = r.children),
          (e = r.fallback),
          s
            ? ((r = t.mode),
              (s = t.child),
              (o = { mode: "hidden", children: o }),
              !(r & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = Ph(o, r, 0, null)),
              (e = $s(e, r, n, null)),
              (s.return = t),
              (e.return = t),
              (s.sibling = e),
              (t.child = s),
              (t.child.memoizedState = Q0(n)),
              (t.memoizedState = W0),
              e)
            : Sv(t, o))
    );
  if (((i = e.memoizedState), i !== null && ((a = i.dehydrated), a !== null)))
    return D6(e, t, o, r, a, i, n);
  if (s) {
    (s = r.fallback), (o = t.mode), (i = e.child), (a = i.sibling);
    var u = { mode: "hidden", children: r.children };
    return (
      !(o & 1) && t.child !== i
        ? ((r = t.child),
          (r.childLanes = 0),
          (r.pendingProps = u),
          (t.deletions = null))
        : ((r = Zi(i, u)), (r.subtreeFlags = i.subtreeFlags & 14680064)),
      a !== null ? (s = Zi(a, s)) : ((s = $s(s, o, n, null)), (s.flags |= 2)),
      (s.return = t),
      (r.return = t),
      (r.sibling = s),
      (t.child = r),
      (r = s),
      (s = t.child),
      (o = e.child.memoizedState),
      (o =
        o === null
          ? Q0(n)
          : {
              baseLanes: o.baseLanes | n,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = e.childLanes & ~n),
      (t.memoizedState = W0),
      r
    );
  }
  return (
    (s = e.child),
    (e = s.sibling),
    (r = Zi(s, { mode: "visible", children: r.children })),
    !(t.mode & 1) && (r.lanes = n),
    (r.return = t),
    (r.sibling = null),
    e !== null &&
      ((n = t.deletions),
      n === null ? ((t.deletions = [e]), (t.flags |= 16)) : n.push(e)),
    (t.child = r),
    (t.memoizedState = null),
    r
  );
}
function Sv(e, t) {
  return (
    (t = Ph({ mode: "visible", children: t }, e.mode, 0, null)),
    (t.return = e),
    (e.child = t)
  );
}
function Ul(e, t, n, r) {
  return (
    r !== null && dv(r),
    ha(t, e.child, null, n),
    (e = Sv(t, t.pendingProps.children)),
    (e.flags |= 2),
    (t.memoizedState = null),
    e
  );
}
function D6(e, t, n, r, i, s, o) {
  if (n)
    return t.flags & 256
      ? ((t.flags &= -257), (r = fm(Error(U(422)))), Ul(e, t, o, r))
      : t.memoizedState !== null
      ? ((t.child = e.child), (t.flags |= 128), null)
      : ((s = r.fallback),
        (i = t.mode),
        (r = Ph({ mode: "visible", children: r.children }, i, 0, null)),
        (s = $s(s, i, o, null)),
        (s.flags |= 2),
        (r.return = t),
        (s.return = t),
        (r.sibling = s),
        (t.child = r),
        t.mode & 1 && ha(t, e.child, null, o),
        (t.child.memoizedState = Q0(o)),
        (t.memoizedState = W0),
        s);
  if (!(t.mode & 1)) return Ul(e, t, o, null);
  if (i.data === "$!") {
    if (((r = i.nextSibling && i.nextSibling.dataset), r)) var a = r.dgst;
    return (r = a), (s = Error(U(419))), (r = fm(s, r, void 0)), Ul(e, t, o, r);
  }
  if (((a = (o & e.childLanes) !== 0), pn || a)) {
    if (((r = Et), r !== null)) {
      switch (o & -o) {
        case 4:
          i = 2;
          break;
        case 16:
          i = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          i = 32;
          break;
        case 536870912:
          i = 268435456;
          break;
        default:
          i = 0;
      }
      (i = i & (r.suspendedLanes | o) ? 0 : i),
        i !== 0 &&
          i !== s.retryLane &&
          ((s.retryLane = i), ci(e, i), lr(r, e, i, -1));
    }
    return Dv(), (r = fm(Error(U(421)))), Ul(e, t, o, r);
  }
  return i.data === "$?"
    ? ((t.flags |= 128),
      (t.child = e.child),
      (t = G6.bind(null, e)),
      (i._reactRetry = t),
      null)
    : ((e = s.treeContext),
      (Cn = Wi(i.nextSibling)),
      (In = t),
      (Ke = !0),
      (ar = null),
      e !== null &&
        ((Gn[qn++] = Yr),
        (Gn[qn++] = Xr),
        (Gn[qn++] = Ks),
        (Yr = e.id),
        (Xr = e.overflow),
        (Ks = t)),
      (t = Sv(t, r.children)),
      (t.flags |= 4096),
      t);
}
function B1(e, t, n) {
  e.lanes |= t;
  var r = e.alternate;
  r !== null && (r.lanes |= t), U0(e.return, t, n);
}
function hm(e, t, n, r, i) {
  var s = e.memoizedState;
  s === null
    ? (e.memoizedState = {
        isBackwards: t,
        rendering: null,
        renderingStartTime: 0,
        last: r,
        tail: n,
        tailMode: i,
      })
    : ((s.isBackwards = t),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = r),
      (s.tail = n),
      (s.tailMode = i));
}
function Cx(e, t, n) {
  var r = t.pendingProps,
    i = r.revealOrder,
    s = r.tail;
  if ((en(e, t, r.children, n), (r = Je.current), r & 2))
    (r = (r & 1) | 2), (t.flags |= 128);
  else {
    if (e !== null && e.flags & 128)
      e: for (e = t.child; e !== null; ) {
        if (e.tag === 13) e.memoizedState !== null && B1(e, n, t);
        else if (e.tag === 19) B1(e, n, t);
        else if (e.child !== null) {
          (e.child.return = e), (e = e.child);
          continue;
        }
        if (e === t) break e;
        for (; e.sibling === null; ) {
          if (e.return === null || e.return === t) break e;
          e = e.return;
        }
        (e.sibling.return = e.return), (e = e.sibling);
      }
    r &= 1;
  }
  if ((ze(Je, r), !(t.mode & 1))) t.memoizedState = null;
  else
    switch (i) {
      case "forwards":
        for (n = t.child, i = null; n !== null; )
          (e = n.alternate),
            e !== null && tf(e) === null && (i = n),
            (n = n.sibling);
        (n = i),
          n === null
            ? ((i = t.child), (t.child = null))
            : ((i = n.sibling), (n.sibling = null)),
          hm(t, !1, i, n, s);
        break;
      case "backwards":
        for (n = null, i = t.child, t.child = null; i !== null; ) {
          if (((e = i.alternate), e !== null && tf(e) === null)) {
            t.child = i;
            break;
          }
          (e = i.sibling), (i.sibling = n), (n = i), (i = e);
        }
        hm(t, !0, n, null, s);
        break;
      case "together":
        hm(t, !1, null, null, void 0);
        break;
      default:
        t.memoizedState = null;
    }
  return t.child;
}
function md(e, t) {
  !(t.mode & 1) &&
    e !== null &&
    ((e.alternate = null), (t.alternate = null), (t.flags |= 2));
}
function li(e, t, n) {
  if (
    (e !== null && (t.dependencies = e.dependencies),
    (Js |= t.lanes),
    !(n & t.childLanes))
  )
    return null;
  if (e !== null && t.child !== e.child) throw Error(U(153));
  if (t.child !== null) {
    for (
      e = t.child, n = Zi(e, e.pendingProps), t.child = n, n.return = t;
      e.sibling !== null;

    )
      (e = e.sibling), (n = n.sibling = Zi(e, e.pendingProps)), (n.return = t);
    n.sibling = null;
  }
  return t.child;
}
function O6(e, t, n) {
  switch (t.tag) {
    case 3:
      xx(t), fa();
      break;
    case 5:
      XA(t);
      break;
    case 1:
      bn(t.type) && Kd(t);
      break;
    case 4:
      gv(t, t.stateNode.containerInfo);
      break;
    case 10:
      var r = t.type._context,
        i = t.memoizedProps.value;
      ze(Yd, r._currentValue), (r._currentValue = i);
      break;
    case 13:
      if (((r = t.memoizedState), r !== null))
        return r.dehydrated !== null
          ? (ze(Je, Je.current & 1), (t.flags |= 128), null)
          : n & t.child.childLanes
          ? Sx(e, t, n)
          : (ze(Je, Je.current & 1),
            (e = li(e, t, n)),
            e !== null ? e.sibling : null);
      ze(Je, Je.current & 1);
      break;
    case 19:
      if (((r = (n & t.childLanes) !== 0), e.flags & 128)) {
        if (r) return Cx(e, t, n);
        t.flags |= 128;
      }
      if (
        ((i = t.memoizedState),
        i !== null &&
          ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
        ze(Je, Je.current),
        r)
      )
        break;
      return null;
    case 22:
    case 23:
      return (t.lanes = 0), _x(e, t, n);
  }
  return li(e, t, n);
}
var Tx, V0, Ix, kx;
Tx = function (e, t) {
  for (var n = t.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === t) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === t) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
V0 = function () {};
Ix = function (e, t, n, r) {
  var i = e.memoizedProps;
  if (i !== r) {
    (e = t.stateNode), Os(Pr.current);
    var s = null;
    switch (n) {
      case "input":
        (i = y0(e, i)), (r = y0(e, r)), (s = []);
        break;
      case "select":
        (i = tt({}, i, { value: void 0 })),
          (r = tt({}, r, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (i = b0(e, i)), (r = b0(e, r)), (s = []);
        break;
      default:
        typeof i.onClick != "function" &&
          typeof r.onClick == "function" &&
          (e.onclick = Qd);
    }
    E0(n, r);
    var o;
    n = null;
    for (l in i)
      if (!r.hasOwnProperty(l) && i.hasOwnProperty(l) && i[l] != null)
        if (l === "style") {
          var a = i[l];
          for (o in a) a.hasOwnProperty(o) && (n || (n = {}), (n[o] = ""));
        } else
          l !== "dangerouslySetInnerHTML" &&
            l !== "children" &&
            l !== "suppressContentEditableWarning" &&
            l !== "suppressHydrationWarning" &&
            l !== "autoFocus" &&
            (qu.hasOwnProperty(l)
              ? s || (s = [])
              : (s = s || []).push(l, null));
    for (l in r) {
      var u = r[l];
      if (
        ((a = i != null ? i[l] : void 0),
        r.hasOwnProperty(l) && u !== a && (u != null || a != null))
      )
        if (l === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (u && u.hasOwnProperty(o)) ||
                (n || (n = {}), (n[o] = ""));
            for (o in u)
              u.hasOwnProperty(o) &&
                a[o] !== u[o] &&
                (n || (n = {}), (n[o] = u[o]));
          } else n || (s || (s = []), s.push(l, n)), (n = u);
        else
          l === "dangerouslySetInnerHTML"
            ? ((u = u ? u.__html : void 0),
              (a = a ? a.__html : void 0),
              u != null && a !== u && (s = s || []).push(l, u))
            : l === "children"
            ? (typeof u != "string" && typeof u != "number") ||
              (s = s || []).push(l, "" + u)
            : l !== "suppressContentEditableWarning" &&
              l !== "suppressHydrationWarning" &&
              (qu.hasOwnProperty(l)
                ? (u != null && l === "onScroll" && Ge("scroll", e),
                  s || a === u || (s = []))
                : (s = s || []).push(l, u));
    }
    n && (s = s || []).push("style", n);
    var l = s;
    (t.updateQueue = l) && (t.flags |= 4);
  }
};
kx = function (e, t, n, r) {
  n !== r && (t.flags |= 4);
};
function tu(e, t) {
  if (!Ke)
    switch (e.tailMode) {
      case "hidden":
        t = e.tail;
        for (var n = null; t !== null; )
          t.alternate !== null && (n = t), (t = t.sibling);
        n === null ? (e.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = e.tail;
        for (var r = null; n !== null; )
          n.alternate !== null && (r = n), (n = n.sibling);
        r === null
          ? t || e.tail === null
            ? (e.tail = null)
            : (e.tail.sibling = null)
          : (r.sibling = null);
    }
}
function Gt(e) {
  var t = e.alternate !== null && e.alternate.child === e.child,
    n = 0,
    r = 0;
  if (t)
    for (var i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags & 14680064),
        (r |= i.flags & 14680064),
        (i.return = e),
        (i = i.sibling);
  else
    for (i = e.child; i !== null; )
      (n |= i.lanes | i.childLanes),
        (r |= i.subtreeFlags),
        (r |= i.flags),
        (i.return = e),
        (i = i.sibling);
  return (e.subtreeFlags |= r), (e.childLanes = n), t;
}
function R6(e, t, n) {
  var r = t.pendingProps;
  switch ((lv(t), t.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return Gt(t), null;
    case 1:
      return bn(t.type) && Vd(), Gt(t), null;
    case 3:
      return (
        (r = t.stateNode),
        pa(),
        We(vn),
        We(Yt),
        bv(),
        r.pendingContext &&
          ((r.context = r.pendingContext), (r.pendingContext = null)),
        (e === null || e.child === null) &&
          (Fl(t)
            ? (t.flags |= 4)
            : e === null ||
              (e.memoizedState.isDehydrated && !(t.flags & 256)) ||
              ((t.flags |= 1024), ar !== null && (ny(ar), (ar = null)))),
        V0(e, t),
        Gt(t),
        null
      );
    case 5:
      vv(t);
      var i = Os(rc.current);
      if (((n = t.type), e !== null && t.stateNode != null))
        Ix(e, t, n, r, i),
          e.ref !== t.ref && ((t.flags |= 512), (t.flags |= 2097152));
      else {
        if (!r) {
          if (t.stateNode === null) throw Error(U(166));
          return Gt(t), null;
        }
        if (((e = Os(Pr.current)), Fl(t))) {
          (r = t.stateNode), (n = t.type);
          var s = t.memoizedProps;
          switch (((r[xr] = t), (r[tc] = s), (e = (t.mode & 1) !== 0), n)) {
            case "dialog":
              Ge("cancel", r), Ge("close", r);
              break;
            case "iframe":
            case "object":
            case "embed":
              Ge("load", r);
              break;
            case "video":
            case "audio":
              for (i = 0; i < vu.length; i++) Ge(vu[i], r);
              break;
            case "source":
              Ge("error", r);
              break;
            case "img":
            case "image":
            case "link":
              Ge("error", r), Ge("load", r);
              break;
            case "details":
              Ge("toggle", r);
              break;
            case "input":
              zw(r, s), Ge("invalid", r);
              break;
            case "select":
              (r._wrapperState = { wasMultiple: !!s.multiple }),
                Ge("invalid", r);
              break;
            case "textarea":
              qw(r, s), Ge("invalid", r);
          }
          E0(n, s), (i = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? r.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Ll(r.textContent, a, e),
                    (i = ["children", a]))
                  : typeof a == "number" &&
                    r.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      Ll(r.textContent, a, e),
                    (i = ["children", "" + a]))
                : qu.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  Ge("scroll", r);
            }
          switch (n) {
            case "input":
              kl(r), Gw(r, s, !0);
              break;
            case "textarea":
              kl(r), Ww(r);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (r.onclick = Qd);
          }
          (r = i), (t.updateQueue = r), r !== null && (t.flags |= 4);
        } else {
          (o = i.nodeType === 9 ? i : i.ownerDocument),
            e === "http://www.w3.org/1999/xhtml" && (e = nA(n)),
            e === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((e = o.createElement("div")),
                  (e.innerHTML = "<script></script>"),
                  (e = e.removeChild(e.firstChild)))
                : typeof r.is == "string"
                ? (e = o.createElement(n, { is: r.is }))
                : ((e = o.createElement(n)),
                  n === "select" &&
                    ((o = e),
                    r.multiple
                      ? (o.multiple = !0)
                      : r.size && (o.size = r.size)))
              : (e = o.createElementNS(e, n)),
            (e[xr] = t),
            (e[tc] = r),
            Tx(e, t, !1, !1),
            (t.stateNode = e);
          e: {
            switch (((o = _0(n, r)), n)) {
              case "dialog":
                Ge("cancel", e), Ge("close", e), (i = r);
                break;
              case "iframe":
              case "object":
              case "embed":
                Ge("load", e), (i = r);
                break;
              case "video":
              case "audio":
                for (i = 0; i < vu.length; i++) Ge(vu[i], e);
                i = r;
                break;
              case "source":
                Ge("error", e), (i = r);
                break;
              case "img":
              case "image":
              case "link":
                Ge("error", e), Ge("load", e), (i = r);
                break;
              case "details":
                Ge("toggle", e), (i = r);
                break;
              case "input":
                zw(e, r), (i = y0(e, r)), Ge("invalid", e);
                break;
              case "option":
                i = r;
                break;
              case "select":
                (e._wrapperState = { wasMultiple: !!r.multiple }),
                  (i = tt({}, r, { value: void 0 })),
                  Ge("invalid", e);
                break;
              case "textarea":
                qw(e, r), (i = b0(e, r)), Ge("invalid", e);
                break;
              default:
                i = r;
            }
            E0(n, i), (a = i);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var u = a[s];
                s === "style"
                  ? sA(e, u)
                  : s === "dangerouslySetInnerHTML"
                  ? ((u = u ? u.__html : void 0), u != null && rA(e, u))
                  : s === "children"
                  ? typeof u == "string"
                    ? (n !== "textarea" || u !== "") && Wu(e, u)
                    : typeof u == "number" && Wu(e, "" + u)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (qu.hasOwnProperty(s)
                      ? u != null && s === "onScroll" && Ge("scroll", e)
                      : u != null && Kg(e, s, u, o));
              }
            switch (n) {
              case "input":
                kl(e), Gw(e, r, !1);
                break;
              case "textarea":
                kl(e), Ww(e);
                break;
              case "option":
                r.value != null && e.setAttribute("value", "" + Xi(r.value));
                break;
              case "select":
                (e.multiple = !!r.multiple),
                  (s = r.value),
                  s != null
                    ? Zo(e, !!r.multiple, s, !1)
                    : r.defaultValue != null &&
                      Zo(e, !!r.multiple, r.defaultValue, !0);
                break;
              default:
                typeof i.onClick == "function" && (e.onclick = Qd);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                r = !!r.autoFocus;
                break e;
              case "img":
                r = !0;
                break e;
              default:
                r = !1;
            }
          }
          r && (t.flags |= 4);
        }
        t.ref !== null && ((t.flags |= 512), (t.flags |= 2097152));
      }
      return Gt(t), null;
    case 6:
      if (e && t.stateNode != null) kx(e, t, e.memoizedProps, r);
      else {
        if (typeof r != "string" && t.stateNode === null) throw Error(U(166));
        if (((n = Os(rc.current)), Os(Pr.current), Fl(t))) {
          if (
            ((r = t.stateNode),
            (n = t.memoizedProps),
            (r[xr] = t),
            (s = r.nodeValue !== n) && ((e = In), e !== null))
          )
            switch (e.tag) {
              case 3:
                Ll(r.nodeValue, n, (e.mode & 1) !== 0);
                break;
              case 5:
                e.memoizedProps.suppressHydrationWarning !== !0 &&
                  Ll(r.nodeValue, n, (e.mode & 1) !== 0);
            }
          s && (t.flags |= 4);
        } else
          (r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r)),
            (r[xr] = t),
            (t.stateNode = r);
      }
      return Gt(t), null;
    case 13:
      if (
        (We(Je),
        (r = t.memoizedState),
        e === null ||
          (e.memoizedState !== null && e.memoizedState.dehydrated !== null))
      ) {
        if (Ke && Cn !== null && t.mode & 1 && !(t.flags & 128))
          WA(), fa(), (t.flags |= 98560), (s = !1);
        else if (((s = Fl(t)), r !== null && r.dehydrated !== null)) {
          if (e === null) {
            if (!s) throw Error(U(318));
            if (
              ((s = t.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(U(317));
            s[xr] = t;
          } else
            fa(), !(t.flags & 128) && (t.memoizedState = null), (t.flags |= 4);
          Gt(t), (s = !1);
        } else ar !== null && (ny(ar), (ar = null)), (s = !0);
        if (!s) return t.flags & 65536 ? t : null;
      }
      return t.flags & 128
        ? ((t.lanes = n), t)
        : ((r = r !== null),
          r !== (e !== null && e.memoizedState !== null) &&
            r &&
            ((t.child.flags |= 8192),
            t.mode & 1 &&
              (e === null || Je.current & 1 ? ht === 0 && (ht = 3) : Dv())),
          t.updateQueue !== null && (t.flags |= 4),
          Gt(t),
          null);
    case 4:
      return (
        pa(), V0(e, t), e === null && Xu(t.stateNode.containerInfo), Gt(t), null
      );
    case 10:
      return pv(t.type._context), Gt(t), null;
    case 17:
      return bn(t.type) && Vd(), Gt(t), null;
    case 19:
      if ((We(Je), (s = t.memoizedState), s === null)) return Gt(t), null;
      if (((r = (t.flags & 128) !== 0), (o = s.rendering), o === null))
        if (r) tu(s, !1);
        else {
          if (ht !== 0 || (e !== null && e.flags & 128))
            for (e = t.child; e !== null; ) {
              if (((o = tf(e)), o !== null)) {
                for (
                  t.flags |= 128,
                    tu(s, !1),
                    r = o.updateQueue,
                    r !== null && ((t.updateQueue = r), (t.flags |= 4)),
                    t.subtreeFlags = 0,
                    r = n,
                    n = t.child;
                  n !== null;

                )
                  (s = n),
                    (e = r),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = e),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (e = o.dependencies),
                        (s.dependencies =
                          e === null
                            ? null
                            : {
                                lanes: e.lanes,
                                firstContext: e.firstContext,
                              })),
                    (n = n.sibling);
                return ze(Je, (Je.current & 1) | 2), t.child;
              }
              e = e.sibling;
            }
          s.tail !== null &&
            st() > ya &&
            ((t.flags |= 128), (r = !0), tu(s, !1), (t.lanes = 4194304));
        }
      else {
        if (!r)
          if (((e = tf(o)), e !== null)) {
            if (
              ((t.flags |= 128),
              (r = !0),
              (n = e.updateQueue),
              n !== null && ((t.updateQueue = n), (t.flags |= 4)),
              tu(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !Ke)
            )
              return Gt(t), null;
          } else
            2 * st() - s.renderingStartTime > ya &&
              n !== 1073741824 &&
              ((t.flags |= 128), (r = !0), tu(s, !1), (t.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = t.child), (t.child = o))
          : ((n = s.last),
            n !== null ? (n.sibling = o) : (t.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((t = s.tail),
          (s.rendering = t),
          (s.tail = t.sibling),
          (s.renderingStartTime = st()),
          (t.sibling = null),
          (n = Je.current),
          ze(Je, r ? (n & 1) | 2 : n & 1),
          t)
        : (Gt(t), null);
    case 22:
    case 23:
      return (
        Pv(),
        (r = t.memoizedState !== null),
        e !== null && (e.memoizedState !== null) !== r && (t.flags |= 8192),
        r && t.mode & 1
          ? xn & 1073741824 && (Gt(t), t.subtreeFlags & 6 && (t.flags |= 8192))
          : Gt(t),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(U(156, t.tag));
}
function B6(e, t) {
  switch ((lv(t), t.tag)) {
    case 1:
      return (
        bn(t.type) && Vd(),
        (e = t.flags),
        e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 3:
      return (
        pa(),
        We(vn),
        We(Yt),
        bv(),
        (e = t.flags),
        e & 65536 && !(e & 128) ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 5:
      return vv(t), null;
    case 13:
      if (
        (We(Je), (e = t.memoizedState), e !== null && e.dehydrated !== null)
      ) {
        if (t.alternate === null) throw Error(U(340));
        fa();
      }
      return (
        (e = t.flags), e & 65536 ? ((t.flags = (e & -65537) | 128), t) : null
      );
    case 19:
      return We(Je), null;
    case 4:
      return pa(), null;
    case 10:
      return pv(t.type._context), null;
    case 22:
    case 23:
      return Pv(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var $l = !1,
  Vt = !1,
  N6 = typeof WeakSet == "function" ? WeakSet : Set,
  J = null;
function Go(e, t) {
  var n = e.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (r) {
        rt(e, t, r);
      }
    else n.current = null;
}
function K0(e, t, n) {
  try {
    n();
  } catch (r) {
    rt(e, t, r);
  }
}
var N1 = !1;
function M6(e, t) {
  if (((O0 = Gd), (e = RA()), uv(e))) {
    if ("selectionStart" in e)
      var n = { start: e.selectionStart, end: e.selectionEnd };
    else
      e: {
        n = ((n = e.ownerDocument) && n.defaultView) || window;
        var r = n.getSelection && n.getSelection();
        if (r && r.rangeCount !== 0) {
          n = r.anchorNode;
          var i = r.anchorOffset,
            s = r.focusNode;
          r = r.focusOffset;
          try {
            n.nodeType, s.nodeType;
          } catch {
            n = null;
            break e;
          }
          var o = 0,
            a = -1,
            u = -1,
            l = 0,
            c = 0,
            d = e,
            f = null;
          t: for (;;) {
            for (
              var p;
              d !== n || (i !== 0 && d.nodeType !== 3) || (a = o + i),
                d !== s || (r !== 0 && d.nodeType !== 3) || (u = o + r),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (p = d.firstChild) !== null;

            )
              (f = d), (d = p);
            for (;;) {
              if (d === e) break t;
              if (
                (f === n && ++l === i && (a = o),
                f === s && ++c === r && (u = o),
                (p = d.nextSibling) !== null)
              )
                break;
              (d = f), (f = d.parentNode);
            }
            d = p;
          }
          n = a === -1 || u === -1 ? null : { start: a, end: u };
        } else n = null;
      }
    n = n || { start: 0, end: 0 };
  } else n = null;
  for (R0 = { focusedElem: e, selectionRange: n }, Gd = !1, J = t; J !== null; )
    if (((t = J), (e = t.child), (t.subtreeFlags & 1028) !== 0 && e !== null))
      (e.return = t), (J = e);
    else
      for (; J !== null; ) {
        t = J;
        try {
          var m = t.alternate;
          if (t.flags & 1024)
            switch (t.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (m !== null) {
                  var g = m.memoizedProps,
                    w = m.memoizedState,
                    v = t.stateNode,
                    y = v.getSnapshotBeforeUpdate(
                      t.elementType === t.type ? g : rr(t.type, g),
                      w
                    );
                  v.__reactInternalSnapshotBeforeUpdate = y;
                }
                break;
              case 3:
                var b = t.stateNode.containerInfo;
                b.nodeType === 1
                  ? (b.textContent = "")
                  : b.nodeType === 9 &&
                    b.documentElement &&
                    b.removeChild(b.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(U(163));
            }
        } catch (_) {
          rt(t, t.return, _);
        }
        if (((e = t.sibling), e !== null)) {
          (e.return = t.return), (J = e);
          break;
        }
        J = t.return;
      }
  return (m = N1), (N1 = !1), m;
}
function Ru(e, t, n) {
  var r = t.updateQueue;
  if (((r = r !== null ? r.lastEffect : null), r !== null)) {
    var i = (r = r.next);
    do {
      if ((i.tag & e) === e) {
        var s = i.destroy;
        (i.destroy = void 0), s !== void 0 && K0(t, n, s);
      }
      i = i.next;
    } while (i !== r);
  }
}
function Ih(e, t) {
  if (
    ((t = t.updateQueue), (t = t !== null ? t.lastEffect : null), t !== null)
  ) {
    var n = (t = t.next);
    do {
      if ((n.tag & e) === e) {
        var r = n.create;
        n.destroy = r();
      }
      n = n.next;
    } while (n !== t);
  }
}
function Z0(e) {
  var t = e.ref;
  if (t !== null) {
    var n = e.stateNode;
    switch (e.tag) {
      case 5:
        e = n;
        break;
      default:
        e = n;
    }
    typeof t == "function" ? t(e) : (t.current = e);
  }
}
function Px(e) {
  var t = e.alternate;
  t !== null && ((e.alternate = null), Px(t)),
    (e.child = null),
    (e.deletions = null),
    (e.sibling = null),
    e.tag === 5 &&
      ((t = e.stateNode),
      t !== null &&
        (delete t[xr], delete t[tc], delete t[M0], delete t[v6], delete t[b6])),
    (e.stateNode = null),
    (e.return = null),
    (e.dependencies = null),
    (e.memoizedProps = null),
    (e.memoizedState = null),
    (e.pendingProps = null),
    (e.stateNode = null),
    (e.updateQueue = null);
}
function Dx(e) {
  return e.tag === 5 || e.tag === 3 || e.tag === 4;
}
function M1(e) {
  e: for (;;) {
    for (; e.sibling === null; ) {
      if (e.return === null || Dx(e.return)) return null;
      e = e.return;
    }
    for (
      e.sibling.return = e.return, e = e.sibling;
      e.tag !== 5 && e.tag !== 6 && e.tag !== 18;

    ) {
      if (e.flags & 2 || e.child === null || e.tag === 4) continue e;
      (e.child.return = e), (e = e.child);
    }
    if (!(e.flags & 2)) return e.stateNode;
  }
}
function J0(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
    (e = e.stateNode),
      t
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(e, t)
          : n.insertBefore(e, t)
        : (n.nodeType === 8
            ? ((t = n.parentNode), t.insertBefore(e, n))
            : ((t = n), t.appendChild(e)),
          (n = n._reactRootContainer),
          n != null || t.onclick !== null || (t.onclick = Qd));
  else if (r !== 4 && ((e = e.child), e !== null))
    for (J0(e, t, n), e = e.sibling; e !== null; ) J0(e, t, n), (e = e.sibling);
}
function Y0(e, t, n) {
  var r = e.tag;
  if (r === 5 || r === 6)
    (e = e.stateNode), t ? n.insertBefore(e, t) : n.appendChild(e);
  else if (r !== 4 && ((e = e.child), e !== null))
    for (Y0(e, t, n), e = e.sibling; e !== null; ) Y0(e, t, n), (e = e.sibling);
}
var At = null,
  sr = !1;
function Ai(e, t, n) {
  for (n = n.child; n !== null; ) Ox(e, t, n), (n = n.sibling);
}
function Ox(e, t, n) {
  if (kr && typeof kr.onCommitFiberUnmount == "function")
    try {
      kr.onCommitFiberUnmount(wh, n);
    } catch {}
  switch (n.tag) {
    case 5:
      Vt || Go(n, t);
    case 6:
      var r = At,
        i = sr;
      (At = null),
        Ai(e, t, n),
        (At = r),
        (sr = i),
        At !== null &&
          (sr
            ? ((e = At),
              (n = n.stateNode),
              e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n))
            : At.removeChild(n.stateNode));
      break;
    case 18:
      At !== null &&
        (sr
          ? ((e = At),
            (n = n.stateNode),
            e.nodeType === 8
              ? om(e.parentNode, n)
              : e.nodeType === 1 && om(e, n),
            Zu(e))
          : om(At, n.stateNode));
      break;
    case 4:
      (r = At),
        (i = sr),
        (At = n.stateNode.containerInfo),
        (sr = !0),
        Ai(e, t, n),
        (At = r),
        (sr = i);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !Vt &&
        ((r = n.updateQueue), r !== null && ((r = r.lastEffect), r !== null))
      ) {
        i = r = r.next;
        do {
          var s = i,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && K0(n, t, o),
            (i = i.next);
        } while (i !== r);
      }
      Ai(e, t, n);
      break;
    case 1:
      if (
        !Vt &&
        (Go(n, t),
        (r = n.stateNode),
        typeof r.componentWillUnmount == "function")
      )
        try {
          (r.props = n.memoizedProps),
            (r.state = n.memoizedState),
            r.componentWillUnmount();
        } catch (a) {
          rt(n, t, a);
        }
      Ai(e, t, n);
      break;
    case 21:
      Ai(e, t, n);
      break;
    case 22:
      n.mode & 1
        ? ((Vt = (r = Vt) || n.memoizedState !== null), Ai(e, t, n), (Vt = r))
        : Ai(e, t, n);
      break;
    default:
      Ai(e, t, n);
  }
}
function L1(e) {
  var t = e.updateQueue;
  if (t !== null) {
    e.updateQueue = null;
    var n = e.stateNode;
    n === null && (n = e.stateNode = new N6()),
      t.forEach(function (r) {
        var i = q6.bind(null, e, r);
        n.has(r) || (n.add(r), r.then(i, i));
      });
  }
}
function nr(e, t) {
  var n = t.deletions;
  if (n !== null)
    for (var r = 0; r < n.length; r++) {
      var i = n[r];
      try {
        var s = e,
          o = t,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (At = a.stateNode), (sr = !1);
              break e;
            case 3:
              (At = a.stateNode.containerInfo), (sr = !0);
              break e;
            case 4:
              (At = a.stateNode.containerInfo), (sr = !0);
              break e;
          }
          a = a.return;
        }
        if (At === null) throw Error(U(160));
        Ox(s, o, i), (At = null), (sr = !1);
        var u = i.alternate;
        u !== null && (u.return = null), (i.return = null);
      } catch (l) {
        rt(i, t, l);
      }
    }
  if (t.subtreeFlags & 12854)
    for (t = t.child; t !== null; ) Rx(t, e), (t = t.sibling);
}
function Rx(e, t) {
  var n = e.alternate,
    r = e.flags;
  switch (e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((nr(t, e), vr(e), r & 4)) {
        try {
          Ru(3, e, e.return), Ih(3, e);
        } catch (g) {
          rt(e, e.return, g);
        }
        try {
          Ru(5, e, e.return);
        } catch (g) {
          rt(e, e.return, g);
        }
      }
      break;
    case 1:
      nr(t, e), vr(e), r & 512 && n !== null && Go(n, n.return);
      break;
    case 5:
      if (
        (nr(t, e),
        vr(e),
        r & 512 && n !== null && Go(n, n.return),
        e.flags & 32)
      ) {
        var i = e.stateNode;
        try {
          Wu(i, "");
        } catch (g) {
          rt(e, e.return, g);
        }
      }
      if (r & 4 && ((i = e.stateNode), i != null)) {
        var s = e.memoizedProps,
          o = n !== null ? n.memoizedProps : s,
          a = e.type,
          u = e.updateQueue;
        if (((e.updateQueue = null), u !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && eA(i, s),
              _0(a, o);
            var l = _0(a, s);
            for (o = 0; o < u.length; o += 2) {
              var c = u[o],
                d = u[o + 1];
              c === "style"
                ? sA(i, d)
                : c === "dangerouslySetInnerHTML"
                ? rA(i, d)
                : c === "children"
                ? Wu(i, d)
                : Kg(i, c, d, l);
            }
            switch (a) {
              case "input":
                g0(i, s);
                break;
              case "textarea":
                tA(i, s);
                break;
              case "select":
                var f = i._wrapperState.wasMultiple;
                i._wrapperState.wasMultiple = !!s.multiple;
                var p = s.value;
                p != null
                  ? Zo(i, !!s.multiple, p, !1)
                  : f !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Zo(i, !!s.multiple, s.defaultValue, !0)
                      : Zo(i, !!s.multiple, s.multiple ? [] : "", !1));
            }
            i[tc] = s;
          } catch (g) {
            rt(e, e.return, g);
          }
      }
      break;
    case 6:
      if ((nr(t, e), vr(e), r & 4)) {
        if (e.stateNode === null) throw Error(U(162));
        (i = e.stateNode), (s = e.memoizedProps);
        try {
          i.nodeValue = s;
        } catch (g) {
          rt(e, e.return, g);
        }
      }
      break;
    case 3:
      if (
        (nr(t, e), vr(e), r & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          Zu(t.containerInfo);
        } catch (g) {
          rt(e, e.return, g);
        }
      break;
    case 4:
      nr(t, e), vr(e);
      break;
    case 13:
      nr(t, e),
        vr(e),
        (i = e.child),
        i.flags & 8192 &&
          ((s = i.memoizedState !== null),
          (i.stateNode.isHidden = s),
          !s ||
            (i.alternate !== null && i.alternate.memoizedState !== null) ||
            (Iv = st())),
        r & 4 && L1(e);
      break;
    case 22:
      if (
        ((c = n !== null && n.memoizedState !== null),
        e.mode & 1 ? ((Vt = (l = Vt) || c), nr(t, e), (Vt = l)) : nr(t, e),
        vr(e),
        r & 8192)
      ) {
        if (
          ((l = e.memoizedState !== null),
          (e.stateNode.isHidden = l) && !c && e.mode & 1)
        )
          for (J = e, c = e.child; c !== null; ) {
            for (d = J = c; J !== null; ) {
              switch (((f = J), (p = f.child), f.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Ru(4, f, f.return);
                  break;
                case 1:
                  Go(f, f.return);
                  var m = f.stateNode;
                  if (typeof m.componentWillUnmount == "function") {
                    (r = f), (n = f.return);
                    try {
                      (t = r),
                        (m.props = t.memoizedProps),
                        (m.state = t.memoizedState),
                        m.componentWillUnmount();
                    } catch (g) {
                      rt(r, n, g);
                    }
                  }
                  break;
                case 5:
                  Go(f, f.return);
                  break;
                case 22:
                  if (f.memoizedState !== null) {
                    j1(d);
                    continue;
                  }
              }
              p !== null ? ((p.return = f), (J = p)) : j1(d);
            }
            c = c.sibling;
          }
        e: for (c = null, d = e; ; ) {
          if (d.tag === 5) {
            if (c === null) {
              c = d;
              try {
                (i = d.stateNode),
                  l
                    ? ((s = i.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (u = d.memoizedProps.style),
                      (o =
                        u != null && u.hasOwnProperty("display")
                          ? u.display
                          : null),
                      (a.style.display = iA("display", o)));
              } catch (g) {
                rt(e, e.return, g);
              }
            }
          } else if (d.tag === 6) {
            if (c === null)
              try {
                d.stateNode.nodeValue = l ? "" : d.memoizedProps;
              } catch (g) {
                rt(e, e.return, g);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === e) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === e) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === e) break e;
            c === d && (c = null), (d = d.return);
          }
          c === d && (c = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      nr(t, e), vr(e), r & 4 && L1(e);
      break;
    case 21:
      break;
    default:
      nr(t, e), vr(e);
  }
}
function vr(e) {
  var t = e.flags;
  if (t & 2) {
    try {
      e: {
        for (var n = e.return; n !== null; ) {
          if (Dx(n)) {
            var r = n;
            break e;
          }
          n = n.return;
        }
        throw Error(U(160));
      }
      switch (r.tag) {
        case 5:
          var i = r.stateNode;
          r.flags & 32 && (Wu(i, ""), (r.flags &= -33));
          var s = M1(e);
          Y0(e, s, i);
          break;
        case 3:
        case 4:
          var o = r.stateNode.containerInfo,
            a = M1(e);
          J0(e, a, o);
          break;
        default:
          throw Error(U(161));
      }
    } catch (u) {
      rt(e, e.return, u);
    }
    e.flags &= -3;
  }
  t & 4096 && (e.flags &= -4097);
}
function L6(e, t, n) {
  (J = e), Bx(e);
}
function Bx(e, t, n) {
  for (var r = (e.mode & 1) !== 0; J !== null; ) {
    var i = J,
      s = i.child;
    if (i.tag === 22 && r) {
      var o = i.memoizedState !== null || $l;
      if (!o) {
        var a = i.alternate,
          u = (a !== null && a.memoizedState !== null) || Vt;
        a = $l;
        var l = Vt;
        if ((($l = o), (Vt = u) && !l))
          for (J = i; J !== null; )
            (o = J),
              (u = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? U1(i)
                : u !== null
                ? ((u.return = o), (J = u))
                : U1(i);
        for (; s !== null; ) (J = s), Bx(s), (s = s.sibling);
        (J = i), ($l = a), (Vt = l);
      }
      F1(e);
    } else
      i.subtreeFlags & 8772 && s !== null ? ((s.return = i), (J = s)) : F1(e);
  }
}
function F1(e) {
  for (; J !== null; ) {
    var t = J;
    if (t.flags & 8772) {
      var n = t.alternate;
      try {
        if (t.flags & 8772)
          switch (t.tag) {
            case 0:
            case 11:
            case 15:
              Vt || Ih(5, t);
              break;
            case 1:
              var r = t.stateNode;
              if (t.flags & 4 && !Vt)
                if (n === null) r.componentDidMount();
                else {
                  var i =
                    t.elementType === t.type
                      ? n.memoizedProps
                      : rr(t.type, n.memoizedProps);
                  r.componentDidUpdate(
                    i,
                    n.memoizedState,
                    r.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = t.updateQueue;
              s !== null && E1(t, s, r);
              break;
            case 3:
              var o = t.updateQueue;
              if (o !== null) {
                if (((n = null), t.child !== null))
                  switch (t.child.tag) {
                    case 5:
                      n = t.child.stateNode;
                      break;
                    case 1:
                      n = t.child.stateNode;
                  }
                E1(t, o, n);
              }
              break;
            case 5:
              var a = t.stateNode;
              if (n === null && t.flags & 4) {
                n = a;
                var u = t.memoizedProps;
                switch (t.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    u.autoFocus && n.focus();
                    break;
                  case "img":
                    u.src && (n.src = u.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (t.memoizedState === null) {
                var l = t.alternate;
                if (l !== null) {
                  var c = l.memoizedState;
                  if (c !== null) {
                    var d = c.dehydrated;
                    d !== null && Zu(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(U(163));
          }
        Vt || (t.flags & 512 && Z0(t));
      } catch (f) {
        rt(t, t.return, f);
      }
    }
    if (t === e) {
      J = null;
      break;
    }
    if (((n = t.sibling), n !== null)) {
      (n.return = t.return), (J = n);
      break;
    }
    J = t.return;
  }
}
function j1(e) {
  for (; J !== null; ) {
    var t = J;
    if (t === e) {
      J = null;
      break;
    }
    var n = t.sibling;
    if (n !== null) {
      (n.return = t.return), (J = n);
      break;
    }
    J = t.return;
  }
}
function U1(e) {
  for (; J !== null; ) {
    var t = J;
    try {
      switch (t.tag) {
        case 0:
        case 11:
        case 15:
          var n = t.return;
          try {
            Ih(4, t);
          } catch (u) {
            rt(t, n, u);
          }
          break;
        case 1:
          var r = t.stateNode;
          if (typeof r.componentDidMount == "function") {
            var i = t.return;
            try {
              r.componentDidMount();
            } catch (u) {
              rt(t, i, u);
            }
          }
          var s = t.return;
          try {
            Z0(t);
          } catch (u) {
            rt(t, s, u);
          }
          break;
        case 5:
          var o = t.return;
          try {
            Z0(t);
          } catch (u) {
            rt(t, o, u);
          }
      }
    } catch (u) {
      rt(t, t.return, u);
    }
    if (t === e) {
      J = null;
      break;
    }
    var a = t.sibling;
    if (a !== null) {
      (a.return = t.return), (J = a);
      break;
    }
    J = t.return;
  }
}
var F6 = Math.ceil,
  sf = yi.ReactCurrentDispatcher,
  Cv = yi.ReactCurrentOwner,
  Zn = yi.ReactCurrentBatchConfig,
  Ce = 0,
  Et = null,
  ct = null,
  xt = 0,
  xn = 0,
  qo = fs(0),
  ht = 0,
  ac = null,
  Js = 0,
  kh = 0,
  Tv = 0,
  Bu = null,
  fn = null,
  Iv = 0,
  ya = 1 / 0,
  Gr = null,
  of = !1,
  X0 = null,
  Vi = null,
  Hl = !1,
  ji = null,
  af = 0,
  Nu = 0,
  ey = null,
  yd = -1,
  gd = 0;
function nn() {
  return Ce & 6 ? st() : yd !== -1 ? yd : (yd = st());
}
function Ki(e) {
  return e.mode & 1
    ? Ce & 2 && xt !== 0
      ? xt & -xt
      : E6.transition !== null
      ? (gd === 0 && (gd = gA()), gd)
      : ((e = Re),
        e !== 0 || ((e = window.event), (e = e === void 0 ? 16 : xA(e.type))),
        e)
    : 1;
}
function lr(e, t, n, r) {
  if (50 < Nu) throw ((Nu = 0), (ey = null), Error(U(185)));
  tl(e, n, r),
    (!(Ce & 2) || e !== Et) &&
      (e === Et && (!(Ce & 2) && (kh |= n), ht === 4 && Mi(e, xt)),
      wn(e, r),
      n === 1 && Ce === 0 && !(t.mode & 1) && ((ya = st() + 500), Sh && hs()));
}
function wn(e, t) {
  var n = e.callbackNode;
  EP(e, t);
  var r = zd(e, e === Et ? xt : 0);
  if (r === 0)
    n !== null && Kw(n), (e.callbackNode = null), (e.callbackPriority = 0);
  else if (((t = r & -r), e.callbackPriority !== t)) {
    if ((n != null && Kw(n), t === 1))
      e.tag === 0 ? w6($1.bind(null, e)) : zA($1.bind(null, e)),
        y6(function () {
          !(Ce & 6) && hs();
        }),
        (n = null);
    else {
      switch (vA(r)) {
        case 1:
          n = ev;
          break;
        case 4:
          n = mA;
          break;
        case 16:
          n = Hd;
          break;
        case 536870912:
          n = yA;
          break;
        default:
          n = Hd;
      }
      n = Hx(n, Nx.bind(null, e));
    }
    (e.callbackPriority = t), (e.callbackNode = n);
  }
}
function Nx(e, t) {
  if (((yd = -1), (gd = 0), Ce & 6)) throw Error(U(327));
  var n = e.callbackNode;
  if (ta() && e.callbackNode !== n) return null;
  var r = zd(e, e === Et ? xt : 0);
  if (r === 0) return null;
  if (r & 30 || r & e.expiredLanes || t) t = uf(e, r);
  else {
    t = r;
    var i = Ce;
    Ce |= 2;
    var s = Lx();
    (Et !== e || xt !== t) && ((Gr = null), (ya = st() + 500), Us(e, t));
    do
      try {
        $6();
        break;
      } catch (a) {
        Mx(e, a);
      }
    while (!0);
    hv(),
      (sf.current = s),
      (Ce = i),
      ct !== null ? (t = 0) : ((Et = null), (xt = 0), (t = ht));
  }
  if (t !== 0) {
    if (
      (t === 2 && ((i = T0(e)), i !== 0 && ((r = i), (t = ty(e, i)))), t === 1)
    )
      throw ((n = ac), Us(e, 0), Mi(e, r), wn(e, st()), n);
    if (t === 6) Mi(e, r);
    else {
      if (
        ((i = e.current.alternate),
        !(r & 30) &&
          !j6(i) &&
          ((t = uf(e, r)),
          t === 2 && ((s = T0(e)), s !== 0 && ((r = s), (t = ty(e, s)))),
          t === 1))
      )
        throw ((n = ac), Us(e, 0), Mi(e, r), wn(e, st()), n);
      switch (((e.finishedWork = i), (e.finishedLanes = r), t)) {
        case 0:
        case 1:
          throw Error(U(345));
        case 2:
          Cs(e, fn, Gr);
          break;
        case 3:
          if (
            (Mi(e, r), (r & 130023424) === r && ((t = Iv + 500 - st()), 10 < t))
          ) {
            if (zd(e, 0) !== 0) break;
            if (((i = e.suspendedLanes), (i & r) !== r)) {
              nn(), (e.pingedLanes |= e.suspendedLanes & i);
              break;
            }
            e.timeoutHandle = N0(Cs.bind(null, e, fn, Gr), t);
            break;
          }
          Cs(e, fn, Gr);
          break;
        case 4:
          if ((Mi(e, r), (r & 4194240) === r)) break;
          for (t = e.eventTimes, i = -1; 0 < r; ) {
            var o = 31 - cr(r);
            (s = 1 << o), (o = t[o]), o > i && (i = o), (r &= ~s);
          }
          if (
            ((r = i),
            (r = st() - r),
            (r =
              (120 > r
                ? 120
                : 480 > r
                ? 480
                : 1080 > r
                ? 1080
                : 1920 > r
                ? 1920
                : 3e3 > r
                ? 3e3
                : 4320 > r
                ? 4320
                : 1960 * F6(r / 1960)) - r),
            10 < r)
          ) {
            e.timeoutHandle = N0(Cs.bind(null, e, fn, Gr), r);
            break;
          }
          Cs(e, fn, Gr);
          break;
        case 5:
          Cs(e, fn, Gr);
          break;
        default:
          throw Error(U(329));
      }
    }
  }
  return wn(e, st()), e.callbackNode === n ? Nx.bind(null, e) : null;
}
function ty(e, t) {
  var n = Bu;
  return (
    e.current.memoizedState.isDehydrated && (Us(e, t).flags |= 256),
    (e = uf(e, t)),
    e !== 2 && ((t = fn), (fn = n), t !== null && ny(t)),
    e
  );
}
function ny(e) {
  fn === null ? (fn = e) : fn.push.apply(fn, e);
}
function j6(e) {
  for (var t = e; ; ) {
    if (t.flags & 16384) {
      var n = t.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var r = 0; r < n.length; r++) {
          var i = n[r],
            s = i.getSnapshot;
          i = i.value;
          try {
            if (!hr(s(), i)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = t.child), t.subtreeFlags & 16384 && n !== null))
      (n.return = t), (t = n);
    else {
      if (t === e) break;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return !0;
        t = t.return;
      }
      (t.sibling.return = t.return), (t = t.sibling);
    }
  }
  return !0;
}
function Mi(e, t) {
  for (
    t &= ~Tv,
      t &= ~kh,
      e.suspendedLanes |= t,
      e.pingedLanes &= ~t,
      e = e.expirationTimes;
    0 < t;

  ) {
    var n = 31 - cr(t),
      r = 1 << n;
    (e[n] = -1), (t &= ~r);
  }
}
function $1(e) {
  if (Ce & 6) throw Error(U(327));
  ta();
  var t = zd(e, 0);
  if (!(t & 1)) return wn(e, st()), null;
  var n = uf(e, t);
  if (e.tag !== 0 && n === 2) {
    var r = T0(e);
    r !== 0 && ((t = r), (n = ty(e, r)));
  }
  if (n === 1) throw ((n = ac), Us(e, 0), Mi(e, t), wn(e, st()), n);
  if (n === 6) throw Error(U(345));
  return (
    (e.finishedWork = e.current.alternate),
    (e.finishedLanes = t),
    Cs(e, fn, Gr),
    wn(e, st()),
    null
  );
}
function kv(e, t) {
  var n = Ce;
  Ce |= 1;
  try {
    return e(t);
  } finally {
    (Ce = n), Ce === 0 && ((ya = st() + 500), Sh && hs());
  }
}
function Ys(e) {
  ji !== null && ji.tag === 0 && !(Ce & 6) && ta();
  var t = Ce;
  Ce |= 1;
  var n = Zn.transition,
    r = Re;
  try {
    if (((Zn.transition = null), (Re = 1), e)) return e();
  } finally {
    (Re = r), (Zn.transition = n), (Ce = t), !(Ce & 6) && hs();
  }
}
function Pv() {
  (xn = qo.current), We(qo);
}
function Us(e, t) {
  (e.finishedWork = null), (e.finishedLanes = 0);
  var n = e.timeoutHandle;
  if ((n !== -1 && ((e.timeoutHandle = -1), m6(n)), ct !== null))
    for (n = ct.return; n !== null; ) {
      var r = n;
      switch ((lv(r), r.tag)) {
        case 1:
          (r = r.type.childContextTypes), r != null && Vd();
          break;
        case 3:
          pa(), We(vn), We(Yt), bv();
          break;
        case 5:
          vv(r);
          break;
        case 4:
          pa();
          break;
        case 13:
          We(Je);
          break;
        case 19:
          We(Je);
          break;
        case 10:
          pv(r.type._context);
          break;
        case 22:
        case 23:
          Pv();
      }
      n = n.return;
    }
  if (
    ((Et = e),
    (ct = e = Zi(e.current, null)),
    (xt = xn = t),
    (ht = 0),
    (ac = null),
    (Tv = kh = Js = 0),
    (fn = Bu = null),
    Ds !== null)
  ) {
    for (t = 0; t < Ds.length; t++)
      if (((n = Ds[t]), (r = n.interleaved), r !== null)) {
        n.interleaved = null;
        var i = r.next,
          s = n.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = i), (r.next = o);
        }
        n.pending = r;
      }
    Ds = null;
  }
  return e;
}
function Mx(e, t) {
  do {
    var n = ct;
    try {
      if ((hv(), (hd.current = rf), nf)) {
        for (var r = et.memoizedState; r !== null; ) {
          var i = r.queue;
          i !== null && (i.pending = null), (r = r.next);
        }
        nf = !1;
      }
      if (
        ((Zs = 0),
        (bt = ft = et = null),
        (Ou = !1),
        (ic = 0),
        (Cv.current = null),
        n === null || n.return === null)
      ) {
        (ht = 1), (ac = t), (ct = null);
        break;
      }
      e: {
        var s = e,
          o = n.return,
          a = n,
          u = t;
        if (
          ((t = xt),
          (a.flags |= 32768),
          u !== null && typeof u == "object" && typeof u.then == "function")
        ) {
          var l = u,
            c = a,
            d = c.tag;
          if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var f = c.alternate;
            f
              ? ((c.updateQueue = f.updateQueue),
                (c.memoizedState = f.memoizedState),
                (c.lanes = f.lanes))
              : ((c.updateQueue = null), (c.memoizedState = null));
          }
          var p = I1(o);
          if (p !== null) {
            (p.flags &= -257),
              k1(p, o, a, s, t),
              p.mode & 1 && T1(s, l, t),
              (t = p),
              (u = l);
            var m = t.updateQueue;
            if (m === null) {
              var g = new Set();
              g.add(u), (t.updateQueue = g);
            } else m.add(u);
            break e;
          } else {
            if (!(t & 1)) {
              T1(s, l, t), Dv();
              break e;
            }
            u = Error(U(426));
          }
        } else if (Ke && a.mode & 1) {
          var w = I1(o);
          if (w !== null) {
            !(w.flags & 65536) && (w.flags |= 256),
              k1(w, o, a, s, t),
              dv(ma(u, a));
            break e;
          }
        }
        (s = u = ma(u, a)),
          ht !== 4 && (ht = 2),
          Bu === null ? (Bu = [s]) : Bu.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (t &= -t), (s.lanes |= t);
              var v = bx(s, u, t);
              w1(s, v);
              break e;
            case 1:
              a = u;
              var y = s.type,
                b = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof y.getDerivedStateFromError == "function" ||
                  (b !== null &&
                    typeof b.componentDidCatch == "function" &&
                    (Vi === null || !Vi.has(b))))
              ) {
                (s.flags |= 65536), (t &= -t), (s.lanes |= t);
                var _ = wx(s, a, t);
                w1(s, _);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      jx(n);
    } catch (A) {
      (t = A), ct === n && n !== null && (ct = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function Lx() {
  var e = sf.current;
  return (sf.current = rf), e === null ? rf : e;
}
function Dv() {
  (ht === 0 || ht === 3 || ht === 2) && (ht = 4),
    Et === null || (!(Js & 268435455) && !(kh & 268435455)) || Mi(Et, xt);
}
function uf(e, t) {
  var n = Ce;
  Ce |= 2;
  var r = Lx();
  (Et !== e || xt !== t) && ((Gr = null), Us(e, t));
  do
    try {
      U6();
      break;
    } catch (i) {
      Mx(e, i);
    }
  while (!0);
  if ((hv(), (Ce = n), (sf.current = r), ct !== null)) throw Error(U(261));
  return (Et = null), (xt = 0), ht;
}
function U6() {
  for (; ct !== null; ) Fx(ct);
}
function $6() {
  for (; ct !== null && !fP(); ) Fx(ct);
}
function Fx(e) {
  var t = $x(e.alternate, e, xn);
  (e.memoizedProps = e.pendingProps),
    t === null ? jx(e) : (ct = t),
    (Cv.current = null);
}
function jx(e) {
  var t = e;
  do {
    var n = t.alternate;
    if (((e = t.return), t.flags & 32768)) {
      if (((n = B6(n, t)), n !== null)) {
        (n.flags &= 32767), (ct = n);
        return;
      }
      if (e !== null)
        (e.flags |= 32768), (e.subtreeFlags = 0), (e.deletions = null);
      else {
        (ht = 6), (ct = null);
        return;
      }
    } else if (((n = R6(n, t, xn)), n !== null)) {
      ct = n;
      return;
    }
    if (((t = t.sibling), t !== null)) {
      ct = t;
      return;
    }
    ct = t = e;
  } while (t !== null);
  ht === 0 && (ht = 5);
}
function Cs(e, t, n) {
  var r = Re,
    i = Zn.transition;
  try {
    (Zn.transition = null), (Re = 1), H6(e, t, n, r);
  } finally {
    (Zn.transition = i), (Re = r);
  }
  return null;
}
function H6(e, t, n, r) {
  do ta();
  while (ji !== null);
  if (Ce & 6) throw Error(U(327));
  n = e.finishedWork;
  var i = e.finishedLanes;
  if (n === null) return null;
  if (((e.finishedWork = null), (e.finishedLanes = 0), n === e.current))
    throw Error(U(177));
  (e.callbackNode = null), (e.callbackPriority = 0);
  var s = n.lanes | n.childLanes;
  if (
    (_P(e, s),
    e === Et && ((ct = Et = null), (xt = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Hl ||
      ((Hl = !0),
      Hx(Hd, function () {
        return ta(), null;
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    (s = Zn.transition), (Zn.transition = null);
    var o = Re;
    Re = 1;
    var a = Ce;
    (Ce |= 4),
      (Cv.current = null),
      M6(e, n),
      Rx(n, e),
      u6(R0),
      (Gd = !!O0),
      (R0 = O0 = null),
      (e.current = n),
      L6(n),
      hP(),
      (Ce = a),
      (Re = o),
      (Zn.transition = s);
  } else e.current = n;
  if (
    (Hl && ((Hl = !1), (ji = e), (af = i)),
    (s = e.pendingLanes),
    s === 0 && (Vi = null),
    yP(n.stateNode),
    wn(e, st()),
    t !== null)
  )
    for (r = e.onRecoverableError, n = 0; n < t.length; n++)
      (i = t[n]), r(i.value, { componentStack: i.stack, digest: i.digest });
  if (of) throw ((of = !1), (e = X0), (X0 = null), e);
  return (
    af & 1 && e.tag !== 0 && ta(),
    (s = e.pendingLanes),
    s & 1 ? (e === ey ? Nu++ : ((Nu = 0), (ey = e))) : (Nu = 0),
    hs(),
    null
  );
}
function ta() {
  if (ji !== null) {
    var e = vA(af),
      t = Zn.transition,
      n = Re;
    try {
      if (((Zn.transition = null), (Re = 16 > e ? 16 : e), ji === null))
        var r = !1;
      else {
        if (((e = ji), (ji = null), (af = 0), Ce & 6)) throw Error(U(331));
        var i = Ce;
        for (Ce |= 4, J = e.current; J !== null; ) {
          var s = J,
            o = s.child;
          if (J.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var u = 0; u < a.length; u++) {
                var l = a[u];
                for (J = l; J !== null; ) {
                  var c = J;
                  switch (c.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ru(8, c, s);
                  }
                  var d = c.child;
                  if (d !== null) (d.return = c), (J = d);
                  else
                    for (; J !== null; ) {
                      c = J;
                      var f = c.sibling,
                        p = c.return;
                      if ((Px(c), c === l)) {
                        J = null;
                        break;
                      }
                      if (f !== null) {
                        (f.return = p), (J = f);
                        break;
                      }
                      J = p;
                    }
                }
              }
              var m = s.alternate;
              if (m !== null) {
                var g = m.child;
                if (g !== null) {
                  m.child = null;
                  do {
                    var w = g.sibling;
                    (g.sibling = null), (g = w);
                  } while (g !== null);
                }
              }
              J = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (J = o);
          else
            e: for (; J !== null; ) {
              if (((s = J), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Ru(9, s, s.return);
                }
              var v = s.sibling;
              if (v !== null) {
                (v.return = s.return), (J = v);
                break e;
              }
              J = s.return;
            }
        }
        var y = e.current;
        for (J = y; J !== null; ) {
          o = J;
          var b = o.child;
          if (o.subtreeFlags & 2064 && b !== null) (b.return = o), (J = b);
          else
            e: for (o = y; J !== null; ) {
              if (((a = J), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Ih(9, a);
                  }
                } catch (A) {
                  rt(a, a.return, A);
                }
              if (a === o) {
                J = null;
                break e;
              }
              var _ = a.sibling;
              if (_ !== null) {
                (_.return = a.return), (J = _);
                break e;
              }
              J = a.return;
            }
        }
        if (
          ((Ce = i), hs(), kr && typeof kr.onPostCommitFiberRoot == "function")
        )
          try {
            kr.onPostCommitFiberRoot(wh, e);
          } catch {}
        r = !0;
      }
      return r;
    } finally {
      (Re = n), (Zn.transition = t);
    }
  }
  return !1;
}
function H1(e, t, n) {
  (t = ma(n, t)),
    (t = bx(e, t, 1)),
    (e = Qi(e, t, 1)),
    (t = nn()),
    e !== null && (tl(e, 1, t), wn(e, t));
}
function rt(e, t, n) {
  if (e.tag === 3) H1(e, e, n);
  else
    for (; t !== null; ) {
      if (t.tag === 3) {
        H1(t, e, n);
        break;
      } else if (t.tag === 1) {
        var r = t.stateNode;
        if (
          typeof t.type.getDerivedStateFromError == "function" ||
          (typeof r.componentDidCatch == "function" &&
            (Vi === null || !Vi.has(r)))
        ) {
          (e = ma(n, e)),
            (e = wx(t, e, 1)),
            (t = Qi(t, e, 1)),
            (e = nn()),
            t !== null && (tl(t, 1, e), wn(t, e));
          break;
        }
      }
      t = t.return;
    }
}
function z6(e, t, n) {
  var r = e.pingCache;
  r !== null && r.delete(t),
    (t = nn()),
    (e.pingedLanes |= e.suspendedLanes & n),
    Et === e &&
      (xt & n) === n &&
      (ht === 4 || (ht === 3 && (xt & 130023424) === xt && 500 > st() - Iv)
        ? Us(e, 0)
        : (Tv |= n)),
    wn(e, t);
}
function Ux(e, t) {
  t === 0 &&
    (e.mode & 1
      ? ((t = Ol), (Ol <<= 1), !(Ol & 130023424) && (Ol = 4194304))
      : (t = 1));
  var n = nn();
  (e = ci(e, t)), e !== null && (tl(e, t, n), wn(e, n));
}
function G6(e) {
  var t = e.memoizedState,
    n = 0;
  t !== null && (n = t.retryLane), Ux(e, n);
}
function q6(e, t) {
  var n = 0;
  switch (e.tag) {
    case 13:
      var r = e.stateNode,
        i = e.memoizedState;
      i !== null && (n = i.retryLane);
      break;
    case 19:
      r = e.stateNode;
      break;
    default:
      throw Error(U(314));
  }
  r !== null && r.delete(t), Ux(e, n);
}
var $x;
$x = function (e, t, n) {
  if (e !== null)
    if (e.memoizedProps !== t.pendingProps || vn.current) pn = !0;
    else {
      if (!(e.lanes & n) && !(t.flags & 128)) return (pn = !1), O6(e, t, n);
      pn = !!(e.flags & 131072);
    }
  else (pn = !1), Ke && t.flags & 1048576 && GA(t, Jd, t.index);
  switch (((t.lanes = 0), t.tag)) {
    case 2:
      var r = t.type;
      md(e, t), (e = t.pendingProps);
      var i = da(t, Yt.current);
      ea(t, n), (i = Ev(null, t, r, e, i, n));
      var s = _v();
      return (
        (t.flags |= 1),
        typeof i == "object" &&
        i !== null &&
        typeof i.render == "function" &&
        i.$$typeof === void 0
          ? ((t.tag = 1),
            (t.memoizedState = null),
            (t.updateQueue = null),
            bn(r) ? ((s = !0), Kd(t)) : (s = !1),
            (t.memoizedState =
              i.state !== null && i.state !== void 0 ? i.state : null),
            yv(t),
            (i.updater = Ch),
            (t.stateNode = i),
            (i._reactInternals = t),
            H0(t, r, e, n),
            (t = q0(null, t, r, !0, s, n)))
          : ((t.tag = 0), Ke && s && cv(t), en(null, t, i, n), (t = t.child)),
        t
      );
    case 16:
      r = t.elementType;
      e: {
        switch (
          (md(e, t),
          (e = t.pendingProps),
          (i = r._init),
          (r = i(r._payload)),
          (t.type = r),
          (i = t.tag = Q6(r)),
          (e = rr(r, e)),
          i)
        ) {
          case 0:
            t = G0(null, t, r, e, n);
            break e;
          case 1:
            t = O1(null, t, r, e, n);
            break e;
          case 11:
            t = P1(null, t, r, e, n);
            break e;
          case 14:
            t = D1(null, t, r, rr(r.type, e), n);
            break e;
        }
        throw Error(U(306, r, ""));
      }
      return t;
    case 0:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : rr(r, i)),
        G0(e, t, r, i, n)
      );
    case 1:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : rr(r, i)),
        O1(e, t, r, i, n)
      );
    case 3:
      e: {
        if ((xx(t), e === null)) throw Error(U(387));
        (r = t.pendingProps),
          (s = t.memoizedState),
          (i = s.element),
          VA(e, t),
          ef(t, r, null, n);
        var o = t.memoizedState;
        if (((r = o.element), s.isDehydrated))
          if (
            ((s = {
              element: r,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (t.updateQueue.baseState = s),
            (t.memoizedState = s),
            t.flags & 256)
          ) {
            (i = ma(Error(U(423)), t)), (t = R1(e, t, r, n, i));
            break e;
          } else if (r !== i) {
            (i = ma(Error(U(424)), t)), (t = R1(e, t, r, n, i));
            break e;
          } else
            for (
              Cn = Wi(t.stateNode.containerInfo.firstChild),
                In = t,
                Ke = !0,
                ar = null,
                n = YA(t, null, r, n),
                t.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((fa(), r === i)) {
            t = li(e, t, n);
            break e;
          }
          en(e, t, r, n);
        }
        t = t.child;
      }
      return t;
    case 5:
      return (
        XA(t),
        e === null && j0(t),
        (r = t.type),
        (i = t.pendingProps),
        (s = e !== null ? e.memoizedProps : null),
        (o = i.children),
        B0(r, i) ? (o = null) : s !== null && B0(r, s) && (t.flags |= 32),
        Ax(e, t),
        en(e, t, o, n),
        t.child
      );
    case 6:
      return e === null && j0(t), null;
    case 13:
      return Sx(e, t, n);
    case 4:
      return (
        gv(t, t.stateNode.containerInfo),
        (r = t.pendingProps),
        e === null ? (t.child = ha(t, null, r, n)) : en(e, t, r, n),
        t.child
      );
    case 11:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : rr(r, i)),
        P1(e, t, r, i, n)
      );
    case 7:
      return en(e, t, t.pendingProps, n), t.child;
    case 8:
      return en(e, t, t.pendingProps.children, n), t.child;
    case 12:
      return en(e, t, t.pendingProps.children, n), t.child;
    case 10:
      e: {
        if (
          ((r = t.type._context),
          (i = t.pendingProps),
          (s = t.memoizedProps),
          (o = i.value),
          ze(Yd, r._currentValue),
          (r._currentValue = o),
          s !== null)
        )
          if (hr(s.value, o)) {
            if (s.children === i.children && !vn.current) {
              t = li(e, t, n);
              break e;
            }
          } else
            for (s = t.child, s !== null && (s.return = t); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var u = a.firstContext; u !== null; ) {
                  if (u.context === r) {
                    if (s.tag === 1) {
                      (u = ri(-1, n & -n)), (u.tag = 2);
                      var l = s.updateQueue;
                      if (l !== null) {
                        l = l.shared;
                        var c = l.pending;
                        c === null
                          ? (u.next = u)
                          : ((u.next = c.next), (c.next = u)),
                          (l.pending = u);
                      }
                    }
                    (s.lanes |= n),
                      (u = s.alternate),
                      u !== null && (u.lanes |= n),
                      U0(s.return, n, t),
                      (a.lanes |= n);
                    break;
                  }
                  u = u.next;
                }
              } else if (s.tag === 10) o = s.type === t.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(U(341));
                (o.lanes |= n),
                  (a = o.alternate),
                  a !== null && (a.lanes |= n),
                  U0(o, n, t),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === t) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        en(e, t, i.children, n), (t = t.child);
      }
      return t;
    case 9:
      return (
        (i = t.type),
        (r = t.pendingProps.children),
        ea(t, n),
        (i = Yn(i)),
        (r = r(i)),
        (t.flags |= 1),
        en(e, t, r, n),
        t.child
      );
    case 14:
      return (
        (r = t.type),
        (i = rr(r, t.pendingProps)),
        (i = rr(r.type, i)),
        D1(e, t, r, i, n)
      );
    case 15:
      return Ex(e, t, t.type, t.pendingProps, n);
    case 17:
      return (
        (r = t.type),
        (i = t.pendingProps),
        (i = t.elementType === r ? i : rr(r, i)),
        md(e, t),
        (t.tag = 1),
        bn(r) ? ((e = !0), Kd(t)) : (e = !1),
        ea(t, n),
        ZA(t, r, i),
        H0(t, r, i, n),
        q0(null, t, r, !0, e, n)
      );
    case 19:
      return Cx(e, t, n);
    case 22:
      return _x(e, t, n);
  }
  throw Error(U(156, t.tag));
};
function Hx(e, t) {
  return pA(e, t);
}
function W6(e, t, n, r) {
  (this.tag = e),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = t),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = r),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function Qn(e, t, n, r) {
  return new W6(e, t, n, r);
}
function Ov(e) {
  return (e = e.prototype), !(!e || !e.isReactComponent);
}
function Q6(e) {
  if (typeof e == "function") return Ov(e) ? 1 : 0;
  if (e != null) {
    if (((e = e.$$typeof), e === Jg)) return 11;
    if (e === Yg) return 14;
  }
  return 2;
}
function Zi(e, t) {
  var n = e.alternate;
  return (
    n === null
      ? ((n = Qn(e.tag, t, e.key, e.mode)),
        (n.elementType = e.elementType),
        (n.type = e.type),
        (n.stateNode = e.stateNode),
        (n.alternate = e),
        (e.alternate = n))
      : ((n.pendingProps = t),
        (n.type = e.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = e.flags & 14680064),
    (n.childLanes = e.childLanes),
    (n.lanes = e.lanes),
    (n.child = e.child),
    (n.memoizedProps = e.memoizedProps),
    (n.memoizedState = e.memoizedState),
    (n.updateQueue = e.updateQueue),
    (t = e.dependencies),
    (n.dependencies =
      t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }),
    (n.sibling = e.sibling),
    (n.index = e.index),
    (n.ref = e.ref),
    n
  );
}
function vd(e, t, n, r, i, s) {
  var o = 2;
  if (((r = e), typeof e == "function")) Ov(e) && (o = 1);
  else if (typeof e == "string") o = 5;
  else
    e: switch (e) {
      case No:
        return $s(n.children, i, s, t);
      case Zg:
        (o = 8), (i |= 8);
        break;
      case f0:
        return (
          (e = Qn(12, n, t, i | 2)), (e.elementType = f0), (e.lanes = s), e
        );
      case h0:
        return (e = Qn(13, n, t, i)), (e.elementType = h0), (e.lanes = s), e;
      case p0:
        return (e = Qn(19, n, t, i)), (e.elementType = p0), (e.lanes = s), e;
      case J2:
        return Ph(n, i, s, t);
      default:
        if (typeof e == "object" && e !== null)
          switch (e.$$typeof) {
            case K2:
              o = 10;
              break e;
            case Z2:
              o = 9;
              break e;
            case Jg:
              o = 11;
              break e;
            case Yg:
              o = 14;
              break e;
            case Di:
              (o = 16), (r = null);
              break e;
          }
        throw Error(U(130, e == null ? e : typeof e, ""));
    }
  return (
    (t = Qn(o, n, t, i)), (t.elementType = e), (t.type = r), (t.lanes = s), t
  );
}
function $s(e, t, n, r) {
  return (e = Qn(7, e, r, t)), (e.lanes = n), e;
}
function Ph(e, t, n, r) {
  return (
    (e = Qn(22, e, r, t)),
    (e.elementType = J2),
    (e.lanes = n),
    (e.stateNode = { isHidden: !1 }),
    e
  );
}
function pm(e, t, n) {
  return (e = Qn(6, e, null, t)), (e.lanes = n), e;
}
function mm(e, t, n) {
  return (
    (t = Qn(4, e.children !== null ? e.children : [], e.key, t)),
    (t.lanes = n),
    (t.stateNode = {
      containerInfo: e.containerInfo,
      pendingChildren: null,
      implementation: e.implementation,
    }),
    t
  );
}
function V6(e, t, n, r, i) {
  (this.tag = t),
    (this.containerInfo = e),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Kp(0)),
    (this.expirationTimes = Kp(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Kp(0)),
    (this.identifierPrefix = r),
    (this.onRecoverableError = i),
    (this.mutableSourceEagerHydrationData = null);
}
function Rv(e, t, n, r, i, s, o, a, u) {
  return (
    (e = new V6(e, t, n, a, u)),
    t === 1 ? ((t = 1), s === !0 && (t |= 8)) : (t = 0),
    (s = Qn(3, null, null, t)),
    (e.current = s),
    (s.stateNode = e),
    (s.memoizedState = {
      element: r,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    yv(s),
    e
  );
}
function K6(e, t, n) {
  var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Bo,
    key: r == null ? null : "" + r,
    children: e,
    containerInfo: t,
    implementation: n,
  };
}
function zx(e) {
  if (!e) return es;
  e = e._reactInternals;
  e: {
    if (po(e) !== e || e.tag !== 1) throw Error(U(170));
    var t = e;
    do {
      switch (t.tag) {
        case 3:
          t = t.stateNode.context;
          break e;
        case 1:
          if (bn(t.type)) {
            t = t.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      t = t.return;
    } while (t !== null);
    throw Error(U(171));
  }
  if (e.tag === 1) {
    var n = e.type;
    if (bn(n)) return HA(e, n, t);
  }
  return t;
}
function Gx(e, t, n, r, i, s, o, a, u) {
  return (
    (e = Rv(n, r, !0, e, i, s, o, a, u)),
    (e.context = zx(null)),
    (n = e.current),
    (r = nn()),
    (i = Ki(n)),
    (s = ri(r, i)),
    (s.callback = t ?? null),
    Qi(n, s, i),
    (e.current.lanes = i),
    tl(e, i, r),
    wn(e, r),
    e
  );
}
function Dh(e, t, n, r) {
  var i = t.current,
    s = nn(),
    o = Ki(i);
  return (
    (n = zx(n)),
    t.context === null ? (t.context = n) : (t.pendingContext = n),
    (t = ri(s, o)),
    (t.payload = { element: e }),
    (r = r === void 0 ? null : r),
    r !== null && (t.callback = r),
    (e = Qi(i, t, o)),
    e !== null && (lr(e, i, o, s), fd(e, i, o)),
    o
  );
}
function cf(e) {
  if (((e = e.current), !e.child)) return null;
  switch (e.child.tag) {
    case 5:
      return e.child.stateNode;
    default:
      return e.child.stateNode;
  }
}
function z1(e, t) {
  if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
    var n = e.retryLane;
    e.retryLane = n !== 0 && n < t ? n : t;
  }
}
function Bv(e, t) {
  z1(e, t), (e = e.alternate) && z1(e, t);
}
function Z6() {
  return null;
}
var qx =
  typeof reportError == "function"
    ? reportError
    : function (e) {
        console.error(e);
      };
function Nv(e) {
  this._internalRoot = e;
}
Oh.prototype.render = Nv.prototype.render = function (e) {
  var t = this._internalRoot;
  if (t === null) throw Error(U(409));
  Dh(e, t, null, null);
};
Oh.prototype.unmount = Nv.prototype.unmount = function () {
  var e = this._internalRoot;
  if (e !== null) {
    this._internalRoot = null;
    var t = e.containerInfo;
    Ys(function () {
      Dh(null, e, null, null);
    }),
      (t[ui] = null);
  }
};
function Oh(e) {
  this._internalRoot = e;
}
Oh.prototype.unstable_scheduleHydration = function (e) {
  if (e) {
    var t = EA();
    e = { blockedOn: null, target: e, priority: t };
    for (var n = 0; n < Ni.length && t !== 0 && t < Ni[n].priority; n++);
    Ni.splice(n, 0, e), n === 0 && AA(e);
  }
};
function Mv(e) {
  return !(!e || (e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11));
}
function Rh(e) {
  return !(
    !e ||
    (e.nodeType !== 1 &&
      e.nodeType !== 9 &&
      e.nodeType !== 11 &&
      (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable "))
  );
}
function G1() {}
function J6(e, t, n, r, i) {
  if (i) {
    if (typeof r == "function") {
      var s = r;
      r = function () {
        var l = cf(o);
        s.call(l);
      };
    }
    var o = Gx(t, r, e, 0, null, !1, !1, "", G1);
    return (
      (e._reactRootContainer = o),
      (e[ui] = o.current),
      Xu(e.nodeType === 8 ? e.parentNode : e),
      Ys(),
      o
    );
  }
  for (; (i = e.lastChild); ) e.removeChild(i);
  if (typeof r == "function") {
    var a = r;
    r = function () {
      var l = cf(u);
      a.call(l);
    };
  }
  var u = Rv(e, 0, !1, null, null, !1, !1, "", G1);
  return (
    (e._reactRootContainer = u),
    (e[ui] = u.current),
    Xu(e.nodeType === 8 ? e.parentNode : e),
    Ys(function () {
      Dh(t, u, n, r);
    }),
    u
  );
}
function Bh(e, t, n, r, i) {
  var s = n._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof i == "function") {
      var a = i;
      i = function () {
        var u = cf(o);
        a.call(u);
      };
    }
    Dh(t, o, e, i);
  } else o = J6(n, t, e, i, r);
  return cf(o);
}
bA = function (e) {
  switch (e.tag) {
    case 3:
      var t = e.stateNode;
      if (t.current.memoizedState.isDehydrated) {
        var n = gu(t.pendingLanes);
        n !== 0 &&
          (tv(t, n | 1), wn(t, st()), !(Ce & 6) && ((ya = st() + 500), hs()));
      }
      break;
    case 13:
      Ys(function () {
        var r = ci(e, 1);
        if (r !== null) {
          var i = nn();
          lr(r, e, 1, i);
        }
      }),
        Bv(e, 1);
  }
};
nv = function (e) {
  if (e.tag === 13) {
    var t = ci(e, 134217728);
    if (t !== null) {
      var n = nn();
      lr(t, e, 134217728, n);
    }
    Bv(e, 134217728);
  }
};
wA = function (e) {
  if (e.tag === 13) {
    var t = Ki(e),
      n = ci(e, t);
    if (n !== null) {
      var r = nn();
      lr(n, e, t, r);
    }
    Bv(e, t);
  }
};
EA = function () {
  return Re;
};
_A = function (e, t) {
  var n = Re;
  try {
    return (Re = e), t();
  } finally {
    Re = n;
  }
};
x0 = function (e, t, n) {
  switch (t) {
    case "input":
      if ((g0(e, n), (t = n.name), n.type === "radio" && t != null)) {
        for (n = e; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + t) + '][type="radio"]'
          ),
            t = 0;
          t < n.length;
          t++
        ) {
          var r = n[t];
          if (r !== e && r.form === e.form) {
            var i = xh(r);
            if (!i) throw Error(U(90));
            X2(r), g0(r, i);
          }
        }
      }
      break;
    case "textarea":
      tA(e, n);
      break;
    case "select":
      (t = n.value), t != null && Zo(e, !!n.multiple, t, !1);
  }
};
uA = kv;
cA = Ys;
var Y6 = { usingClientEntryPoint: !1, Events: [rl, jo, xh, oA, aA, kv] },
  nu = {
    findFiberByHostInstance: Ps,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  X6 = {
    bundleType: nu.bundleType,
    version: nu.version,
    rendererPackageName: nu.rendererPackageName,
    rendererConfig: nu.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: yi.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (e) {
      return (e = fA(e)), e === null ? null : e.stateNode;
    },
    findFiberByHostInstance: nu.findFiberByHostInstance || Z6,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var zl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!zl.isDisabled && zl.supportsFiber)
    try {
      (wh = zl.inject(X6)), (kr = zl);
    } catch {}
}
Rn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Y6;
Rn.createPortal = function (e, t) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Mv(t)) throw Error(U(200));
  return K6(e, t, null, n);
};
Rn.createRoot = function (e, t) {
  if (!Mv(e)) throw Error(U(299));
  var n = !1,
    r = "",
    i = qx;
  return (
    t != null &&
      (t.unstable_strictMode === !0 && (n = !0),
      t.identifierPrefix !== void 0 && (r = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (i = t.onRecoverableError)),
    (t = Rv(e, 1, !1, null, null, n, !1, r, i)),
    (e[ui] = t.current),
    Xu(e.nodeType === 8 ? e.parentNode : e),
    new Nv(t)
  );
};
Rn.findDOMNode = function (e) {
  if (e == null) return null;
  if (e.nodeType === 1) return e;
  var t = e._reactInternals;
  if (t === void 0)
    throw typeof e.render == "function"
      ? Error(U(188))
      : ((e = Object.keys(e).join(",")), Error(U(268, e)));
  return (e = fA(t)), (e = e === null ? null : e.stateNode), e;
};
Rn.flushSync = function (e) {
  return Ys(e);
};
Rn.hydrate = function (e, t, n) {
  if (!Rh(t)) throw Error(U(200));
  return Bh(null, e, t, !0, n);
};
Rn.hydrateRoot = function (e, t, n) {
  if (!Mv(e)) throw Error(U(405));
  var r = (n != null && n.hydratedSources) || null,
    i = !1,
    s = "",
    o = qx;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (i = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (o = n.onRecoverableError)),
    (t = Gx(t, null, e, 1, n ?? null, i, !1, s, o)),
    (e[ui] = t.current),
    Xu(e),
    r)
  )
    for (e = 0; e < r.length; e++)
      (n = r[e]),
        (i = n._getVersion),
        (i = i(n._source)),
        t.mutableSourceEagerHydrationData == null
          ? (t.mutableSourceEagerHydrationData = [n, i])
          : t.mutableSourceEagerHydrationData.push(n, i);
  return new Oh(t);
};
Rn.render = function (e, t, n) {
  if (!Rh(t)) throw Error(U(200));
  return Bh(null, e, t, !1, n);
};
Rn.unmountComponentAtNode = function (e) {
  if (!Rh(e)) throw Error(U(40));
  return e._reactRootContainer
    ? (Ys(function () {
        Bh(null, null, e, !1, function () {
          (e._reactRootContainer = null), (e[ui] = null);
        });
      }),
      !0)
    : !1;
};
Rn.unstable_batchedUpdates = kv;
Rn.unstable_renderSubtreeIntoContainer = function (e, t, n, r) {
  if (!Rh(n)) throw Error(U(200));
  if (e == null || e._reactInternals === void 0) throw Error(U(38));
  return Bh(e, t, n, !1, r);
};
Rn.version = "18.2.0-next-9e3b772b8-20220608";
function Wx() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Wx);
    } catch (e) {
      console.error(e);
    }
}
Wx(), (G2.exports = Rn);
var e5 = G2.exports,
  q1 = e5;
(l0.createRoot = q1.createRoot), (l0.hydrateRoot = q1.hydrateRoot);
function Qx(e, t = {}) {
  const {
    fees: n = e.fees,
    formatters: r = e.formatters,
    serializers: i = e.serializers,
  } = t;
  return { ...e, fees: n, formatters: r, serializers: i };
}
const t5 = "1.20.0",
  n5 = (e) => e,
  Nh = (e) => e,
  r5 = () => `viem@${t5}`;
let q = class ry extends Error {
  constructor(t, n = {}) {
    var s;
    super(),
      Object.defineProperty(this, "details", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "docsPath", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "metaMessages", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "shortMessage", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ViemError",
      }),
      Object.defineProperty(this, "version", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r5(),
      });
    const r =
        n.cause instanceof ry
          ? n.cause.details
          : (s = n.cause) != null && s.message
          ? n.cause.message
          : n.details,
      i = (n.cause instanceof ry && n.cause.docsPath) || n.docsPath;
    (this.message = [
      t || "An error occurred.",
      "",
      ...(n.metaMessages ? [...n.metaMessages, ""] : []),
      ...(i
        ? [
            `Docs: https://viem.sh${i}.html${
              n.docsSlug ? `#${n.docsSlug}` : ""
            }`,
          ]
        : []),
      ...(r ? [`Details: ${r}`] : []),
      `Version: ${this.version}`,
    ].join(`
`)),
      n.cause && (this.cause = n.cause),
      (this.details = r),
      (this.docsPath = i),
      (this.metaMessages = n.metaMessages),
      (this.shortMessage = t);
  }
  walk(t) {
    return Vx(this, t);
  }
};
function Vx(e, t) {
  return t != null && t(e)
    ? e
    : e && typeof e == "object" && "cause" in e
    ? Vx(e.cause, t)
    : t
    ? null
    : e;
}
class i5 extends q {
  constructor({ max: t, min: n, signed: r, size: i, value: s }) {
    super(
      `Number "${s}" is not in safe ${
        i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""
      }integer range ${t ? `(${n} to ${t})` : `(above ${n})`}`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "IntegerOutOfRangeError",
      });
  }
}
class s5 extends q {
  constructor(t) {
    super(
      `Hex value "${t}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidHexBooleanError",
      });
  }
}
class o5 extends q {
  constructor({ givenSize: t, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SizeOverflowError",
      });
  }
}
function Dr(e, { strict: t = !0 } = {}) {
  return !e || typeof e != "string"
    ? !1
    : t
    ? /^0x[0-9a-fA-F]*$/.test(e)
    : e.startsWith("0x");
}
function pt(e) {
  return Dr(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
}
function Hs(e, { dir: t = "left" } = {}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e,
    r = 0;
  for (
    let i = 0;
    i < n.length - 1 &&
    n[t === "left" ? i : n.length - i - 1].toString() === "0";
    i++
  )
    r++;
  return (
    (n = t === "left" ? n.slice(r) : n.slice(0, n.length - r)),
    typeof e == "string"
      ? (n.length === 1 && t === "right" && (n = `${n}0`),
        `0x${n.length % 2 === 1 ? `0${n}` : n}`)
      : n
  );
}
class Kx extends q {
  constructor({ offset: t, position: n, size: r }) {
    super(
      `Slice ${
        n === "start" ? "starting" : "ending"
      } at offset "${t}" is out-of-bounds (size: ${r}).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SliceOffsetOutOfBoundsError",
      });
  }
}
class Zx extends q {
  constructor({ size: t, targetSize: n, type: r }) {
    super(
      `${r.charAt(0).toUpperCase()}${r
        .slice(1)
        .toLowerCase()} size (${t}) exceeds padding size (${n}).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SizeExceedsPaddingSizeError",
      });
  }
}
function La(e, { dir: t, size: n = 32 } = {}) {
  return typeof e == "string"
    ? Ji(e, { dir: t, size: n })
    : a5(e, { dir: t, size: n });
}
function Ji(e, { dir: t, size: n = 32 } = {}) {
  if (n === null) return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2)
    throw new Zx({ size: Math.ceil(r.length / 2), targetSize: n, type: "hex" });
  return `0x${r[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function a5(e, { dir: t, size: n = 32 } = {}) {
  if (n === null) return e;
  if (e.length > n)
    throw new Zx({ size: e.length, targetSize: n, type: "bytes" });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const s = t === "right";
    r[s ? i : n - i - 1] = e[s ? i : e.length - i - 1];
  }
  return r;
}
const u5 = Array.from({ length: 256 }, (e, t) =>
  t.toString(16).padStart(2, "0")
);
function gi(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint"
    ? he(e, t)
    : typeof e == "string"
    ? Lv(e, t)
    : typeof e == "boolean"
    ? Jx(e, t)
    : uc(e, t);
}
function Jx(e, t = {}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number"
    ? (ps(n, { size: t.size }), La(n, { size: t.size }))
    : n;
}
function uc(e, t = {}) {
  let n = "";
  for (let i = 0; i < e.length; i++) n += u5[e[i]];
  const r = `0x${n}`;
  return typeof t.size == "number"
    ? (ps(r, { size: t.size }), La(r, { dir: "right", size: t.size }))
    : r;
}
function he(e, t = {}) {
  const { signed: n, size: r } = t,
    i = BigInt(e);
  let s;
  r
    ? n
      ? (s = (1n << (BigInt(r) * 8n - 1n)) - 1n)
      : (s = 2n ** (BigInt(r) * 8n) - 1n)
    : typeof e == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && n ? -s - 1n : 0;
  if ((s && i > s) || i < o) {
    const u = typeof e == "bigint" ? "n" : "";
    throw new i5({
      max: s ? `${s}${u}` : void 0,
      min: `${o}${u}`,
      signed: n,
      size: r,
      value: `${e}${u}`,
    });
  }
  const a = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(
    16
  )}`;
  return r ? La(a, { size: r }) : a;
}
const c5 = new TextEncoder();
function Lv(e, t = {}) {
  const n = c5.encode(e);
  return uc(n, t);
}
const l5 = new TextEncoder();
function ts(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint"
    ? f5(e, t)
    : typeof e == "boolean"
    ? d5(e, t)
    : Dr(e)
    ? Fv(e, t)
    : ii(e, t);
}
function d5(e, t = {}) {
  const n = new Uint8Array(1);
  return (
    (n[0] = Number(e)),
    typeof t.size == "number"
      ? (ps(n, { size: t.size }), La(n, { size: t.size }))
      : n
  );
}
const Ur = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function W1(e) {
  if (e >= Ur.zero && e <= Ur.nine) return e - Ur.zero;
  if (e >= Ur.A && e <= Ur.F) return e - (Ur.A - 10);
  if (e >= Ur.a && e <= Ur.f) return e - (Ur.a - 10);
}
function Fv(e, t = {}) {
  let n = e;
  t.size &&
    (ps(n, { size: t.size }), (n = La(n, { dir: "right", size: t.size })));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2,
    s = new Uint8Array(i);
  for (let o = 0, a = 0; o < i; o++) {
    const u = W1(r.charCodeAt(a++)),
      l = W1(r.charCodeAt(a++));
    if (u === void 0 || l === void 0)
      throw new q(
        `Invalid byte sequence ("${r[a - 2]}${r[a - 1]}" in "${r}").`
      );
    s[o] = u * 16 + l;
  }
  return s;
}
function f5(e, t) {
  const n = he(e, t);
  return Fv(n);
}
function ii(e, t = {}) {
  const n = l5.encode(e);
  return typeof t.size == "number"
    ? (ps(n, { size: t.size }), La(n, { dir: "right", size: t.size }))
    : n;
}
function ps(e, { size: t }) {
  if (pt(e) > t) throw new o5({ givenSize: pt(e), maxSize: t });
}
function Mh(e, t = {}) {
  const { signed: n } = t;
  t.size && ps(e, { size: t.size });
  const r = BigInt(e);
  if (!n) return r;
  const i = (e.length - 2) / 2,
    s = (1n << (BigInt(i) * 8n - 1n)) - 1n;
  return r <= s ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function h5(e, t = {}) {
  let n = e;
  if ((t.size && (ps(n, { size: t.size }), (n = Hs(n))), Hs(n) === "0x00"))
    return !1;
  if (Hs(n) === "0x01") return !0;
  throw new s5(n);
}
function Jt(e, t = {}) {
  return Number(Mh(e, t));
}
function jv(e, t = {}) {
  let n = Fv(e);
  return (
    t.size && (ps(n, { size: t.size }), (n = Hs(n, { dir: "right" }))),
    new TextDecoder().decode(n)
  );
}
const Yx = { "0x0": "legacy", "0x1": "eip2930", "0x2": "eip1559" };
function Xx(e) {
  const t = {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    chainId: e.chainId ? Jt(e.chainId) : void 0,
    gas: e.gas ? BigInt(e.gas) : void 0,
    gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
    maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e.maxPriorityFeePerGas
      ? BigInt(e.maxPriorityFeePerGas)
      : void 0,
    nonce: e.nonce ? Jt(e.nonce) : void 0,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    type: e.type ? Yx[e.type] : void 0,
    typeHex: e.type ? e.type : void 0,
    value: e.value ? BigInt(e.value) : void 0,
    v: e.v ? BigInt(e.v) : void 0,
  };
  return (
    (t.yParity = (() => {
      if (e.yParity) return Number(e.yParity);
      if (typeof t.v == "bigint") {
        if (t.v === 0n || t.v === 27n) return 0;
        if (t.v === 1n || t.v === 28n) return 1;
        if (t.v >= 35n) return t.v % 2n === 0n ? 1 : 0;
      }
    })()),
    t.type === "legacy" &&
      (delete t.accessList,
      delete t.maxFeePerGas,
      delete t.maxPriorityFeePerGas,
      delete t.yParity),
    t.type === "eip2930" &&
      (delete t.maxFeePerGas, delete t.maxPriorityFeePerGas),
    t
  );
}
function eS(e) {
  var n;
  const t =
    (n = e.transactions) == null
      ? void 0
      : n.map((r) => (typeof r == "string" ? r : Xx(r)));
  return {
    ...e,
    baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
    difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
    gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
    hash: e.hash ? e.hash : null,
    logsBloom: e.logsBloom ? e.logsBloom : null,
    nonce: e.nonce ? e.nonce : null,
    number: e.number ? BigInt(e.number) : null,
    size: e.size ? BigInt(e.size) : void 0,
    timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
    transactions: t,
    totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null,
  };
}
function pr(e, { args: t, eventName: n } = {}) {
  return {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    logIndex: e.logIndex ? Number(e.logIndex) : null,
    transactionHash: e.transactionHash ? e.transactionHash : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    ...(n ? { args: t, eventName: n } : {}),
  };
}
const p5 = { "0x0": "reverted", "0x1": "success" };
function m5(e) {
  return {
    ...e,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    contractAddress: e.contractAddress ? e.contractAddress : null,
    cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
    effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
    logs: e.logs ? e.logs.map((t) => pr(t)) : null,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Jt(e.transactionIndex) : null,
    status: e.status ? p5[e.status] : null,
    type: e.type ? Yx[e.type] || e.type : null,
  };
}
const y5 = { legacy: "0x0", eip2930: "0x1", eip1559: "0x2" };
function Lh(e) {
  return {
    ...e,
    gas: typeof e.gas < "u" ? he(e.gas) : void 0,
    gasPrice: typeof e.gasPrice < "u" ? he(e.gasPrice) : void 0,
    maxFeePerGas: typeof e.maxFeePerGas < "u" ? he(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas:
      typeof e.maxPriorityFeePerGas < "u" ? he(e.maxPriorityFeePerGas) : void 0,
    nonce: typeof e.nonce < "u" ? he(e.nonce) : void 0,
    type: typeof e.type < "u" ? y5[e.type] : void 0,
    value: typeof e.value < "u" ? he(e.value) : void 0,
  };
}
let cc = class extends q {
  constructor({ address: t }) {
    super(`Address "${t}" is invalid.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidAddressError",
      });
  }
};
class iy extends q {
  constructor({ blockNumber: t, chain: n, contract: r }) {
    super(`Chain "${n.name}" does not support contract "${r.name}".`, {
      metaMessages: [
        "This could be due to any of the following:",
        ...(t && r.blockCreated && r.blockCreated > t
          ? [
              `- The contract "${r.name}" was not deployed until block ${r.blockCreated} (current block ${t}).`,
            ]
          : [`- The chain does not have the contract "${r.name}" configured.`]),
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ChainDoesNotSupportContract",
      });
  }
}
let g5 = class extends q {
  constructor({ chain: t, currentChainId: n }) {
    super(
      `The current chain of the wallet (id: ${n}) does not match the target chain for the transaction (id: ${t.id}  ${t.name}).`,
      {
        metaMessages: [
          `Current Chain ID:  ${n}`,
          `Expected Chain ID: ${t.id}  ${t.name}`,
        ],
      }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ChainMismatchError",
      });
  }
};
class v5 extends q {
  constructor() {
    super(
      [
        "No chain was provided to the request.",
        "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.",
      ].join(`
`)
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ChainNotFoundError",
      });
  }
}
class tS extends q {
  constructor() {
    super("No chain was provided to the Client."),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ClientChainNotConfiguredError",
      });
  }
}
const b5 = { gwei: 9, wei: 18 },
  w5 = { ether: -9, wei: 9 },
  E5 = { ether: -18, gwei: -9 };
function lf(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), (n = n.padStart(t, "0"));
  let [i, s] = [n.slice(0, n.length - t), n.slice(n.length - t)];
  return (
    (s = s.replace(/(0+)$/, "")),
    `${r ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`
  );
}
function En(e, t = "wei") {
  return lf(e, w5[t]);
}
class Wo extends q {
  constructor({ cause: t, message: n } = {}) {
    var i;
    const r =
      (i = n == null ? void 0 : n.replace("execution reverted: ", "")) == null
        ? void 0
        : i.replace("execution reverted", "");
    super(
      `Execution reverted ${
        r ? `with reason: ${r}` : "for an unknown reason"
      }.`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ExecutionRevertedError",
      });
  }
}
Object.defineProperty(Wo, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3,
});
Object.defineProperty(Wo, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/,
});
class df extends q {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${
        n ? ` = ${En(n)} gwei` : ""
      }) cannot be higher than the maximum allowed value (2^256-1).`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "FeeCapTooHigh",
      });
  }
}
Object.defineProperty(df, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/,
});
class sy extends q {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(
      `The fee cap (\`maxFeePerGas\`${
        n ? ` = ${En(n)}` : ""
      } gwei) cannot be lower than the block base fee.`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "FeeCapTooLow",
      });
  }
}
Object.defineProperty(sy, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/,
});
class oy extends q {
  constructor({ cause: t, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${
        n ? `(${n}) ` : ""
      }is higher than the next one expected.`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "NonceTooHighError",
      });
  }
}
Object.defineProperty(oy, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/,
});
class ay extends q {
  constructor({ cause: t, nonce: n } = {}) {
    super(
      [
        `Nonce provided for the transaction ${
          n ? `(${n}) ` : ""
        }is lower than the current nonce of the account.`,
        "Try increasing the nonce or find the latest nonce with `getTransactionCount`.",
      ].join(`
`),
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "NonceTooLowError",
      });
  }
}
Object.defineProperty(ay, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/,
});
class uy extends q {
  constructor({ cause: t, nonce: n } = {}) {
    super(
      `Nonce provided for the transaction ${
        n ? `(${n}) ` : ""
      }exceeds the maximum allowed nonce.`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "NonceMaxValueError",
      });
  }
}
Object.defineProperty(uy, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/,
});
class cy extends q {
  constructor({ cause: t } = {}) {
    super(
      [
        "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.",
      ].join(`
`),
      {
        cause: t,
        metaMessages: [
          "This error could arise when the account does not have enough funds to:",
          " - pay for the total gas fee,",
          " - pay for the value to send.",
          " ",
          "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
          " - `gas` is the amount of gas needed for transaction to execute,",
          " - `gas fee` is the gas fee,",
          " - `value` is the amount of ether to send to the recipient.",
        ],
      }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InsufficientFundsError",
      });
  }
}
Object.defineProperty(cy, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds/,
});
class ly extends q {
  constructor({ cause: t, gas: n } = {}) {
    super(
      `The amount of gas ${
        n ? `(${n}) ` : ""
      }provided for the transaction exceeds the limit allowed for the block.`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "IntrinsicGasTooHighError",
      });
  }
}
Object.defineProperty(ly, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/,
});
class dy extends q {
  constructor({ cause: t, gas: n } = {}) {
    super(
      `The amount of gas ${
        n ? `(${n}) ` : ""
      }provided for the transaction is too low.`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "IntrinsicGasTooLowError",
      });
  }
}
Object.defineProperty(dy, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/,
});
class fy extends q {
  constructor({ cause: t }) {
    super("The transaction type is not supported for this chain.", {
      cause: t,
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "TransactionTypeNotSupportedError",
      });
  }
}
Object.defineProperty(fy, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/,
});
class ff extends q {
  constructor({ cause: t, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super(
      [
        `The provided tip (\`maxPriorityFeePerGas\`${
          n ? ` = ${En(n)} gwei` : ""
        }) cannot be higher than the fee cap (\`maxFeePerGas\`${
          r ? ` = ${En(r)} gwei` : ""
        }).`,
      ].join(`
`),
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "TipAboveFeeCapError",
      });
  }
}
Object.defineProperty(ff, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value:
    /max priority fee per gas higher than max fee per gas|tip higher than fee cap/,
});
class Fh extends q {
  constructor({ cause: t }) {
    super(
      `An error occurred while executing: ${
        t == null ? void 0 : t.shortMessage
      }`,
      { cause: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownNodeError",
      });
  }
}
const _5 = /^0x[a-fA-F0-9]{40}$/;
function ns(e) {
  return _5.test(e);
}
function di(e) {
  return typeof e[0] == "string" ? Uv(e) : A5(e);
}
function A5(e) {
  let t = 0;
  for (const i of e) t += i.length;
  const n = new Uint8Array(t);
  let r = 0;
  for (const i of e) n.set(i, r), (r += i.length);
  return n;
}
function Uv(e) {
  return `0x${e.reduce((t, n) => t + n.replace("0x", ""), "")}`;
}
function x5(e, t) {
  const n = e.exec(t);
  return n == null ? void 0 : n.groups;
}
const Q1 = /^tuple(?<array>(\[(\d*)\])*)$/;
function hy(e) {
  let t = e.type;
  if (Q1.test(e.type) && "components" in e) {
    t = "(";
    const n = e.components.length;
    for (let i = 0; i < n; i++) {
      const s = e.components[i];
      (t += hy(s)), i < n - 1 && (t += ", ");
    }
    const r = x5(Q1, e.type);
    return (
      (t += `)${(r == null ? void 0 : r.array) ?? ""}`), hy({ ...e, type: t })
    );
  }
  return (
    "indexed" in e && e.indexed && (t = `${t} indexed`),
    e.name ? `${t} ${e.name}` : t
  );
}
function ru(e) {
  let t = "";
  const n = e.length;
  for (let r = 0; r < n; r++) {
    const i = e[r];
    (t += hy(i)), r !== n - 1 && (t += ", ");
  }
  return t;
}
function S5(e) {
  return e.type === "function"
    ? `function ${e.name}(${ru(e.inputs)})${
        e.stateMutability && e.stateMutability !== "nonpayable"
          ? ` ${e.stateMutability}`
          : ""
      }${e.outputs.length ? ` returns (${ru(e.outputs)})` : ""}`
    : e.type === "event"
    ? `event ${e.name}(${ru(e.inputs)})`
    : e.type === "error"
    ? `error ${e.name}(${ru(e.inputs)})`
    : e.type === "constructor"
    ? `constructor(${ru(e.inputs)})${
        e.stateMutability === "payable" ? " payable" : ""
      }`
    : e.type === "fallback"
    ? "fallback()"
    : "receive() external payable";
}
function se(e, t, n) {
  return (r) => {
    var i;
    return ((i = e[t.name || n]) == null ? void 0 : i.call(e, r)) ?? t(e, r);
  };
}
function fi(e, { includeName: t = !1 } = {}) {
  if (e.type !== "function" && e.type !== "event" && e.type !== "error")
    throw new j5(e.type);
  return `${e.name}(${jh(e.inputs, { includeName: t })})`;
}
function jh(e, { includeName: t = !1 } = {}) {
  return e ? e.map((n) => C5(n, { includeName: t })).join(t ? ", " : ",") : "";
}
function C5(e, { includeName: t }) {
  return e.type.startsWith("tuple")
    ? `(${jh(e.components, { includeName: t })})${e.type.slice(5)}`
    : e.type + (t && e.name ? ` ${e.name}` : "");
}
class T5 extends q {
  constructor({ docsPath: t }) {
    super(
      [
        "A constructor was not found on the ABI.",
        "Make sure you are using the correct ABI and that the constructor exists on it.",
      ].join(`
`),
      { docsPath: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiConstructorNotFoundError",
      });
  }
}
class V1 extends q {
  constructor({ docsPath: t }) {
    super(
      [
        "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
        "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.",
      ].join(`
`),
      { docsPath: t }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiConstructorParamsNotFoundError",
      });
  }
}
class $v extends q {
  constructor({ data: t, params: n, size: r }) {
    super(
      [`Data size of ${r} bytes is too small for given parameters.`].join(`
`),
      {
        metaMessages: [
          `Params: (${jh(n, { includeName: !0 })})`,
          `Data:   ${t} (${r} bytes)`,
        ],
      }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiDecodingDataSizeTooSmallError",
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "params", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = t),
      (this.params = n),
      (this.size = r);
  }
}
class Uh extends q {
  constructor() {
    super('Cannot decode zero data ("0x") with ABI parameters.'),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiDecodingZeroDataError",
      });
  }
}
class I5 extends q {
  constructor({ expectedLength: t, givenLength: n, type: r }) {
    super(
      [
        `ABI encoding array length mismatch for type ${r}.`,
        `Expected length: ${t}`,
        `Given length: ${n}`,
      ].join(`
`)
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiEncodingArrayLengthMismatchError",
      });
  }
}
class k5 extends q {
  constructor({ expectedSize: t, value: n }) {
    super(
      `Size of bytes "${n}" (bytes${pt(
        n
      )}) does not match expected size (bytes${t}).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiEncodingBytesSizeMismatchError",
      });
  }
}
class P5 extends q {
  constructor({ expectedLength: t, givenLength: n }) {
    super(
      [
        "ABI encoding params/values length mismatch.",
        `Expected length (params): ${t}`,
        `Given length (values): ${n}`,
      ].join(`
`)
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiEncodingLengthMismatchError",
      });
  }
}
class nS extends q {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Encoded error signature "${t}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${t}.`,
      ].join(`
`),
      { docsPath: n }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiErrorSignatureNotFoundError",
      }),
      Object.defineProperty(this, "signature", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.signature = t);
  }
}
class D5 extends q {
  constructor({ docsPath: t }) {
    super("Cannot extract event signature from empty topics.", { docsPath: t }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiEventSignatureEmptyTopicsError",
      });
  }
}
class O5 extends q {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Encoded event signature "${t}" not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
        `You can look up the signature here: https://openchain.xyz/signatures?query=${t}.`,
      ].join(`
`),
      { docsPath: n }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiEventSignatureNotFoundError",
      });
  }
}
class K1 extends q {
  constructor(t, { docsPath: n } = {}) {
    super(
      [
        `Event ${t ? `"${t}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the event exists on it.",
      ].join(`
`),
      { docsPath: n }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiEventNotFoundError",
      });
  }
}
class hf extends q {
  constructor(t, { docsPath: n } = {}) {
    super(
      [
        `Function ${t ? `"${t}" ` : ""}not found on ABI.`,
        "Make sure you are using the correct ABI and that the function exists on it.",
      ].join(`
`),
      { docsPath: n }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiFunctionNotFoundError",
      });
  }
}
class R5 extends q {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Function "${t}" does not contain any \`outputs\` on ABI.`,
        "Cannot decode function result without knowing what the parameter types are.",
        "Make sure you are using the correct ABI and that the function exists on it.",
      ].join(`
`),
      { docsPath: n }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiFunctionOutputsNotFoundError",
      });
  }
}
class B5 extends q {
  constructor(t, n) {
    super("Found ambiguous types in overloaded ABI items.", {
      metaMessages: [
        `\`${t.type}\` in \`${fi(t.abiItem)}\`, and`,
        `\`${n.type}\` in \`${fi(n.abiItem)}\``,
        "",
        "These types encode differently and cannot be distinguished at runtime.",
        "Remove one of the ambiguous items in the ABI.",
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AbiItemAmbiguityError",
      });
  }
}
class N5 extends q {
  constructor({ expectedSize: t, givenSize: n }) {
    super(`Expected bytes${t}, got bytes${n}.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "BytesSizeMismatchError",
      });
  }
}
class Xs extends q {
  constructor({ abiItem: t, data: n, params: r, size: i }) {
    super(
      [`Data size of ${i} bytes is too small for non-indexed event parameters.`]
        .join(`
`),
      {
        metaMessages: [
          `Params: (${jh(r, { includeName: !0 })})`,
          `Data:   ${n} (${i} bytes)`,
        ],
      }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "DecodeLogDataMismatch",
      }),
      Object.defineProperty(this, "abiItem", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "params", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "size", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abiItem = t),
      (this.data = n),
      (this.params = r),
      (this.size = i);
  }
}
class Fa extends q {
  constructor({ abiItem: t, param: n }) {
    super(
      [
        `Expected a topic for indexed event parameter${
          n.name ? ` "${n.name}"` : ""
        } on event "${fi(t, { includeName: !0 })}".`,
      ].join(`
`)
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "DecodeLogTopicsMismatch",
      }),
      Object.defineProperty(this, "abiItem", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.abiItem = t);
  }
}
class M5 extends q {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Type "${t}" is not a valid encoding type.`,
        "Please provide a valid ABI type.",
      ].join(`
`),
      { docsPath: n }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidAbiEncodingType",
      });
  }
}
class L5 extends q {
  constructor(t, { docsPath: n }) {
    super(
      [
        `Type "${t}" is not a valid decoding type.`,
        "Please provide a valid ABI type.",
      ].join(`
`),
      { docsPath: n }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidAbiDecodingType",
      });
  }
}
class F5 extends q {
  constructor(t) {
    super(
      [`Value "${t}" is not a valid array.`].join(`
`)
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidArrayError",
      });
  }
}
class j5 extends q {
  constructor(t) {
    super(
      [
        `"${t}" is not a valid definition type.`,
        'Valid types: "function", "event", "error"',
      ].join(`
`)
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidDefinitionTypeError",
      });
  }
}
class U5 extends q {
  constructor(t) {
    super(`Filter type "${t}" is not supported.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "FilterTypeNotSupportedError",
      });
  }
}
function $5(e) {
  let t = !0,
    n = "",
    r = 0,
    i = "",
    s = !1;
  for (let o = 0; o < e.length; o++) {
    const a = e[o];
    if (
      (["(", ")", ","].includes(a) && (t = !0),
      a === "(" && r++,
      a === ")" && r--,
      !!t)
    ) {
      if (r === 0) {
        if (a === " " && ["event", "function", ""].includes(i)) i = "";
        else if (((i += a), a === ")")) {
          s = !0;
          break;
        }
        continue;
      }
      if (a === " ") {
        e[o - 1] !== "," && n !== "," && n !== ",(" && ((n = ""), (t = !1));
        continue;
      }
      (i += a), (n += a);
    }
  }
  if (!s) throw new q("Unable to normalize signature.");
  return i;
}
const rS = (e) => {
    const t = typeof e == "string" ? e : S5(e);
    return $5(t);
  },
  H5 = (e) => rS(e);
function Z1(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function iS(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(
      `Expected Uint8Array of length ${t}, not of length=${e.length}`
    );
}
function J1(e, t = !0) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function z5(e, t) {
  iS(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(
      `digestInto() expects output buffer of length at least ${n}`
    );
}
const Gl = BigInt(2 ** 32 - 1),
  Y1 = BigInt(32);
function G5(e, t = !1) {
  return t
    ? { h: Number(e & Gl), l: Number((e >> Y1) & Gl) }
    : { h: Number((e >> Y1) & Gl) | 0, l: Number(e & Gl) | 0 };
}
function q5(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = G5(e[i], t);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const W5 = (e, t, n) => (e << n) | (t >>> (32 - n)),
  Q5 = (e, t, n) => (t << n) | (e >>> (32 - n)),
  V5 = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  K5 = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const Z5 =
    (e) => e instanceof Uint8Array,
  J5 = (e) =>
    new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  Y5 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!Y5) throw new Error("Non little-endian hardware is not supported");
function X5(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function sS(e) {
  if ((typeof e == "string" && (e = X5(e)), !Z5(e)))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
let eD = class {
  clone() {
    return this._cloneInto();
  }
};
function tD(e) {
  const t = (r) => e().update(sS(r)).digest(),
    n = e();
  return (
    (t.outputLen = n.outputLen),
    (t.blockLen = n.blockLen),
    (t.create = () => e()),
    t
  );
}
const [oS, aS, uS] = [[], [], []],
  nD = BigInt(0),
  iu = BigInt(1),
  rD = BigInt(2),
  iD = BigInt(7),
  sD = BigInt(256),
  oD = BigInt(113);
for (let e = 0, t = iu, n = 1, r = 0; e < 24; e++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    oS.push(2 * (5 * r + n)),
    aS.push((((e + 1) * (e + 2)) / 2) % 64);
  let i = nD;
  for (let s = 0; s < 7; s++)
    (t = ((t << iu) ^ ((t >> iD) * oD)) % sD),
      t & rD && (i ^= iu << ((iu << BigInt(s)) - iu));
  uS.push(i);
}
const [aD, uD] = q5(uS, !0),
  X1 = (e, t, n) => (n > 32 ? V5(e, t, n) : W5(e, t, n)),
  eE = (e, t, n) => (n > 32 ? K5(e, t, n) : Q5(e, t, n));
function cD(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      n[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        u = (o + 2) % 10,
        l = n[u],
        c = n[u + 1],
        d = X1(l, c, 1) ^ n[a],
        f = eE(l, c, 1) ^ n[a + 1];
      for (let p = 0; p < 50; p += 10) (e[o + p] ^= d), (e[o + p + 1] ^= f);
    }
    let i = e[2],
      s = e[3];
    for (let o = 0; o < 24; o++) {
      const a = aS[o],
        u = X1(i, s, a),
        l = eE(i, s, a),
        c = oS[o];
      (i = e[c]), (s = e[c + 1]), (e[c] = u), (e[c + 1] = l);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = e[o + a];
      for (let a = 0; a < 10; a++)
        e[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (e[0] ^= aD[r]), (e[1] ^= uD[r]);
  }
  n.fill(0);
}
let lD = class cS extends eD {
  constructor(t, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = t),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      Z1(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = J5(this.state));
  }
  keccak() {
    cD(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
  }
  update(t) {
    J1(this);
    const { blockLen: n, state: r } = this;
    t = sS(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= t[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    (t[r] ^= n),
      n & 128 && r === i - 1 && this.keccak(),
      (t[i - 1] ^= 128),
      this.keccak();
  }
  writeInto(t) {
    J1(this, !1), iS(t), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = t.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      t.set(n.subarray(this.posOut, this.posOut + o), i),
        (this.posOut += o),
        (i += o);
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Z1(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((z5(t, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(t) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: o,
    } = this;
    return (
      t || (t = new cS(n, r, i, o, s)),
      t.state32.set(this.state32),
      (t.pos = this.pos),
      (t.posOut = this.posOut),
      (t.finished = this.finished),
      (t.rounds = s),
      (t.suffix = r),
      (t.outputLen = i),
      (t.enableXOF = o),
      (t.destroyed = this.destroyed),
      t
    );
  }
};
const dD = (e, t, n) => tD(() => new lD(t, e, n)),
  fD = dD(1, 136, 256 / 8);
function tn(e, t) {
  const n = t || "hex",
    r = fD(Dr(e, { strict: !1 }) ? ts(e) : e);
  return n === "bytes" ? r : gi(r);
}
const hD = (e) => tn(ts(e)),
  Hv = (e) => hD(H5(e));
function lt(e, t, n, { strict: r } = {}) {
  return Dr(e, { strict: !1 })
    ? mD(e, t, n, { strict: r })
    : pD(e, t, n, { strict: r });
}
function lS(e, t) {
  if (typeof t == "number" && t > 0 && t > pt(e) - 1)
    throw new Kx({ offset: t, position: "start", size: pt(e) });
}
function dS(e, t, n) {
  if (typeof t == "number" && typeof n == "number" && pt(e) !== n - t)
    throw new Kx({ offset: n, position: "end", size: pt(e) });
}
function pD(e, t, n, { strict: r } = {}) {
  lS(e, t);
  const i = e.slice(t, n);
  return r && dS(i, t, n), i;
}
function mD(e, t, n, { strict: r } = {}) {
  lS(e, t);
  const i = `0x${e.replace("0x", "").slice((t ?? 0) * 2, (n ?? e.length) * 2)}`;
  return r && dS(i, t, n), i;
}
function sl(e, t) {
  if (e.length !== t.length)
    throw new P5({ expectedLength: e.length, givenLength: t.length });
  const n = yD({ params: e, values: t }),
    r = Gv(n);
  return r.length === 0 ? "0x" : r;
}
function yD({ params: e, values: t }) {
  const n = [];
  for (let r = 0; r < e.length; r++) n.push(zv({ param: e[r], value: t[r] }));
  return n;
}
function zv({ param: e, value: t }) {
  const n = $h(e.type);
  if (n) {
    const [r, i] = n;
    return vD(t, { length: r, param: { ...e, type: i } });
  }
  if (e.type === "tuple") return AD(t, { param: e });
  if (e.type === "address") return gD(t);
  if (e.type === "bool") return wD(t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) {
    const r = e.type.startsWith("int");
    return ED(t, { signed: r });
  }
  if (e.type.startsWith("bytes")) return bD(t, { param: e });
  if (e.type === "string") return _D(t);
  throw new M5(e.type, { docsPath: "/docs/contract/encodeAbiParameters" });
}
function Gv(e) {
  let t = 0;
  for (let s = 0; s < e.length; s++) {
    const { dynamic: o, encoded: a } = e[s];
    o ? (t += 32) : (t += pt(a));
  }
  const n = [],
    r = [];
  let i = 0;
  for (let s = 0; s < e.length; s++) {
    const { dynamic: o, encoded: a } = e[s];
    o ? (n.push(he(t + i, { size: 32 })), r.push(a), (i += pt(a))) : n.push(a);
  }
  return di([...n, ...r]);
}
function gD(e) {
  if (!ns(e)) throw new cc({ address: e });
  return { dynamic: !1, encoded: Ji(e.toLowerCase()) };
}
function vD(e, { length: t, param: n }) {
  const r = t === null;
  if (!Array.isArray(e)) throw new F5(e);
  if (!r && e.length !== t)
    throw new I5({
      expectedLength: t,
      givenLength: e.length,
      type: `${n.type}[${t}]`,
    });
  let i = !1;
  const s = [];
  for (let o = 0; o < e.length; o++) {
    const a = zv({ param: n, value: e[o] });
    a.dynamic && (i = !0), s.push(a);
  }
  if (r || i) {
    const o = Gv(s);
    if (r) {
      const a = he(s.length, { size: 32 });
      return { dynamic: !0, encoded: s.length > 0 ? di([a, o]) : a };
    }
    if (i) return { dynamic: !0, encoded: o };
  }
  return { dynamic: !1, encoded: di(s.map(({ encoded: o }) => o)) };
}
function bD(e, { param: t }) {
  const [, n] = t.type.split("bytes"),
    r = pt(e);
  if (!n) {
    let i = e;
    return (
      r % 32 !== 0 &&
        (i = Ji(i, {
          dir: "right",
          size: Math.ceil((e.length - 2) / 2 / 32) * 32,
        })),
      { dynamic: !0, encoded: di([Ji(he(r, { size: 32 })), i]) }
    );
  }
  if (r !== parseInt(n)) throw new k5({ expectedSize: parseInt(n), value: e });
  return { dynamic: !1, encoded: Ji(e, { dir: "right" }) };
}
function wD(e) {
  return { dynamic: !1, encoded: Ji(Jx(e)) };
}
function ED(e, { signed: t }) {
  return { dynamic: !1, encoded: he(e, { size: 32, signed: t }) };
}
function _D(e) {
  const t = Lv(e),
    n = Math.ceil(pt(t) / 32),
    r = [];
  for (let i = 0; i < n; i++)
    r.push(Ji(lt(t, i * 32, (i + 1) * 32), { dir: "right" }));
  return { dynamic: !0, encoded: di([Ji(he(pt(t), { size: 32 })), ...r]) };
}
function AD(e, { param: t }) {
  let n = !1;
  const r = [];
  for (let i = 0; i < t.components.length; i++) {
    const s = t.components[i],
      o = Array.isArray(e) ? i : s.name,
      a = zv({ param: s, value: e[o] });
    r.push(a), a.dynamic && (n = !0);
  }
  return { dynamic: n, encoded: n ? Gv(r) : di(r.map(({ encoded: i }) => i)) };
}
function $h(e) {
  const t = e.match(/^(.*)\[(\d+)?\]$/);
  return t ? [t[2] ? Number(t[2]) : null, t[1]] : void 0;
}
const xD = (e) => tn(ts(e)),
  qv = (e) => lt(xD(rS(e)), 0, 4);
function ol({ abi: e, args: t = [], name: n }) {
  const r = Dr(n, { strict: !1 }),
    i = e.filter((o) =>
      r
        ? o.type === "function"
          ? qv(o) === n
          : o.type === "event"
          ? Hv(o) === n
          : !1
        : "name" in o && o.name === n
    );
  if (i.length === 0) return;
  if (i.length === 1) return i[0];
  let s;
  for (const o of i) {
    if (!("inputs" in o)) continue;
    if (!t || t.length === 0) {
      if (!o.inputs || o.inputs.length === 0) return o;
      continue;
    }
    if (!o.inputs || o.inputs.length === 0 || o.inputs.length !== t.length)
      continue;
    if (
      t.every((u, l) => {
        const c = "inputs" in o && o.inputs[l];
        return c ? py(u, c) : !1;
      })
    ) {
      if (s && "inputs" in s && s.inputs) {
        const u = fS(o.inputs, s.inputs, t);
        if (u)
          throw new B5({ abiItem: o, type: u[0] }, { abiItem: s, type: u[1] });
      }
      s = o;
    }
  }
  return s || i[0];
}
function py(e, t) {
  const n = typeof e,
    r = t.type;
  switch (r) {
    case "address":
      return ns(e);
    case "bool":
      return n === "boolean";
    case "function":
      return n === "string";
    case "string":
      return n === "string";
    default:
      return r === "tuple" && "components" in t
        ? Object.values(t.components).every((i, s) =>
            py(Object.values(e)[s], i)
          )
        : /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(
            r
          )
        ? n === "number" || n === "bigint"
        : /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(r)
        ? n === "string" || e instanceof Uint8Array
        : /[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(r)
        ? Array.isArray(e) &&
          e.every((i) =>
            py(i, { ...t, type: r.replace(/(\[[0-9]{0,}\])$/, "") })
          )
        : !1;
  }
}
function fS(e, t, n) {
  for (const r in e) {
    const i = e[r],
      s = t[r];
    if (
      i.type === "tuple" &&
      s.type === "tuple" &&
      "components" in i &&
      "components" in s
    )
      return fS(i.components, s.components, n[r]);
    const o = [i.type, s.type];
    if (
      o.includes("address") && o.includes("bytes20")
        ? !0
        : (o.includes("address") && o.includes("string")) ||
          (o.includes("address") && o.includes("bytes"))
        ? ns(n[r])
        : !1
    )
      return o;
  }
}
function al({ abi: e, eventName: t, args: n }) {
  var a;
  let r = e[0];
  if (t && ((r = ol({ abi: e, args: n, name: t })), !r))
    throw new K1(t, { docsPath: "/docs/contract/encodeEventTopics" });
  if (r.type !== "event")
    throw new K1(void 0, { docsPath: "/docs/contract/encodeEventTopics" });
  const i = fi(r),
    s = Hv(i);
  let o = [];
  if (n && "inputs" in r) {
    const u =
        (a = r.inputs) == null
          ? void 0
          : a.filter((c) => "indexed" in c && c.indexed),
      l = Array.isArray(n)
        ? n
        : Object.values(n).length > 0
        ? (u == null ? void 0 : u.map((c) => n[c.name])) ?? []
        : [];
    l.length > 0 &&
      (o =
        (u == null
          ? void 0
          : u.map((c, d) =>
              Array.isArray(l[d])
                ? l[d].map((f, p) => tE({ param: c, value: l[d][p] }))
                : l[d]
                ? tE({ param: c, value: l[d] })
                : null
            )) ?? []);
  }
  return [s, ...o];
}
function tE({ param: e, value: t }) {
  if (e.type === "string" || e.type === "bytes") return tn(ts(t));
  if (e.type === "tuple" || e.type.match(/^(.*)\[(\d+)?\]$/))
    throw new U5(e.type);
  return sl([e], [t]);
}
function Hh(e, { method: t }) {
  var r, i;
  const n = {};
  return (
    e.transport.type === "fallback" &&
      ((i = (r = e.transport).onResponse) == null ||
        i.call(r, ({ method: s, response: o, status: a, transport: u }) => {
          a === "success" && t === s && (n[o] = u.request);
        })),
    (s) => n[s] || e.request
  );
}
async function hS(
  e,
  {
    address: t,
    abi: n,
    args: r,
    eventName: i,
    fromBlock: s,
    strict: o,
    toBlock: a,
  }
) {
  const u = Hh(e, { method: "eth_newFilter" }),
    l = i ? al({ abi: n, args: r, eventName: i }) : void 0,
    c = await e.request({
      method: "eth_newFilter",
      params: [
        {
          address: t,
          fromBlock: typeof s == "bigint" ? he(s) : s,
          toBlock: typeof a == "bigint" ? he(a) : a,
          topics: l,
        },
      ],
    });
  return {
    abi: n,
    args: r,
    eventName: i,
    id: c,
    request: u(c),
    strict: o,
    type: "event",
  };
}
function tr(e) {
  return typeof e == "string" ? { address: e, type: "json-rpc" } : e;
}
function ms({ abi: e, args: t, functionName: n }) {
  let r = e[0];
  if (n && ((r = ol({ abi: e, args: t, name: n })), !r))
    throw new hf(n, { docsPath: "/docs/contract/encodeFunctionData" });
  if (r.type !== "function")
    throw new hf(void 0, { docsPath: "/docs/contract/encodeFunctionData" });
  const i = fi(r),
    s = qv(i),
    o = "inputs" in r && r.inputs ? sl(r.inputs, t ?? []) : void 0;
  return Uv([s, o ?? "0x"]);
}
const pS = {
    1: "An `assert` condition failed.",
    17: "Arithmic operation resulted in underflow or overflow.",
    18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
    33: "Attempted to convert to an invalid type.",
    34: "Attempted to access a storage byte array that is incorrectly encoded.",
    49: "Performed `.pop()` on an empty array",
    50: "Array index is out of bounds.",
    65: "Allocated too much memory or created an array which is too large.",
    81: "Attempted to call a zero-initialized variable of internal function type.",
  },
  SD = {
    inputs: [{ name: "message", type: "string" }],
    name: "Error",
    type: "error",
  },
  CD = {
    inputs: [{ name: "reason", type: "uint256" }],
    name: "Panic",
    type: "error",
  };
function Wv(e, t) {
  const n = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(),
    r = tn(ii(n), "bytes"),
    i = (t ? n.substring(`${t}0x`.length) : n).split("");
  for (let s = 0; s < 40; s += 2)
    r[s >> 1] >> 4 >= 8 && i[s] && (i[s] = i[s].toUpperCase()),
      (r[s >> 1] & 15) >= 8 && i[s + 1] && (i[s + 1] = i[s + 1].toUpperCase());
  return `0x${i.join("")}`;
}
function Yi(e, t) {
  if (!ns(e)) throw new cc({ address: e });
  return Wv(e, t);
}
function zh(e, t) {
  if (t === "0x" && e.length > 0) throw new Uh();
  if (pt(t) && pt(t) < 32) throw new $v({ data: t, params: e, size: pt(t) });
  return TD({ data: t, params: e });
}
function TD({ data: e, params: t }) {
  const n = [];
  let r = 0;
  for (let i = 0; i < t.length; i++) {
    if (r >= pt(e)) throw new $v({ data: e, params: t, size: pt(e) });
    const s = t[i],
      { consumed: o, value: a } = na({ data: e, param: s, position: r });
    n.push(a), (r += o);
  }
  return n;
}
function na({ data: e, param: t, position: n }) {
  const r = $h(t.type);
  if (r) {
    const [s, o] = r;
    return kD(e, { length: s, param: { ...t, type: o }, position: n });
  }
  if (t.type === "tuple") return BD(e, { param: t, position: n });
  if (t.type === "string") return RD(e, { position: n });
  if (t.type.startsWith("bytes")) return DD(e, { param: t, position: n });
  const i = lt(e, n, n + 32, { strict: !0 });
  if (t.type.startsWith("uint") || t.type.startsWith("int"))
    return OD(i, { param: t });
  if (t.type === "address") return ID(i);
  if (t.type === "bool") return PD(i);
  throw new L5(t.type, { docsPath: "/docs/contract/decodeAbiParameters" });
}
function ID(e) {
  return { consumed: 32, value: Wv(lt(e, -20)) };
}
function kD(e, { param: t, length: n, position: r }) {
  if (!n) {
    const o = Jt(lt(e, r, r + 32, { strict: !0 })),
      a = Jt(lt(e, o, o + 32, { strict: !0 }));
    let u = 0;
    const l = [];
    for (let c = 0; c < a; ++c) {
      const d = na({ data: lt(e, o + 32), param: t, position: u });
      (u += d.consumed), l.push(d.value);
    }
    return { value: l, consumed: 32 };
  }
  if (pf(t)) {
    const o = $h(t.type),
      a = !(o != null && o[0]);
    let u = 0;
    const l = [];
    for (let c = 0; c < n; ++c) {
      const d = Jt(lt(e, r, r + 32, { strict: !0 })),
        f = na({ data: lt(e, d), param: t, position: a ? u : c * 32 });
      (u += f.consumed), l.push(f.value);
    }
    return { value: l, consumed: 32 };
  }
  let i = 0;
  const s = [];
  for (let o = 0; o < n; ++o) {
    const a = na({ data: e, param: t, position: r + i });
    (i += a.consumed), s.push(a.value);
  }
  return { value: s, consumed: i };
}
function PD(e) {
  return { consumed: 32, value: h5(e) };
}
function DD(e, { param: t, position: n }) {
  const [r, i] = t.type.split("bytes");
  if (!i) {
    const o = Jt(lt(e, n, n + 32, { strict: !0 })),
      a = Jt(lt(e, o, o + 32, { strict: !0 }));
    return a === 0
      ? { consumed: 32, value: "0x" }
      : { consumed: 32, value: lt(e, o + 32, o + 32 + a, { strict: !0 }) };
  }
  return { consumed: 32, value: lt(e, n, n + parseInt(i), { strict: !0 }) };
}
function OD(e, { param: t }) {
  const n = t.type.startsWith("int");
  return {
    consumed: 32,
    value:
      parseInt(t.type.split("int")[1] || "256") > 48
        ? Mh(e, { signed: n })
        : Jt(e, { signed: n }),
  };
}
function RD(e, { position: t }) {
  const n = Jt(lt(e, t, t + 32, { strict: !0 })),
    r = Jt(lt(e, n, n + 32, { strict: !0 }));
  return r === 0
    ? { consumed: 32, value: "" }
    : {
        consumed: 32,
        value: jv(Hs(lt(e, n + 32, n + 32 + r, { strict: !0 }))),
      };
}
function BD(e, { param: t, position: n }) {
  const r = t.components.length === 0 || t.components.some(({ name: o }) => !o),
    i = r ? [] : {};
  let s = 0;
  if (pf(t)) {
    const o = Jt(lt(e, n, n + 32, { strict: !0 }));
    for (let a = 0; a < t.components.length; ++a) {
      const u = t.components[a],
        l = na({ data: lt(e, o), param: u, position: s });
      (s += l.consumed), (i[r ? a : u == null ? void 0 : u.name] = l.value);
    }
    return { consumed: 32, value: i };
  }
  for (let o = 0; o < t.components.length; ++o) {
    const a = t.components[o],
      u = na({ data: e, param: a, position: n + s });
    (s += u.consumed), (i[r ? o : a == null ? void 0 : a.name] = u.value);
  }
  return { consumed: s, value: i };
}
function pf(e) {
  var r;
  const { type: t } = e;
  if (t === "string" || t === "bytes" || t.endsWith("[]")) return !0;
  if (t === "tuple") return (r = e.components) == null ? void 0 : r.some(pf);
  const n = $h(e.type);
  return !!(n && pf({ ...e, type: n[1] }));
}
function ND({ abi: e, data: t }) {
  const n = lt(t, 0, 4);
  if (n === "0x") throw new Uh();
  const i = [...(e || []), SD, CD].find(
    (s) => s.type === "error" && n === qv(fi(s))
  );
  if (!i) throw new nS(n, { docsPath: "/docs/contract/decodeErrorResult" });
  return {
    abiItem: i,
    args:
      "inputs" in i && i.inputs && i.inputs.length > 0
        ? zh(i.inputs, lt(t, 4))
        : void 0,
    errorName: i.name,
  };
}
const rn = (e, t, n) =>
  JSON.stringify(
    e,
    (r, i) => {
      const s = typeof i == "bigint" ? i.toString() : i;
      return typeof t == "function" ? t(r, s) : s;
    },
    n
  );
function mS({
  abiItem: e,
  args: t,
  includeFunctionName: n = !0,
  includeName: r = !1,
}) {
  if ("name" in e && "inputs" in e && e.inputs)
    return `${n ? e.name : ""}(${e.inputs
      .map(
        (i, s) =>
          `${r && i.name ? `${i.name}: ` : ""}${
            typeof t[s] == "object" ? rn(t[s]) : t[s]
          }`
      )
      .join(", ")})`;
}
function Qv(e, t = "wei") {
  return lf(e, b5[t]);
}
function ul(e) {
  const t = Object.entries(e)
      .map(([r, i]) => (i === void 0 || i === !1 ? null : [r, i]))
      .filter(Boolean),
    n = t.reduce((r, [i]) => Math.max(r, i.length), 0);
  return t.map(([r, i]) => `  ${`${r}:`.padEnd(n + 1)}  ${i}`).join(`
`);
}
class MD extends q {
  constructor() {
    super(
      [
        "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
        "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.",
      ].join(`
`)
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "FeeConflictError",
      });
  }
}
class LD extends q {
  constructor({ transaction: t }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        ul(t),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- a Legacy Transaction with `gasPrice`",
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidSerializableTransactionError",
      });
  }
}
class FD extends q {
  constructor(
    t,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: o,
      gasPrice: a,
      maxFeePerGas: u,
      maxPriorityFeePerGas: l,
      nonce: c,
      to: d,
      value: f,
    }
  ) {
    var m;
    const p = ul({
      chain:
        i &&
        `${i == null ? void 0 : i.name} (id: ${i == null ? void 0 : i.id})`,
      from: n == null ? void 0 : n.address,
      to: d,
      value:
        typeof f < "u" &&
        `${Qv(f)} ${
          ((m = i == null ? void 0 : i.nativeCurrency) == null
            ? void 0
            : m.symbol) || "ETH"
        }`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${En(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${En(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${En(l)} gwei`,
      nonce: c,
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...(t.metaMessages ? [...t.metaMessages, " "] : []),
        "Request Arguments:",
        p,
      ].filter(Boolean),
    }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "TransactionExecutionError",
      }),
      (this.cause = t);
  }
}
class yS extends q {
  constructor({
    blockHash: t,
    blockNumber: n,
    blockTag: r,
    hash: i,
    index: s,
  }) {
    let o = "Transaction";
    r &&
      s !== void 0 &&
      (o = `Transaction at block time "${r}" at index "${s}"`),
      t &&
        s !== void 0 &&
        (o = `Transaction at block hash "${t}" at index "${s}"`),
      n &&
        s !== void 0 &&
        (o = `Transaction at block number "${n}" at index "${s}"`),
      i && (o = `Transaction with hash "${i}"`),
      super(`${o} could not be found.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "TransactionNotFoundError",
      });
  }
}
class gS extends q {
  constructor({ hash: t }) {
    super(
      `Transaction receipt with hash "${t}" could not be found. The Transaction may not be processed on a block yet.`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "TransactionReceiptNotFoundError",
      });
  }
}
class jD extends q {
  constructor({ hash: t }) {
    super(
      `Timed out while waiting for transaction with hash "${t}" to be confirmed.`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "WaitForTransactionReceiptTimeoutError",
      });
  }
}
class vS extends q {
  constructor(
    t,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: o,
      gasPrice: a,
      maxFeePerGas: u,
      maxPriorityFeePerGas: l,
      nonce: c,
      to: d,
      value: f,
    }
  ) {
    var g;
    const p = n ? tr(n) : void 0,
      m = ul({
        from: p == null ? void 0 : p.address,
        to: d,
        value:
          typeof f < "u" &&
          `${Qv(f)} ${
            ((g = i == null ? void 0 : i.nativeCurrency) == null
              ? void 0
              : g.symbol) || "ETH"
          }`,
        data: s,
        gas: o,
        gasPrice: typeof a < "u" && `${En(a)} gwei`,
        maxFeePerGas: typeof u < "u" && `${En(u)} gwei`,
        maxPriorityFeePerGas: typeof l < "u" && `${En(l)} gwei`,
        nonce: c,
      });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...(t.metaMessages ? [...t.metaMessages, " "] : []),
        "Raw Call Arguments:",
        m,
      ].filter(Boolean),
    }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "CallExecutionError",
      }),
      (this.cause = t);
  }
}
class Vv extends q {
  constructor(
    t,
    {
      abi: n,
      args: r,
      contractAddress: i,
      docsPath: s,
      functionName: o,
      sender: a,
    }
  ) {
    const u = ol({ abi: n, args: r, name: o }),
      l = u
        ? mS({ abiItem: u, args: r, includeFunctionName: !1, includeName: !1 })
        : void 0,
      c = u ? fi(u, { includeName: !0 }) : void 0,
      d = ul({
        address: i && n5(i),
        function: c,
        args:
          l &&
          l !== "()" &&
          `${[...Array((o == null ? void 0 : o.length) ?? 0).keys()]
            .map(() => " ")
            .join("")}${l}`,
        sender: a,
      });
    super(
      t.shortMessage ||
        `An unknown error occurred while executing the contract function "${o}".`,
      {
        cause: t,
        docsPath: s,
        metaMessages: [
          ...(t.metaMessages ? [...t.metaMessages, " "] : []),
          "Contract Call:",
          d,
        ].filter(Boolean),
      }
    ),
      Object.defineProperty(this, "abi", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "args", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "contractAddress", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "formattedArgs", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "functionName", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "sender", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ContractFunctionExecutionError",
      }),
      (this.abi = n),
      (this.args = r),
      (this.cause = t),
      (this.contractAddress = i),
      (this.functionName = o),
      (this.sender = a);
  }
}
class my extends q {
  constructor({ abi: t, data: n, functionName: r, message: i }) {
    let s, o, a, u;
    if (n && n !== "0x")
      try {
        o = ND({ abi: t, data: n });
        const { abiItem: c, errorName: d, args: f } = o;
        if (d === "Error") u = f[0];
        else if (d === "Panic") {
          const [p] = f;
          u = pS[p];
        } else {
          const p = c ? fi(c, { includeName: !0 }) : void 0,
            m =
              c && f
                ? mS({
                    abiItem: c,
                    args: f,
                    includeFunctionName: !1,
                    includeName: !1,
                  })
                : void 0;
          a = [
            p ? `Error: ${p}` : "",
            m && m !== "()"
              ? `       ${[
                  ...Array((d == null ? void 0 : d.length) ?? 0).keys(),
                ]
                  .map(() => " ")
                  .join("")}${m}`
              : "",
          ];
        }
      } catch (c) {
        s = c;
      }
    else i && (u = i);
    let l;
    s instanceof nS &&
      ((l = s.signature),
      (a = [
        `Unable to decode signature "${l}" as it was not found on the provided ABI.`,
        "Make sure you are using the correct ABI and that the error exists on it.",
        `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${l}.`,
      ])),
      super(
        (u && u !== "execution reverted") || l
          ? [
              `The contract function "${r}" reverted with the following ${
                l ? "signature" : "reason"
              }:`,
              u || l,
            ].join(`
`)
          : `The contract function "${r}" reverted.`,
        { cause: s, metaMessages: a }
      ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ContractFunctionRevertedError",
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "reason", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "signature", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = o),
      (this.reason = u),
      (this.signature = l);
  }
}
class UD extends q {
  constructor({ functionName: t }) {
    super(`The contract function "${t}" returned no data ("0x").`, {
      metaMessages: [
        "This could be due to any of the following:",
        `  - The contract does not have the function "${t}",`,
        "  - The parameters passed to the contract function may be invalid, or",
        "  - The address is not a contract.",
      ],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ContractFunctionZeroDataError",
      });
  }
}
class Kv extends q {
  constructor({ data: t, message: n }) {
    super(n || ""),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: 3,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "RawContractError",
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = t);
  }
}
class Mu extends q {
  constructor({ body: t, details: n, headers: r, status: i, url: s }) {
    super("HTTP request failed.", {
      details: n,
      metaMessages: [
        i && `Status: ${i}`,
        `URL: ${Nh(s)}`,
        t && `Request body: ${rn(t)}`,
      ].filter(Boolean),
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "HttpRequestError",
      }),
      Object.defineProperty(this, "body", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "headers", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "status", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "url", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.body = t),
      (this.headers = r),
      (this.status = i),
      (this.url = s);
  }
}
class $D extends q {
  constructor({ body: t, details: n, url: r }) {
    super("WebSocket request failed.", {
      details: n,
      metaMessages: [`URL: ${Nh(r)}`, `Request body: ${rn(t)}`],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "WebSocketRequestError",
      });
  }
}
class Zv extends q {
  constructor({ body: t, error: n, url: r }) {
    super("RPC Request failed.", {
      cause: n,
      details: n.message,
      metaMessages: [`URL: ${Nh(r)}`, `Request body: ${rn(t)}`],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "RpcRequestError",
      }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.code = n.code);
  }
}
class yy extends q {
  constructor({ body: t, url: n }) {
    super("The request took too long to respond.", {
      details: "The request timed out.",
      metaMessages: [`URL: ${Nh(n)}`, `Request body: ${rn(t)}`],
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "TimeoutError",
      });
  }
}
const HD = -1;
let An = class extends q {
  constructor(t, { code: n, docsPath: r, metaMessages: i, shortMessage: s }) {
    super(s, {
      cause: t,
      docsPath: r,
      metaMessages: i || (t == null ? void 0 : t.metaMessages),
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "RpcError",
      }),
      Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.name = t.name),
      (this.code = t instanceof Zv ? t.code : n ?? HD);
  }
};
class ja extends An {
  constructor(t, n) {
    super(t, n),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ProviderRpcError",
      }),
      Object.defineProperty(this, "data", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      (this.data = n.data);
  }
}
class lc extends An {
  constructor(t) {
    super(t, {
      code: lc.code,
      shortMessage:
        "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ParseRpcError",
      });
  }
}
Object.defineProperty(lc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32700,
});
class dc extends An {
  constructor(t) {
    super(t, {
      code: dc.code,
      shortMessage: "JSON is not a valid request object.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidRequestRpcError",
      });
  }
}
Object.defineProperty(dc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32600,
});
class fc extends An {
  constructor(t) {
    super(t, {
      code: fc.code,
      shortMessage: "The method does not exist / is not available.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "MethodNotFoundRpcError",
      });
  }
}
Object.defineProperty(fc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32601,
});
class hc extends An {
  constructor(t) {
    super(t, {
      code: hc.code,
      shortMessage: [
        "Invalid parameters were provided to the RPC method.",
        "Double check you have provided the correct parameters.",
      ].join(`
`),
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidParamsRpcError",
      });
  }
}
Object.defineProperty(hc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32602,
});
class ga extends An {
  constructor(t) {
    super(t, {
      code: ga.code,
      shortMessage: "An internal error was received.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InternalRpcError",
      });
  }
}
Object.defineProperty(ga, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32603,
});
class eo extends An {
  constructor(t) {
    super(t, {
      code: eo.code,
      shortMessage: [
        "Missing or invalid parameters.",
        "Double check you have provided the correct parameters.",
      ].join(`
`),
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "InvalidInputRpcError",
      });
  }
}
Object.defineProperty(eo, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32e3,
});
class pc extends An {
  constructor(t) {
    super(t, { code: pc.code, shortMessage: "Requested resource not found." }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ResourceNotFoundRpcError",
      });
  }
}
Object.defineProperty(pc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32001,
});
class va extends An {
  constructor(t) {
    super(t, {
      code: va.code,
      shortMessage: "Requested resource not available.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ResourceUnavailableRpcError",
      });
  }
}
Object.defineProperty(va, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32002,
});
class mc extends An {
  constructor(t) {
    super(t, { code: mc.code, shortMessage: "Transaction creation failed." }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "TransactionRejectedRpcError",
      });
  }
}
Object.defineProperty(mc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32003,
});
class yc extends An {
  constructor(t) {
    super(t, { code: yc.code, shortMessage: "Method is not implemented." }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "MethodNotSupportedRpcError",
      });
  }
}
Object.defineProperty(yc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32004,
});
class gc extends An {
  constructor(t) {
    super(t, { code: gc.code, shortMessage: "Request exceeds defined limit." }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "LimitExceededRpcError",
      });
  }
}
Object.defineProperty(gc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32005,
});
class vc extends An {
  constructor(t) {
    super(t, {
      code: vc.code,
      shortMessage: "Version of JSON-RPC protocol is not supported.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "JsonRpcVersionUnsupportedError",
      });
  }
}
Object.defineProperty(vc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: -32006,
});
class Vn extends ja {
  constructor(t) {
    super(t, { code: Vn.code, shortMessage: "User rejected the request." }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UserRejectedRequestError",
      });
  }
}
Object.defineProperty(Vn, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4001,
});
class bc extends ja {
  constructor(t) {
    super(t, {
      code: bc.code,
      shortMessage:
        "The requested method and/or account has not been authorized by the user.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnauthorizedProviderError",
      });
  }
}
Object.defineProperty(bc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4100,
});
class wc extends ja {
  constructor(t) {
    super(t, {
      code: wc.code,
      shortMessage: "The Provider does not support the requested method.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnsupportedProviderMethodError",
      });
  }
}
Object.defineProperty(wc, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4200,
});
class Ec extends ja {
  constructor(t) {
    super(t, {
      code: Ec.code,
      shortMessage: "The Provider is disconnected from all chains.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ProviderDisconnectedError",
      });
  }
}
Object.defineProperty(Ec, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4900,
});
class _c extends ja {
  constructor(t) {
    super(t, {
      code: _c.code,
      shortMessage: "The Provider is not connected to the requested chain.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "ChainDisconnectedError",
      });
  }
}
Object.defineProperty(_c, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4901,
});
class rs extends ja {
  constructor(t) {
    super(t, {
      code: rs.code,
      shortMessage: "An error occurred when attempting to switch chain.",
    }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "SwitchChainError",
      });
  }
}
Object.defineProperty(rs, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 4902,
});
class zD extends An {
  constructor(t) {
    super(t, { shortMessage: "An unknown RPC error occurred." }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "UnknownRpcError",
      });
  }
}
const GD = 3;
function Ac(
  e,
  { abi: t, address: n, args: r, docsPath: i, functionName: s, sender: o }
) {
  const {
      code: a,
      data: u,
      message: l,
      shortMessage: c,
    } = e instanceof Kv
      ? e
      : e instanceof q
      ? e.walk((f) => "data" in f) || e.walk()
      : {},
    d =
      e instanceof Uh
        ? new UD({ functionName: s })
        : [GD, ga.code].includes(a) && (u || l || c)
        ? new my({
            abi: t,
            data: typeof u == "object" ? u.data : u,
            functionName: s,
            message: c ?? l,
          })
        : e;
  return new Vv(d, {
    abi: t,
    args: r,
    contractAddress: n,
    docsPath: i,
    functionName: s,
    sender: o,
  });
}
class Ua extends q {
  constructor({ docsPath: t } = {}) {
    super(
      [
        "Could not find an Account to execute with this Action.",
        "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient.",
      ].join(`
`),
      { docsPath: t, docsSlug: "account" }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "AccountNotFoundError",
      });
  }
}
class qD extends q {
  constructor(
    t,
    {
      account: n,
      docsPath: r,
      chain: i,
      data: s,
      gas: o,
      gasPrice: a,
      maxFeePerGas: u,
      maxPriorityFeePerGas: l,
      nonce: c,
      to: d,
      value: f,
    }
  ) {
    var m;
    const p = ul({
      from: n == null ? void 0 : n.address,
      to: d,
      value:
        typeof f < "u" &&
        `${Qv(f)} ${
          ((m = i == null ? void 0 : i.nativeCurrency) == null
            ? void 0
            : m.symbol) || "ETH"
        }`,
      data: s,
      gas: o,
      gasPrice: typeof a < "u" && `${En(a)} gwei`,
      maxFeePerGas: typeof u < "u" && `${En(u)} gwei`,
      maxPriorityFeePerGas: typeof l < "u" && `${En(l)} gwei`,
      nonce: c,
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...(t.metaMessages ? [...t.metaMessages, " "] : []),
        "Estimate Gas Arguments:",
        p,
      ].filter(Boolean),
    }),
      Object.defineProperty(this, "cause", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0,
      }),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "EstimateGasExecutionError",
      }),
      (this.cause = t);
  }
}
function Jv(e, t) {
  const n = (e.details || "").toLowerCase(),
    r = e.walk((i) => i.code === Wo.code);
  return r instanceof q
    ? new Wo({ cause: e, message: r.details })
    : Wo.nodeMessage.test(n)
    ? new Wo({ cause: e, message: e.details })
    : df.nodeMessage.test(n)
    ? new df({ cause: e, maxFeePerGas: t == null ? void 0 : t.maxFeePerGas })
    : sy.nodeMessage.test(n)
    ? new sy({ cause: e, maxFeePerGas: t == null ? void 0 : t.maxFeePerGas })
    : oy.nodeMessage.test(n)
    ? new oy({ cause: e, nonce: t == null ? void 0 : t.nonce })
    : ay.nodeMessage.test(n)
    ? new ay({ cause: e, nonce: t == null ? void 0 : t.nonce })
    : uy.nodeMessage.test(n)
    ? new uy({ cause: e, nonce: t == null ? void 0 : t.nonce })
    : cy.nodeMessage.test(n)
    ? new cy({ cause: e })
    : ly.nodeMessage.test(n)
    ? new ly({ cause: e, gas: t == null ? void 0 : t.gas })
    : dy.nodeMessage.test(n)
    ? new dy({ cause: e, gas: t == null ? void 0 : t.gas })
    : fy.nodeMessage.test(n)
    ? new fy({ cause: e })
    : ff.nodeMessage.test(n)
    ? new ff({
        cause: e,
        maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
        maxPriorityFeePerGas: t == null ? void 0 : t.maxPriorityFeePerGas,
      })
    : new Fh({ cause: e });
}
function WD(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = Jv(e, n);
    return i instanceof Fh ? e : i;
  })();
  return new qD(r, { docsPath: t, ...n });
}
function Yv(e, { format: t }) {
  if (!t) return {};
  const n = {};
  function r(s) {
    const o = Object.keys(s);
    for (const a of o)
      a in e && (n[a] = e[a]),
        s[a] && typeof s[a] == "object" && !Array.isArray(s[a]) && r(s[a]);
  }
  const i = t(e || {});
  return r(i), n;
}
function cl(e) {
  const {
      account: t,
      gasPrice: n,
      maxFeePerGas: r,
      maxPriorityFeePerGas: i,
      to: s,
    } = e,
    o = t ? tr(t) : void 0;
  if (o && !ns(o.address)) throw new cc({ address: o.address });
  if (s && !ns(s)) throw new cc({ address: s });
  if (typeof n < "u" && (typeof r < "u" || typeof i < "u")) throw new MD();
  if (r && r > 2n ** 256n - 1n) throw new df({ maxFeePerGas: r });
  if (i && r && i > r)
    throw new ff({ maxFeePerGas: r, maxPriorityFeePerGas: i });
}
class QD extends q {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1."),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "BaseFeeScalarError",
      });
  }
}
class Xv extends q {
  constructor() {
    super("Chain does not support EIP-1559 fees."),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "Eip1559FeesNotSupportedError",
      });
  }
}
class VD extends q {
  constructor({ maxPriorityFeePerGas: t }) {
    super(
      `\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${En(
        t
      )} gwei).`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "MaxFeePerGasTooLowError",
      });
  }
}
class bS extends q {
  constructor({ blockHash: t, blockNumber: n }) {
    let r = "Block";
    t && (r = `Block at hash "${t}"`),
      n && (r = `Block at number "${n}"`),
      super(`${r} could not be found.`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "BlockNotFoundError",
      });
  }
}
async function is(
  e,
  { blockHash: t, blockNumber: n, blockTag: r, includeTransactions: i } = {}
) {
  var c, d, f;
  const s = r ?? "latest",
    o = i ?? !1,
    a = n !== void 0 ? he(n) : void 0;
  let u = null;
  if (
    (t
      ? (u = await e.request({ method: "eth_getBlockByHash", params: [t, o] }))
      : (u = await e.request({
          method: "eth_getBlockByNumber",
          params: [a || s, o],
        })),
    !u)
  )
    throw new bS({ blockHash: t, blockNumber: n });
  return (
    ((f =
      (d = (c = e.chain) == null ? void 0 : c.formatters) == null
        ? void 0
        : d.block) == null
      ? void 0
      : f.format) || eS
  )(u);
}
async function eb(e) {
  const t = await e.request({ method: "eth_gasPrice" });
  return BigInt(t);
}
async function KD(e, t) {
  return wS(e, t);
}
async function wS(e, t) {
  var s, o, a;
  const { block: n, chain: r = e.chain, request: i } = t || {};
  if (
    typeof ((s = r == null ? void 0 : r.fees) == null
      ? void 0
      : s.defaultPriorityFee) == "function"
  ) {
    const u = n || (await se(e, is, "getBlock")({}));
    return r.fees.defaultPriorityFee({ block: u, client: e, request: i });
  }
  if (
    typeof ((o = r == null ? void 0 : r.fees) == null
      ? void 0
      : o.defaultPriorityFee) < "u"
  )
    return (a = r == null ? void 0 : r.fees) == null
      ? void 0
      : a.defaultPriorityFee;
  try {
    const u = await e.request({ method: "eth_maxPriorityFeePerGas" });
    return Mh(u);
  } catch {
    const [u, l] = await Promise.all([
      n ? Promise.resolve(n) : se(e, is, "getBlock")({}),
      se(e, eb, "getGasPrice")({}),
    ]);
    if (typeof u.baseFeePerGas != "bigint") throw new Xv();
    const c = l - u.baseFeePerGas;
    return c < 0n ? 0n : c;
  }
}
async function ZD(e, t) {
  return gy(e, t);
}
async function gy(e, t) {
  var f, p;
  const {
      block: n,
      chain: r = e.chain,
      request: i,
      type: s = "eip1559",
    } = t || {},
    o = await (async () => {
      var m, g;
      return typeof ((m = r == null ? void 0 : r.fees) == null
        ? void 0
        : m.baseFeeMultiplier) == "function"
        ? r.fees.baseFeeMultiplier({ block: n, client: e, request: i })
        : ((g = r == null ? void 0 : r.fees) == null
            ? void 0
            : g.baseFeeMultiplier) ?? 1.2;
    })();
  if (o < 1) throw new QD();
  const u =
      10 **
      (((f = o.toString().split(".")[1]) == null ? void 0 : f.length) ?? 0),
    l = (m) => (m * BigInt(Math.ceil(o * u))) / BigInt(u),
    c = n || (await se(e, is, "getBlock")({}));
  if (
    typeof ((p = r == null ? void 0 : r.fees) == null
      ? void 0
      : p.estimateFeesPerGas) == "function"
  )
    return r.fees.estimateFeesPerGas({
      block: n,
      client: e,
      multiply: l,
      request: i,
      type: s,
    });
  if (s === "eip1559") {
    if (typeof c.baseFeePerGas != "bigint") throw new Xv();
    const m =
        i != null && i.maxPriorityFeePerGas
          ? i.maxPriorityFeePerGas
          : await wS(e, { block: c, chain: r, request: i }),
      g = l(c.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? g + m,
      maxPriorityFeePerGas: m,
    };
  }
  return {
    gasPrice:
      (i == null ? void 0 : i.gasPrice) ??
      l(await se(e, eb, "getGasPrice")({})),
  };
}
async function ES(e, { address: t, blockTag: n = "latest", blockNumber: r }) {
  const i = await e.request({
    method: "eth_getTransactionCount",
    params: [t, r ? he(r) : n],
  });
  return Jt(i);
}
function JD(e) {
  if (e.type) return e.type;
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e.gasPrice < "u")
    return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new LD({ transaction: e });
}
async function Gh(e, t) {
  const { account: n = e.account, chain: r, gas: i, nonce: s, type: o } = t;
  if (!n) throw new Ua();
  const a = tr(n),
    u = await se(e, is, "getBlock")({ blockTag: "latest" }),
    l = { ...t, from: a.address };
  if (
    (typeof s > "u" &&
      (l.nonce = await se(
        e,
        ES,
        "getTransactionCount"
      )({ address: a.address, blockTag: "pending" })),
    typeof o > "u")
  )
    try {
      l.type = JD(l);
    } catch {
      l.type = typeof u.baseFeePerGas == "bigint" ? "eip1559" : "legacy";
    }
  if (l.type === "eip1559") {
    const { maxFeePerGas: c, maxPriorityFeePerGas: d } = await gy(e, {
      block: u,
      chain: r,
      request: l,
    });
    if (
      typeof t.maxPriorityFeePerGas > "u" &&
      t.maxFeePerGas &&
      t.maxFeePerGas < d
    )
      throw new VD({ maxPriorityFeePerGas: d });
    (l.maxPriorityFeePerGas = d), (l.maxFeePerGas = c);
  } else {
    if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
      throw new Xv();
    const { gasPrice: c } = await gy(e, {
      block: u,
      chain: r,
      request: l,
      type: "legacy",
    });
    l.gasPrice = c;
  }
  return (
    typeof i > "u" &&
      (l.gas = await se(
        e,
        tb,
        "estimateGas"
      )({ ...l, account: { address: a.address, type: "json-rpc" } })),
    cl(l),
    l
  );
}
async function tb(e, t) {
  var i, s, o;
  const n = t.account ?? e.account;
  if (!n) throw new Ua({ docsPath: "/docs/actions/public/estimateGas" });
  const r = tr(n);
  try {
    const {
        accessList: a,
        blockNumber: u,
        blockTag: l,
        data: c,
        gas: d,
        gasPrice: f,
        maxFeePerGas: p,
        maxPriorityFeePerGas: m,
        nonce: g,
        to: w,
        value: v,
        ...y
      } = r.type === "local" ? await Gh(e, t) : t,
      _ = (u ? he(u) : void 0) || l;
    cl(t);
    const A =
        (o =
          (s = (i = e.chain) == null ? void 0 : i.formatters) == null
            ? void 0
            : s.transactionRequest) == null
          ? void 0
          : o.format,
      h = (A || Lh)({
        ...Yv(y, { format: A }),
        from: r.address,
        accessList: a,
        data: c,
        gas: d,
        gasPrice: f,
        maxFeePerGas: p,
        maxPriorityFeePerGas: m,
        nonce: g,
        to: w,
        value: v,
      }),
      E = await e.request({
        method: "eth_estimateGas",
        params: _ ? [h, _] : [h],
      });
    return BigInt(E);
  } catch (a) {
    throw WD(a, { ...t, account: r, chain: e.chain });
  }
}
async function YD(e, { abi: t, address: n, args: r, functionName: i, ...s }) {
  const o = ms({ abi: t, args: r, functionName: i });
  try {
    return await se(e, tb, "estimateGas")({ data: o, to: n, ...s });
  } catch (a) {
    const u = s.account ? tr(s.account) : void 0;
    throw Ac(a, {
      abi: t,
      address: n,
      args: r,
      docsPath: "/docs/contract/estimateContractGas",
      functionName: i,
      sender: u == null ? void 0 : u.address,
    });
  }
}
const nE = "/docs/contract/decodeEventLog";
function ll({ abi: e, data: t, strict: n, topics: r }) {
  const i = n ?? !0,
    [s, ...o] = r;
  if (!s) throw new D5({ docsPath: nE });
  const a = e.find((m) => m.type === "event" && s === Hv(fi(m)));
  if (!(a && "name" in a) || a.type !== "event")
    throw new O5(s, { docsPath: nE });
  const { name: u, inputs: l } = a,
    c = l == null ? void 0 : l.some((m) => !("name" in m && m.name));
  let d = c ? [] : {};
  const f = l.filter((m) => "indexed" in m && m.indexed);
  for (let m = 0; m < f.length; m++) {
    const g = f[m],
      w = o[m];
    if (!w) throw new Fa({ abiItem: a, param: g });
    d[g.name || m] = XD({ param: g, value: w });
  }
  const p = l.filter((m) => !("indexed" in m && m.indexed));
  if (p.length > 0) {
    if (t && t !== "0x")
      try {
        const m = zh(p, t);
        if (m)
          if (c) d = [...d, ...m];
          else for (let g = 0; g < p.length; g++) d[p[g].name] = m[g];
      } catch (m) {
        if (i)
          throw m instanceof $v
            ? new Xs({
                abiItem: a,
                data: m.data,
                params: m.params,
                size: m.size,
              })
            : m;
      }
    else if (i) throw new Xs({ abiItem: a, data: "0x", params: p, size: 0 });
  }
  return { eventName: u, args: Object.values(d).length > 0 ? d : void 0 };
}
function XD({ param: e, value: t }) {
  return e.type === "string" ||
    e.type === "bytes" ||
    e.type === "tuple" ||
    e.type.match(/^(.*)\[(\d+)?\]$/)
    ? t
    : (zh([e], t) || [])[0];
}
async function nb(
  e,
  {
    address: t,
    blockHash: n,
    fromBlock: r,
    toBlock: i,
    event: s,
    events: o,
    args: a,
    strict: u,
  } = {}
) {
  const l = u ?? !1,
    c = o ?? (s ? [s] : void 0);
  let d = [];
  c &&
    ((d = [c.flatMap((p) => al({ abi: [p], eventName: p.name, args: a }))]),
    s && (d = d[0]));
  let f;
  return (
    n
      ? (f = await e.request({
          method: "eth_getLogs",
          params: [{ address: t, topics: d, blockHash: n }],
        }))
      : (f = await e.request({
          method: "eth_getLogs",
          params: [
            {
              address: t,
              topics: d,
              fromBlock: typeof r == "bigint" ? he(r) : r,
              toBlock: typeof i == "bigint" ? he(i) : i,
            },
          ],
        })),
    f
      .map((p) => {
        var m;
        try {
          const { eventName: g, args: w } = c
            ? ll({ abi: c, data: p.data, topics: p.topics, strict: l })
            : { eventName: void 0, args: void 0 };
          return pr(p, { args: w, eventName: g });
        } catch (g) {
          let w, v;
          if (g instanceof Xs || g instanceof Fa) {
            if (l) return;
            (w = g.abiItem.name),
              (v =
                (m = g.abiItem.inputs) == null
                  ? void 0
                  : m.some((y) => !("name" in y && y.name)));
          }
          return pr(p, { args: v ? [] : {}, eventName: w });
        }
      })
      .filter(Boolean)
  );
}
async function _S(
  e,
  {
    abi: t,
    address: n,
    args: r,
    blockHash: i,
    eventName: s,
    fromBlock: o,
    toBlock: a,
    strict: u,
  }
) {
  const l = s ? ol({ abi: t, name: s }) : void 0,
    c = l ? void 0 : t.filter((d) => d.type === "event");
  return se(
    e,
    nb,
    "getLogs"
  )({
    address: n,
    args: r,
    blockHash: i,
    event: l,
    events: c,
    fromBlock: o,
    toBlock: a,
    strict: u,
  });
}
const ym = "/docs/contract/decodeFunctionResult";
function $a({ abi: e, args: t, functionName: n, data: r }) {
  let i = e[0];
  if (n && ((i = ol({ abi: e, args: t, name: n })), !i))
    throw new hf(n, { docsPath: ym });
  if (i.type !== "function") throw new hf(void 0, { docsPath: ym });
  if (!i.outputs) throw new R5(i.name, { docsPath: ym });
  const s = zh(i.outputs, r);
  if (s && s.length > 1) return s;
  if (s && s.length === 1) return s[0];
}
const eO = "modulepreload",
  tO = function (e) {
    return "/" + e;
  },
  rE = {},
  qh = function (t, n, r) {
    let i = Promise.resolve();
    if (n && n.length > 0) {
      const s = document.getElementsByTagName("link");
      i = Promise.all(
        n.map((o) => {
          if (((o = tO(o)), o in rE)) return;
          rE[o] = !0;
          const a = o.endsWith(".css"),
            u = a ? '[rel="stylesheet"]' : "";
          if (!!r)
            for (let d = s.length - 1; d >= 0; d--) {
              const f = s[d];
              if (f.href === o && (!a || f.rel === "stylesheet")) return;
            }
          else if (document.querySelector(`link[href="${o}"]${u}`)) return;
          const c = document.createElement("link");
          if (
            ((c.rel = a ? "stylesheet" : eO),
            a || ((c.as = "script"), (c.crossOrigin = "")),
            (c.href = o),
            document.head.appendChild(c),
            a)
          )
            return new Promise((d, f) => {
              c.addEventListener("load", d),
                c.addEventListener("error", () =>
                  f(new Error(`Unable to preload CSS for ${o}`))
                );
            });
        })
      );
    }
    return i
      .then(() => t())
      .catch((s) => {
        const o = new Event("vite:preloadError", { cancelable: !0 });
        if (((o.payload = s), window.dispatchEvent(o), !o.defaultPrevented))
          throw s;
      });
  },
  vy = [
    {
      inputs: [
        {
          components: [
            { name: "target", type: "address" },
            { name: "allowFailure", type: "bool" },
            { name: "callData", type: "bytes" },
          ],
          name: "calls",
          type: "tuple[]",
        },
      ],
      name: "aggregate3",
      outputs: [
        {
          components: [
            { name: "success", type: "bool" },
            { name: "returnData", type: "bytes" },
          ],
          name: "returnData",
          type: "tuple[]",
        },
      ],
      stateMutability: "view",
      type: "function",
    },
  ],
  AS = [
    { inputs: [], name: "ResolverNotFound", type: "error" },
    { inputs: [], name: "ResolverWildcardNotSupported", type: "error" },
  ],
  xS = [
    ...AS,
    {
      name: "resolve",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes" },
        { name: "data", type: "bytes" },
      ],
      outputs: [
        { name: "", type: "bytes" },
        { name: "address", type: "address" },
      ],
    },
  ],
  nO = [
    ...AS,
    {
      name: "reverse",
      type: "function",
      stateMutability: "view",
      inputs: [{ type: "bytes", name: "reverseName" }],
      outputs: [
        { type: "string", name: "resolvedName" },
        { type: "address", name: "resolvedAddress" },
        { type: "address", name: "reverseResolver" },
        { type: "address", name: "resolver" },
      ],
    },
  ],
  iE = [
    {
      name: "text",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "key", type: "string" },
      ],
      outputs: [{ name: "", type: "string" }],
    },
  ],
  sE = [
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [{ name: "name", type: "bytes32" }],
      outputs: [{ name: "", type: "address" }],
    },
    {
      name: "addr",
      type: "function",
      stateMutability: "view",
      inputs: [
        { name: "name", type: "bytes32" },
        { name: "coinType", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bytes" }],
    },
  ],
  rO = [
    {
      inputs: [
        { internalType: "address", name: "_signer", type: "address" },
        { internalType: "bytes32", name: "_hash", type: "bytes32" },
        { internalType: "bytes", name: "_signature", type: "bytes" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
  ],
  iO = "0x82ad56cb";
function Ha({ blockNumber: e, chain: t, contract: n }) {
  var i;
  const r = (i = t == null ? void 0 : t.contracts) == null ? void 0 : i[n];
  if (!r) throw new iy({ chain: t, contract: { name: n } });
  if (e && r.blockCreated && r.blockCreated > e)
    throw new iy({
      blockNumber: e,
      chain: t,
      contract: { name: n, blockCreated: r.blockCreated },
    });
  return r.address;
}
function sO(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = Jv(e, n);
    return i instanceof Fh ? e : i;
  })();
  return new vS(r, { docsPath: t, ...n });
}
const gm = new Map();
function rb({ fn: e, id: t, shouldSplitBatch: n, wait: r = 0, sort: i }) {
  const s = async () => {
      const c = u();
      o();
      const d = c.map(({ args: f }) => f);
      d.length !== 0 &&
        e(d)
          .then((f) => {
            var p;
            i && Array.isArray(f) && f.sort(i);
            for (let m = 0; m < c.length; m++) {
              const { pendingPromise: g } = c[m];
              (p = g.resolve) == null || p.call(g, [f[m], f]);
            }
          })
          .catch((f) => {
            var p;
            for (let m = 0; m < c.length; m++) {
              const { pendingPromise: g } = c[m];
              (p = g.reject) == null || p.call(g, f);
            }
          });
    },
    o = () => gm.delete(t),
    a = () => u().map(({ args: c }) => c),
    u = () => gm.get(t) || [],
    l = (c) => gm.set(t, [...u(), c]);
  return {
    flush: o,
    async schedule(c) {
      const d = {},
        f = new Promise((g, w) => {
          (d.resolve = g), (d.reject = w);
        });
      return (
        (n == null ? void 0 : n([...a(), c])) && s(),
        u().length > 0
          ? (l({ args: c, pendingPromise: d }), f)
          : (l({ args: c, pendingPromise: d }), setTimeout(s, r), f)
      );
    },
  };
}
async function Wh(e, t) {
  var v, y, b, _;
  const {
      account: n = e.account,
      batch: r = !!((v = e.batch) != null && v.multicall),
      blockNumber: i,
      blockTag: s = "latest",
      accessList: o,
      data: a,
      gas: u,
      gasPrice: l,
      maxFeePerGas: c,
      maxPriorityFeePerGas: d,
      nonce: f,
      to: p,
      value: m,
      ...g
    } = t,
    w = n ? tr(n) : void 0;
  try {
    cl(t);
    const x = (i ? he(i) : void 0) || s,
      h =
        (_ =
          (b = (y = e.chain) == null ? void 0 : y.formatters) == null
            ? void 0
            : b.transactionRequest) == null
          ? void 0
          : _.format,
      I = (h || Lh)({
        ...Yv(g, { format: h }),
        from: w == null ? void 0 : w.address,
        accessList: o,
        data: a,
        gas: u,
        gasPrice: l,
        maxFeePerGas: c,
        maxPriorityFeePerGas: d,
        nonce: f,
        to: p,
        value: m,
      });
    if (r && oO({ request: I }))
      try {
        return await aO(e, { ...I, blockNumber: i, blockTag: s });
      } catch (k) {
        if (!(k instanceof tS) && !(k instanceof iy)) throw k;
      }
    const C = await e.request({ method: "eth_call", params: x ? [I, x] : [I] });
    return C === "0x" ? { data: void 0 } : { data: C };
  } catch (A) {
    const x = uO(A),
      { offchainLookup: h, offchainLookupSignature: E } = await qh(
        () => import("./ccip-ekrhdqsS.js"),
        __vite__mapDeps([])
      );
    if ((x == null ? void 0 : x.slice(0, 10)) === E && p)
      return { data: await h(e, { data: x, to: p }) };
    throw sO(A, { ...t, account: w, chain: e.chain });
  }
}
function oO({ request: e }) {
  const { data: t, to: n, ...r } = e;
  return !(
    !t ||
    t.startsWith(iO) ||
    !n ||
    Object.values(r).filter((i) => typeof i < "u").length > 0
  );
}
async function aO(e, t) {
  var g;
  const { batchSize: n = 1024, wait: r = 0 } =
      typeof ((g = e.batch) == null ? void 0 : g.multicall) == "object"
        ? e.batch.multicall
        : {},
    {
      blockNumber: i,
      blockTag: s = "latest",
      data: o,
      multicallAddress: a,
      to: u,
    } = t;
  let l = a;
  if (!l) {
    if (!e.chain) throw new tS();
    l = Ha({ blockNumber: i, chain: e.chain, contract: "multicall3" });
  }
  const d = (i ? he(i) : void 0) || s,
    { schedule: f } = rb({
      id: `${e.uid}.${d}`,
      wait: r,
      shouldSplitBatch(w) {
        return w.reduce((y, { data: b }) => y + (b.length - 2), 0) > n * 2;
      },
      fn: async (w) => {
        const v = w.map((_) => ({
            allowFailure: !0,
            callData: _.data,
            target: _.to,
          })),
          y = ms({ abi: vy, args: [v], functionName: "aggregate3" }),
          b = await e.request({
            method: "eth_call",
            params: [{ data: y, to: l }, d],
          });
        return $a({
          abi: vy,
          args: [v],
          functionName: "aggregate3",
          data: b || "0x",
        });
      },
    }),
    [{ returnData: p, success: m }] = await f({ data: o, to: u });
  if (!m) throw new Kv({ data: p });
  return p === "0x" ? { data: void 0 } : { data: p };
}
function uO(e) {
  if (!(e instanceof q)) return;
  const t = e.walk();
  return typeof t.data == "object" ? t.data.data : t.data;
}
async function ss(e, { abi: t, address: n, args: r, functionName: i, ...s }) {
  const o = ms({ abi: t, args: r, functionName: i });
  try {
    const { data: a } = await se(e, Wh, "call")({ data: o, to: n, ...s });
    return $a({ abi: t, args: r, functionName: i, data: a || "0x" });
  } catch (a) {
    throw Ac(a, {
      abi: t,
      address: n,
      args: r,
      docsPath: "/docs/contract/readContract",
      functionName: i,
    });
  }
}
async function cO(
  e,
  { abi: t, address: n, args: r, dataSuffix: i, functionName: s, ...o }
) {
  const a = o.account ? tr(o.account) : void 0,
    u = ms({ abi: t, args: r, functionName: s });
  try {
    const { data: l } = await se(
      e,
      Wh,
      "call"
    )({ batch: !1, data: `${u}${i ? i.replace("0x", "") : ""}`, to: n, ...o });
    return {
      result: $a({ abi: t, args: r, functionName: s, data: l || "0x" }),
      request: {
        abi: t,
        address: n,
        args: r,
        dataSuffix: i,
        functionName: s,
        ...o,
      },
    };
  } catch (l) {
    throw Ac(l, {
      abi: t,
      address: n,
      args: r,
      docsPath: "/docs/contract/simulateContract",
      functionName: s,
      sender: a == null ? void 0 : a.address,
    });
  }
}
const vm = new Map(),
  oE = new Map();
let lO = 0;
function za(e, t, n) {
  const r = ++lO,
    i = () => vm.get(e) || [],
    s = () => {
      const c = i();
      vm.set(
        e,
        c.filter((d) => d.id !== r)
      );
    },
    o = () => {
      const c = oE.get(e);
      i().length === 1 && c && c(), s();
    },
    a = i();
  if ((vm.set(e, [...a, { id: r, fns: t }]), a && a.length > 0)) return o;
  const u = {};
  for (const c in t)
    u[c] = (...d) => {
      var p, m;
      const f = i();
      if (f.length !== 0)
        for (const g of f) (m = (p = g.fns)[c]) == null || m.call(p, ...d);
    };
  const l = n(u);
  return typeof l == "function" && oE.set(e, l), o;
}
async function mf(e) {
  return new Promise((t) => setTimeout(t, e));
}
function dl(e, { emitOnBegin: t, initialWaitTime: n, interval: r }) {
  let i = !0;
  const s = () => (i = !1);
  return (
    (async () => {
      let a;
      t && (a = await e({ unpoll: s }));
      const u = (await (n == null ? void 0 : n(a))) ?? r;
      await mf(u);
      const l = async () => {
        i && (await e({ unpoll: s }), await mf(r), l());
      };
      l();
    })(),
    s
  );
}
const dO = new Map(),
  fO = new Map();
function hO(e) {
  const t = (i, s) => ({
      clear: () => s.delete(i),
      get: () => s.get(i),
      set: (o) => s.set(i, o),
    }),
    n = t(e, dO),
    r = t(e, fO);
  return {
    clear: () => {
      n.clear(), r.clear();
    },
    promise: n,
    response: r,
  };
}
async function pO(e, { cacheKey: t, cacheTime: n = 1 / 0 }) {
  const r = hO(t),
    i = r.response.get();
  if (i && n > 0 && new Date().getTime() - i.created.getTime() < n)
    return i.data;
  let s = r.promise.get();
  s || ((s = e()), r.promise.set(s));
  try {
    const o = await s;
    return r.response.set({ created: new Date(), data: o }), o;
  } finally {
    r.promise.clear();
  }
}
const mO = (e) => `blockNumber.${e}`;
async function fl(e, { cacheTime: t = e.cacheTime, maxAge: n } = {}) {
  const r = await pO(() => e.request({ method: "eth_blockNumber" }), {
    cacheKey: mO(e.uid),
    cacheTime: n ?? t,
  });
  return BigInt(r);
}
async function Qh(e, { filter: t }) {
  const n = "strict" in t && t.strict;
  return (await t.request({ method: "eth_getFilterChanges", params: [t.id] }))
    .map((i) => {
      var s;
      if (typeof i == "string") return i;
      try {
        const { eventName: o, args: a } =
          "abi" in t && t.abi
            ? ll({ abi: t.abi, data: i.data, topics: i.topics, strict: n })
            : { eventName: void 0, args: void 0 };
        return pr(i, { args: a, eventName: o });
      } catch (o) {
        let a, u;
        if (o instanceof Xs || o instanceof Fa) {
          if ("strict" in t && t.strict) return;
          (a = o.abiItem.name),
            (u =
              (s = o.abiItem.inputs) == null
                ? void 0
                : s.some((l) => !("name" in l && l.name)));
        }
        return pr(i, { args: u ? [] : {}, eventName: a });
      }
    })
    .filter(Boolean);
}
async function Vh(e, { filter: t }) {
  return t.request({ method: "eth_uninstallFilter", params: [t.id] });
}
function yO(
  e,
  {
    abi: t,
    address: n,
    args: r,
    batch: i = !0,
    eventName: s,
    onError: o,
    onLogs: a,
    poll: u,
    pollingInterval: l = e.pollingInterval,
    strict: c,
  }
) {
  return (typeof u < "u" ? u : e.transport.type !== "webSocket")
    ? (() => {
        const m = rn(["watchContractEvent", n, r, i, e.uid, s, l]),
          g = c ?? !1;
        return za(m, { onLogs: a, onError: o }, (w) => {
          let v,
            y,
            b = !1;
          const _ = dl(
            async () => {
              var A;
              if (!b) {
                try {
                  y = await se(
                    e,
                    hS,
                    "createContractEventFilter"
                  )({ abi: t, address: n, args: r, eventName: s, strict: g });
                } catch {}
                b = !0;
                return;
              }
              try {
                let x;
                if (y) x = await se(e, Qh, "getFilterChanges")({ filter: y });
                else {
                  const h = await se(e, fl, "getBlockNumber")({});
                  v && v !== h
                    ? (x = await se(
                        e,
                        _S,
                        "getContractEvents"
                      )({
                        abi: t,
                        address: n,
                        args: r,
                        eventName: s,
                        fromBlock: v + 1n,
                        toBlock: h,
                        strict: g,
                      }))
                    : (x = []),
                    (v = h);
                }
                if (x.length === 0) return;
                if (i) w.onLogs(x);
                else for (const h of x) w.onLogs([h]);
              } catch (x) {
                y && x instanceof eo && (b = !1),
                  (A = w.onError) == null || A.call(w, x);
              }
            },
            { emitOnBegin: !0, interval: l }
          );
          return async () => {
            y && (await se(e, Vh, "uninstallFilter")({ filter: y })), _();
          };
        });
      })()
    : (() => {
        let m = !0,
          g = () => (m = !1);
        return (
          (async () => {
            try {
              const w = s ? al({ abi: t, eventName: s, args: r }) : [],
                { unsubscribe: v } = await e.transport.subscribe({
                  params: ["logs", { address: n, topics: w }],
                  onData(y) {
                    var _;
                    if (!m) return;
                    const b = y.result;
                    try {
                      const { eventName: A, args: x } = ll({
                          abi: t,
                          data: b.data,
                          topics: b.topics,
                          strict: c,
                        }),
                        h = pr(b, { args: x, eventName: A });
                      a([h]);
                    } catch (A) {
                      let x, h;
                      if (A instanceof Xs || A instanceof Fa) {
                        if (c) return;
                        (x = A.abiItem.name),
                          (h =
                            (_ = A.abiItem.inputs) == null
                              ? void 0
                              : _.some((I) => !("name" in I && I.name)));
                      }
                      const E = pr(b, { args: h ? [] : {}, eventName: x });
                      a([E]);
                    }
                  },
                  onError(y) {
                    o == null || o(y);
                  },
                });
              (g = v), m || g();
            } catch (w) {
              o == null || o(w);
            }
          })(),
          g
        );
      })();
}
function SS({ chain: e, currentChainId: t }) {
  if (!e) throw new v5();
  if (t !== e.id) throw new g5({ chain: e, currentChainId: t });
}
function gO(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = Jv(e, n);
    return i instanceof Fh ? e : i;
  })();
  return new FD(r, { docsPath: t, ...n });
}
async function xc(e) {
  const t = await e.request({ method: "eth_chainId" });
  return Jt(t);
}
async function ib(e, { serializedTransaction: t }) {
  return e.request({ method: "eth_sendRawTransaction", params: [t] });
}
async function sb(e, t) {
  var g, w, v, y;
  const {
    account: n = e.account,
    chain: r = e.chain,
    accessList: i,
    data: s,
    gas: o,
    gasPrice: a,
    maxFeePerGas: u,
    maxPriorityFeePerGas: l,
    nonce: c,
    to: d,
    value: f,
    ...p
  } = t;
  if (!n) throw new Ua({ docsPath: "/docs/actions/wallet/sendTransaction" });
  const m = tr(n);
  try {
    cl(t);
    let b;
    if (
      (r !== null &&
        ((b = await se(e, xc, "getChainId")({})),
        SS({ currentChainId: b, chain: r })),
      m.type === "local")
    ) {
      const h = await se(
        e,
        Gh,
        "prepareTransactionRequest"
      )({
        account: m,
        accessList: i,
        chain: r,
        data: s,
        gas: o,
        gasPrice: a,
        maxFeePerGas: u,
        maxPriorityFeePerGas: l,
        nonce: c,
        to: d,
        value: f,
        ...p,
      });
      b || (b = await se(e, xc, "getChainId")({}));
      const E =
          (g = r == null ? void 0 : r.serializers) == null
            ? void 0
            : g.transaction,
        I = await m.signTransaction({ ...h, chainId: b }, { serializer: E });
      return await se(
        e,
        ib,
        "sendRawTransaction"
      )({ serializedTransaction: I });
    }
    const _ =
        (y =
          (v = (w = e.chain) == null ? void 0 : w.formatters) == null
            ? void 0
            : v.transactionRequest) == null
          ? void 0
          : y.format,
      x = (_ || Lh)({
        ...Yv(p, { format: _ }),
        accessList: i,
        data: s,
        from: m.address,
        gas: o,
        gasPrice: a,
        maxFeePerGas: u,
        maxPriorityFeePerGas: l,
        nonce: c,
        to: d,
        value: f,
      });
    return await e.request({ method: "eth_sendTransaction", params: [x] });
  } catch (b) {
    throw gO(b, { ...t, account: m, chain: t.chain || void 0 });
  }
}
async function vO(
  e,
  { abi: t, address: n, args: r, dataSuffix: i, functionName: s, ...o }
) {
  const a = ms({ abi: t, args: r, functionName: s });
  return await se(
    e,
    sb,
    "sendTransaction"
  )({ data: `${a}${i ? i.replace("0x", "") : ""}`, to: n, ...o });
}
async function bO(e, { chain: t }) {
  const {
    id: n,
    name: r,
    nativeCurrency: i,
    rpcUrls: s,
    blockExplorers: o,
  } = t;
  await e.request({
    method: "wallet_addEthereumChain",
    params: [
      {
        chainId: he(n),
        chainName: r,
        nativeCurrency: i,
        rpcUrls: s.default.http,
        blockExplorerUrls: o ? Object.values(o).map(({ url: a }) => a) : void 0,
      },
    ],
  });
}
const by = 256;
let ql = by,
  Wl;
function wO(e = 11) {
  if (!Wl || ql + e > by * 2) {
    (Wl = ""), (ql = 0);
    for (let t = 0; t < by; t++)
      Wl += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
  }
  return Wl.substring(ql, ql++ + e);
}
function CS(e) {
  const {
      batch: t,
      cacheTime: n = e.pollingInterval ?? 4e3,
      key: r = "base",
      name: i = "Base Client",
      pollingInterval: s = 4e3,
      type: o = "base",
    } = e,
    a = e.chain,
    u = e.account ? tr(e.account) : void 0,
    {
      config: l,
      request: c,
      value: d,
    } = e.transport({ chain: a, pollingInterval: s }),
    f = { ...l, ...d },
    p = {
      account: u,
      batch: t,
      cacheTime: n,
      chain: a,
      key: r,
      name: i,
      pollingInterval: s,
      request: c,
      transport: f,
      type: o,
      uid: wO(),
    };
  function m(g) {
    return (w) => {
      const v = w(g);
      for (const b in p) delete v[b];
      const y = { ...g, ...v };
      return Object.assign(y, { extend: m(y) });
    };
  }
  return Object.assign(p, { extend: m(p) });
}
function wy(
  e,
  { delay: t = 100, retryCount: n = 2, shouldRetry: r = () => !0 } = {}
) {
  return new Promise((i, s) => {
    const o = async ({ count: a = 0 } = {}) => {
      const u = async ({ error: l }) => {
        const c = typeof t == "function" ? t({ count: a, error: l }) : t;
        c && (await mf(c)), o({ count: a + 1 });
      };
      try {
        const l = await e();
        i(l);
      } catch (l) {
        if (a < n && (await r({ count: a, error: l }))) return u({ error: l });
        s(l);
      }
    };
    o();
  });
}
const TS = (e) =>
  "code" in e
    ? e.code !== -1 &&
      e.code !== -32004 &&
      e.code !== -32005 &&
      e.code !== -32042 &&
      e.code !== -32603
    : e instanceof Mu && e.status
    ? e.status !== 403 &&
      e.status !== 408 &&
      e.status !== 413 &&
      e.status !== 429 &&
      e.status !== 500 &&
      e.status !== 502 &&
      e.status !== 503 &&
      e.status !== 504
    : !1;
function EO(e, { retryDelay: t = 150, retryCount: n = 3 } = {}) {
  return async (r) =>
    wy(
      async () => {
        try {
          return await e(r);
        } catch (i) {
          const s = i;
          switch (s.code) {
            case lc.code:
              throw new lc(s);
            case dc.code:
              throw new dc(s);
            case fc.code:
              throw new fc(s);
            case hc.code:
              throw new hc(s);
            case ga.code:
              throw new ga(s);
            case eo.code:
              throw new eo(s);
            case pc.code:
              throw new pc(s);
            case va.code:
              throw new va(s);
            case mc.code:
              throw new mc(s);
            case yc.code:
              throw new yc(s);
            case gc.code:
              throw new gc(s);
            case vc.code:
              throw new vc(s);
            case Vn.code:
              throw new Vn(s);
            case bc.code:
              throw new bc(s);
            case wc.code:
              throw new wc(s);
            case Ec.code:
              throw new Ec(s);
            case _c.code:
              throw new _c(s);
            case rs.code:
              throw new rs(s);
            case 5e3:
              throw new Vn(s);
            default:
              throw i instanceof q ? i : new zD(s);
          }
        }
      },
      {
        delay: ({ count: i, error: s }) => {
          var o;
          if (s && s instanceof Mu) {
            const a =
              (o = s == null ? void 0 : s.headers) == null
                ? void 0
                : o.get("Retry-After");
            if (a != null && a.match(/\d/)) return parseInt(a) * 1e3;
          }
          return ~~(1 << i) * t;
        },
        retryCount: n,
        shouldRetry: ({ error: i }) => !TS(i),
      }
    );
}
function Kh(
  {
    key: e,
    name: t,
    request: n,
    retryCount: r = 3,
    retryDelay: i = 150,
    timeout: s,
    type: o,
  },
  a
) {
  return {
    config: {
      key: e,
      name: t,
      request: n,
      retryCount: r,
      retryDelay: i,
      timeout: s,
      type: o,
    },
    request: EO(n, { retryCount: r, retryDelay: i }),
    value: a,
  };
}
function IS(e, t = {}) {
  const { key: n = "custom", name: r = "Custom Provider", retryDelay: i } = t;
  return ({ retryCount: s }) =>
    Kh({
      key: n,
      name: r,
      request: e.request.bind(e),
      retryCount: t.retryCount ?? s,
      retryDelay: i,
      type: "custom",
    });
}
function aE(e, t = {}) {
  const {
    key: n = "fallback",
    name: r = "Fallback",
    rank: i = !1,
    retryCount: s,
    retryDelay: o,
  } = t;
  return ({ chain: a, pollingInterval: u = 4e3, timeout: l }) => {
    let c = e,
      d = () => {};
    const f = Kh(
      {
        key: n,
        name: r,
        async request({ method: p, params: m }) {
          const g = async (w = 0) => {
            const v = c[w]({ chain: a, retryCount: 0, timeout: l });
            try {
              const y = await v.request({ method: p, params: m });
              return (
                d({
                  method: p,
                  params: m,
                  response: y,
                  transport: v,
                  status: "success",
                }),
                y
              );
            } catch (y) {
              if (
                (d({
                  error: y,
                  method: p,
                  params: m,
                  transport: v,
                  status: "error",
                }),
                TS(y) || w === c.length - 1)
              )
                throw y;
              return g(w + 1);
            }
          };
          return g();
        },
        retryCount: s,
        retryDelay: o,
        type: "fallback",
      },
      {
        onResponse: (p) => (d = p),
        transports: c.map((p) => p({ chain: a, retryCount: 0 })),
      }
    );
    if (i) {
      const p = typeof i == "object" ? i : {};
      _O({
        chain: a,
        interval: p.interval ?? u,
        onTransports: (m) => (c = m),
        sampleCount: p.sampleCount,
        timeout: p.timeout,
        transports: c,
        weights: p.weights,
      });
    }
    return f;
  };
}
function _O({
  chain: e,
  interval: t = 4e3,
  onTransports: n,
  sampleCount: r = 10,
  timeout: i = 1e3,
  transports: s,
  weights: o = {},
}) {
  const { stability: a = 0.7, latency: u = 0.3 } = o,
    l = [],
    c = async () => {
      const d = await Promise.all(
        s.map(async (m) => {
          const g = m({ chain: e, retryCount: 0, timeout: i }),
            w = Date.now();
          let v, y;
          try {
            await g.request({ method: "net_listening" }), (y = 1);
          } catch {
            y = 0;
          } finally {
            v = Date.now();
          }
          return { latency: v - w, success: y };
        })
      );
      l.push(d), l.length > r && l.shift();
      const f = Math.max(
          ...l.map((m) => Math.max(...m.map(({ latency: g }) => g)))
        ),
        p = s
          .map((m, g) => {
            const w = l.map((A) => A[g].latency),
              y = 1 - w.reduce((A, x) => A + x, 0) / w.length / f,
              b = l.map((A) => A[g].success),
              _ = b.reduce((A, x) => A + x, 0) / b.length;
            return _ === 0 ? [0, g] : [u * y + a * _, g];
          })
          .sort((m, g) => g[0] - m[0]);
      n(p.map(([, m]) => s[m])), await mf(t), c();
    };
  c();
}
class kS extends q {
  constructor() {
    super(
      "No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.",
      { docsPath: "/docs/clients/intro" }
    );
  }
}
function AO() {
  if (typeof WebSocket < "u") return WebSocket;
  if (typeof global.WebSocket < "u") return global.WebSocket;
  if (typeof window.WebSocket < "u") return window.WebSocket;
  if (typeof self.WebSocket < "u") return self.WebSocket;
  throw new Error("`WebSocket` is not supported in this environment");
}
const uE = AO();
function PS(
  e,
  { errorInstance: t = new Error("timed out"), timeout: n, signal: r }
) {
  return new Promise((i, s) => {
    (async () => {
      let o;
      try {
        const a = new AbortController();
        n > 0 &&
          (o = setTimeout(() => {
            r ? a.abort() : s(t);
          }, n)),
          i(await e({ signal: a == null ? void 0 : a.signal }));
      } catch (a) {
        a.name === "AbortError" && s(t), s(a);
      } finally {
        clearTimeout(o);
      }
    })();
  });
}
let Ey = 0;
async function xO(e, { body: t, fetchOptions: n = {}, timeout: r = 1e4 }) {
  var a;
  const { headers: i, method: s, signal: o } = n;
  try {
    const u = await PS(
      async ({ signal: c }) =>
        await fetch(e, {
          ...n,
          body: Array.isArray(t)
            ? rn(t.map((f) => ({ jsonrpc: "2.0", id: f.id ?? Ey++, ...f })))
            : rn({ jsonrpc: "2.0", id: t.id ?? Ey++, ...t }),
          headers: { ...i, "Content-Type": "application/json" },
          method: s || "POST",
          signal: o || (r > 0 ? c : void 0),
        }),
      { errorInstance: new yy({ body: t, url: e }), timeout: r, signal: !0 }
    );
    let l;
    if (
      ((a = u.headers.get("Content-Type")) != null &&
      a.startsWith("application/json")
        ? (l = await u.json())
        : (l = await u.text()),
      !u.ok)
    )
      throw new Mu({
        body: t,
        details: rn(l.error) || u.statusText,
        headers: u.headers,
        status: u.status,
        url: e,
      });
    return l;
  } catch (u) {
    throw u instanceof Mu || u instanceof yy
      ? u
      : new Mu({ body: t, details: u.message, url: e });
  }
}
const bm = new Map();
async function wm(e) {
  let t = bm.get(e);
  if (t) return t;
  const { schedule: n } = rb({
      id: e,
      fn: async () => {
        const s = new uE(e),
          o = new Map(),
          a = new Map(),
          u = ({ data: c }) => {
            const d = JSON.parse(c),
              f = d.method === "eth_subscription",
              p = f ? d.params.subscription : d.id,
              m = f ? a : o,
              g = m.get(p);
            g && g({ data: c }), f || m.delete(p);
          },
          l = () => {
            bm.delete(e),
              s.removeEventListener("close", l),
              s.removeEventListener("message", u);
          };
        return (
          s.addEventListener("close", l),
          s.addEventListener("message", u),
          s.readyState === uE.CONNECTING &&
            (await new Promise((c, d) => {
              s && ((s.onopen = c), (s.onerror = d));
            })),
          (t = Object.assign(s, { requests: o, subscriptions: a })),
          bm.set(e, t),
          [t]
        );
      },
    }),
    [r, [i]] = await n();
  return i;
}
function SO(e, { body: t, onResponse: n }) {
  if (e.readyState === e.CLOSED || e.readyState === e.CLOSING)
    throw new $D({ body: t, url: e.url, details: "Socket is closed." });
  const r = Ey++,
    i = ({ data: s }) => {
      var a;
      const o = JSON.parse(s);
      (typeof o.id == "number" && r !== o.id) ||
        (n == null || n(o),
        t.method === "eth_subscribe" &&
          typeof o.result == "string" &&
          e.subscriptions.set(o.result, i),
        t.method === "eth_unsubscribe" &&
          e.subscriptions.delete((a = t.params) == null ? void 0 : a[0]));
    };
  return (
    e.requests.set(r, i),
    e.send(JSON.stringify({ jsonrpc: "2.0", ...t, id: r })),
    e
  );
}
async function CO(e, { body: t, timeout: n = 1e4 }) {
  return PS(
    () => new Promise((r) => ra.webSocket(e, { body: t, onResponse: r })),
    { errorInstance: new yy({ body: t, url: e.url }), timeout: n }
  );
}
const ra = { http: xO, webSocket: SO, webSocketAsync: CO };
function TO(e, t = {}) {
  const {
    batch: n,
    fetchOptions: r,
    key: i = "http",
    name: s = "HTTP JSON-RPC",
    retryDelay: o,
  } = t;
  return ({ chain: a, retryCount: u, timeout: l }) => {
    const { batchSize: c = 1e3, wait: d = 0 } = typeof n == "object" ? n : {},
      f = t.retryCount ?? u,
      p = l ?? t.timeout ?? 1e4,
      m = e || (a == null ? void 0 : a.rpcUrls.default.http[0]);
    if (!m) throw new kS();
    return Kh(
      {
        key: i,
        name: s,
        async request({ method: g, params: w }) {
          const v = { method: g, params: w },
            { schedule: y } = rb({
              id: `${e}`,
              wait: d,
              shouldSplitBatch(x) {
                return x.length > c;
              },
              fn: (x) => ra.http(m, { body: x, fetchOptions: r, timeout: p }),
              sort: (x, h) => x.id - h.id,
            }),
            b = async (x) =>
              n
                ? y(x)
                : [await ra.http(m, { body: x, fetchOptions: r, timeout: p })],
            [{ error: _, result: A }] = await b(v);
          if (_) throw new Zv({ body: v, error: _, url: m });
          return A;
        },
        retryCount: f,
        retryDelay: o,
        timeout: p,
        type: "http",
      },
      { fetchOptions: r, url: e }
    );
  };
}
function ob(e, t) {
  var r, i, s;
  if (!(e instanceof q)) return !1;
  const n = e.walk((o) => o instanceof my);
  return n instanceof my
    ? !!(
        ((r = n.data) == null ? void 0 : r.errorName) === "ResolverNotFound" ||
        ((i = n.data) == null ? void 0 : i.errorName) ===
          "ResolverWildcardNotSupported" ||
        ((s = n.reason) != null &&
          s.includes("Wildcard on non-extended resolvers is not supported")) ||
        (t === "reverse" && n.reason === pS[50])
      )
    : !1;
}
function DS(e) {
  if (e.length !== 66 || e.indexOf("[") !== 0 || e.indexOf("]") !== 65)
    return null;
  const t = `0x${e.slice(1, 65)}`;
  return Dr(t) ? t : null;
}
function bd(e) {
  let t = new Uint8Array(32).fill(0);
  if (!e) return uc(t);
  const n = e.split(".");
  for (let r = n.length - 1; r >= 0; r -= 1) {
    const i = DS(n[r]),
      s = i ? ts(i) : tn(ii(n[r]), "bytes");
    t = tn(di([t, s]), "bytes");
  }
  return uc(t);
}
function IO(e) {
  return `[${e.slice(2)}]`;
}
function kO(e) {
  const t = new Uint8Array(32).fill(0);
  return e ? DS(e) || tn(ii(e)) : uc(t);
}
function Zh(e) {
  const t = e.replace(/^\.|\.$/gm, "");
  if (t.length === 0) return new Uint8Array(1);
  const n = new Uint8Array(ii(t).byteLength + 2);
  let r = 0;
  const i = t.split(".");
  for (let s = 0; s < i.length; s++) {
    let o = ii(i[s]);
    o.byteLength > 255 && (o = ii(IO(kO(i[s])))),
      (n[r] = o.length),
      n.set(o, r + 1),
      (r += o.length + 1);
  }
  return n.byteLength !== r + 1 ? n.slice(0, r + 1) : n;
}
async function PO(
  e,
  {
    blockNumber: t,
    blockTag: n,
    coinType: r,
    name: i,
    universalResolverAddress: s,
  }
) {
  let o = s;
  if (!o) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    o = Ha({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  try {
    const a = ms({
        abi: sE,
        functionName: "addr",
        ...(r != null ? { args: [bd(i), BigInt(r)] } : { args: [bd(i)] }),
      }),
      u = await se(
        e,
        ss,
        "readContract"
      )({
        address: o,
        abi: xS,
        functionName: "resolve",
        args: [gi(Zh(i)), a],
        blockNumber: t,
        blockTag: n,
      });
    if (u[0] === "0x") return null;
    const l = $a({
      abi: sE,
      args: r != null ? [bd(i), BigInt(r)] : void 0,
      functionName: "addr",
      data: u[0],
    });
    return l === "0x" || Hs(l) === "0x00" ? null : l;
  } catch (a) {
    if (ob(a, "resolve")) return null;
    throw a;
  }
}
class DO extends q {
  constructor({ data: t }) {
    super(
      "Unable to extract image from metadata. The metadata may be malformed or invalid.",
      {
        metaMessages: [
          "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
          "",
          `Provided data: ${JSON.stringify(t)}`,
        ],
      }
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "EnsAvatarInvalidMetadataError",
      });
  }
}
class su extends q {
  constructor({ reason: t }) {
    super(`ENS NFT avatar URI is invalid. ${t}`),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "EnsAvatarInvalidNftUriError",
      });
  }
}
class ab extends q {
  constructor({ uri: t }) {
    super(
      `Unable to resolve ENS avatar URI "${t}". The URI may be malformed, invalid, or does not respond with a valid image.`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "EnsAvatarUriResolutionError",
      });
  }
}
class OO extends q {
  constructor({ namespace: t }) {
    super(
      `ENS NFT avatar namespace "${t}" is not supported. Must be "erc721" or "erc1155".`
    ),
      Object.defineProperty(this, "name", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: "EnsAvatarUnsupportedNamespaceError",
      });
  }
}
const RO =
    /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/,
  BO =
    /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/,
  NO = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/,
  MO = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function LO(e) {
  try {
    const t = await fetch(e, { method: "HEAD" });
    if (t.status === 200) {
      const n = t.headers.get("content-type");
      return n == null ? void 0 : n.startsWith("image/");
    }
    return !1;
  } catch (t) {
    return (typeof t == "object" && typeof t.response < "u") ||
      !globalThis.hasOwnProperty("Image")
      ? !1
      : new Promise((n) => {
          const r = new Image();
          (r.onload = () => {
            n(!0);
          }),
            (r.onerror = () => {
              n(!1);
            }),
            (r.src = e);
        });
  }
}
function cE(e, t) {
  return e ? (e.endsWith("/") ? e.slice(0, -1) : e) : t;
}
function OS({ uri: e, gatewayUrls: t }) {
  const n = NO.test(e);
  if (n) return { uri: e, isOnChain: !0, isEncoded: n };
  const r = cE(t == null ? void 0 : t.ipfs, "https://ipfs.io"),
    i = cE(t == null ? void 0 : t.arweave, "https://arweave.net"),
    s = e.match(RO),
    {
      protocol: o,
      subpath: a,
      target: u,
      subtarget: l = "",
    } = (s == null ? void 0 : s.groups) || {},
    c = o === "ipns:/" || a === "ipns/",
    d = o === "ipfs:/" || a === "ipfs/" || BO.test(e);
  if (e.startsWith("http") && !c && !d) {
    let p = e;
    return (
      t != null &&
        t.arweave &&
        (p = e.replace(
          /https:\/\/arweave.net/g,
          t == null ? void 0 : t.arweave
        )),
      { uri: p, isOnChain: !1, isEncoded: !1 }
    );
  }
  if ((c || d) && u)
    return {
      uri: `${r}/${c ? "ipns" : "ipfs"}/${u}${l}`,
      isOnChain: !1,
      isEncoded: !1,
    };
  if (o === "ar:/" && u)
    return { uri: `${i}/${u}${l || ""}`, isOnChain: !1, isEncoded: !1 };
  let f = e.replace(MO, "");
  if (
    (f.startsWith("<svg") && (f = `data:image/svg+xml;base64,${btoa(f)}`),
    f.startsWith("data:") || f.startsWith("{"))
  )
    return { uri: f, isOnChain: !0, isEncoded: !1 };
  throw new ab({ uri: e });
}
function RS(e) {
  if (
    typeof e != "object" ||
    (!("image" in e) && !("image_url" in e) && !("image_data" in e))
  )
    throw new DO({ data: e });
  return e.image || e.image_url || e.image_data;
}
async function FO({ gatewayUrls: e, uri: t }) {
  try {
    const n = await fetch(t).then((i) => i.json());
    return await ub({ gatewayUrls: e, uri: RS(n) });
  } catch {
    throw new ab({ uri: t });
  }
}
async function ub({ gatewayUrls: e, uri: t }) {
  const { uri: n, isOnChain: r } = OS({ uri: t, gatewayUrls: e });
  if (r || (await LO(n))) return n;
  throw new ab({ uri: t });
}
function jO(e) {
  let t = e;
  t.startsWith("did:nft:") &&
    (t = t.replace("did:nft:", "").replace(/_/g, "/"));
  const [n, r, i] = t.split("/"),
    [s, o] = n.split(":"),
    [a, u] = r.split(":");
  if (!s || s.toLowerCase() !== "eip155")
    throw new su({ reason: "Only EIP-155 supported" });
  if (!o) throw new su({ reason: "Chain ID not found" });
  if (!u) throw new su({ reason: "Contract address not found" });
  if (!i) throw new su({ reason: "Token ID not found" });
  if (!a) throw new su({ reason: "ERC namespace not found" });
  return {
    chainID: parseInt(o),
    namespace: a.toLowerCase(),
    contractAddress: u,
    tokenID: i,
  };
}
async function UO(e, { nft: t }) {
  if (t.namespace === "erc721")
    return ss(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "tokenURI",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "tokenId", type: "uint256" }],
          outputs: [{ name: "", type: "string" }],
        },
      ],
      functionName: "tokenURI",
      args: [BigInt(t.tokenID)],
    });
  if (t.namespace === "erc1155")
    return ss(e, {
      address: t.contractAddress,
      abi: [
        {
          name: "uri",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "_id", type: "uint256" }],
          outputs: [{ name: "", type: "string" }],
        },
      ],
      functionName: "uri",
      args: [BigInt(t.tokenID)],
    });
  throw new OO({ namespace: t.namespace });
}
async function $O(e, { gatewayUrls: t, record: n }) {
  return /eip155:/i.test(n)
    ? HO(e, { gatewayUrls: t, record: n })
    : ub({ uri: n, gatewayUrls: t });
}
async function HO(e, { gatewayUrls: t, record: n }) {
  const r = jO(n),
    i = await UO(e, { nft: r }),
    { uri: s, isOnChain: o, isEncoded: a } = OS({ uri: i, gatewayUrls: t });
  if (o && (s.includes("data:application/json;base64,") || s.startsWith("{"))) {
    const l = a ? atob(s.replace("data:application/json;base64,", "")) : s,
      c = JSON.parse(l);
    return ub({ uri: RS(c), gatewayUrls: t });
  }
  let u = r.tokenID;
  return (
    r.namespace === "erc1155" && (u = u.replace("0x", "").padStart(64, "0")),
    FO({ gatewayUrls: t, uri: s.replace(/(?:0x)?{id}/, u) })
  );
}
async function BS(
  e,
  { blockNumber: t, blockTag: n, name: r, key: i, universalResolverAddress: s }
) {
  let o = s;
  if (!o) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    o = Ha({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  try {
    const a = await se(
      e,
      ss,
      "readContract"
    )({
      address: o,
      abi: xS,
      functionName: "resolve",
      args: [
        gi(Zh(r)),
        ms({ abi: iE, functionName: "text", args: [bd(r), i] }),
      ],
      blockNumber: t,
      blockTag: n,
    });
    if (a[0] === "0x") return null;
    const u = $a({ abi: iE, functionName: "text", data: a[0] });
    return u === "" ? null : u;
  } catch (a) {
    if (ob(a, "resolve")) return null;
    throw a;
  }
}
async function zO(
  e,
  {
    blockNumber: t,
    blockTag: n,
    gatewayUrls: r,
    name: i,
    universalResolverAddress: s,
  }
) {
  const o = await se(
    e,
    BS,
    "getEnsText"
  )({
    blockNumber: t,
    blockTag: n,
    key: "avatar",
    name: i,
    universalResolverAddress: s,
  });
  if (!o) return null;
  try {
    return await $O(e, { record: o, gatewayUrls: r });
  } catch {
    return null;
  }
}
async function GO(
  e,
  { address: t, blockNumber: n, blockTag: r, universalResolverAddress: i }
) {
  let s = i;
  if (!s) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    s = Ha({
      blockNumber: n,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  const o = `${t.toLowerCase().substring(2)}.addr.reverse`;
  try {
    const [a, u] = await se(
      e,
      ss,
      "readContract"
    )({
      address: s,
      abi: nO,
      functionName: "reverse",
      args: [gi(Zh(o))],
      blockNumber: n,
      blockTag: r,
    });
    return t.toLowerCase() !== u.toLowerCase() ? null : a;
  } catch (a) {
    if (ob(a, "reverse")) return null;
    throw a;
  }
}
async function qO(
  e,
  { blockNumber: t, blockTag: n, name: r, universalResolverAddress: i }
) {
  let s = i;
  if (!s) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. universalResolverAddress is required."
      );
    s = Ha({
      blockNumber: t,
      chain: e.chain,
      contract: "ensUniversalResolver",
    });
  }
  const [o] = await se(
    e,
    ss,
    "readContract"
  )({
    address: s,
    abi: [
      {
        inputs: [{ type: "bytes" }],
        name: "findResolver",
        outputs: [{ type: "address" }, { type: "bytes32" }],
        stateMutability: "view",
        type: "function",
      },
    ],
    functionName: "findResolver",
    args: [gi(Zh(r))],
    blockNumber: t,
    blockTag: n,
  });
  return o;
}
async function WO(e) {
  const t = Hh(e, { method: "eth_newBlockFilter" }),
    n = await e.request({ method: "eth_newBlockFilter" });
  return { id: n, request: t(n), type: "block" };
}
async function NS(
  e,
  {
    address: t,
    args: n,
    event: r,
    events: i,
    fromBlock: s,
    strict: o,
    toBlock: a,
  } = {}
) {
  const u = i ?? (r ? [r] : void 0),
    l = Hh(e, { method: "eth_newFilter" });
  let c = [];
  u &&
    ((c = [u.flatMap((f) => al({ abi: [f], eventName: f.name, args: n }))]),
    r && (c = c[0]));
  const d = await e.request({
    method: "eth_newFilter",
    params: [
      {
        address: t,
        fromBlock: typeof s == "bigint" ? he(s) : s,
        toBlock: typeof a == "bigint" ? he(a) : a,
        ...(c.length ? { topics: c } : {}),
      },
    ],
  });
  return {
    abi: u,
    args: n,
    eventName: r ? r.name : void 0,
    fromBlock: s,
    id: d,
    request: l(d),
    strict: o,
    toBlock: a,
    type: "event",
  };
}
async function MS(e) {
  const t = Hh(e, { method: "eth_newPendingTransactionFilter" }),
    n = await e.request({ method: "eth_newPendingTransactionFilter" });
  return { id: n, request: t(n), type: "transaction" };
}
async function QO(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const i = n ? he(n) : void 0,
    s = await e.request({ method: "eth_getBalance", params: [t, i || r] });
  return BigInt(s);
}
async function VO(
  e,
  { blockHash: t, blockNumber: n, blockTag: r = "latest" } = {}
) {
  const i = n !== void 0 ? he(n) : void 0;
  let s;
  return (
    t
      ? (s = await e.request({
          method: "eth_getBlockTransactionCountByHash",
          params: [t],
        }))
      : (s = await e.request({
          method: "eth_getBlockTransactionCountByNumber",
          params: [i || r],
        })),
    Jt(s)
  );
}
async function KO(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const i = n !== void 0 ? he(n) : void 0,
    s = await e.request({ method: "eth_getCode", params: [t, i || r] });
  if (s !== "0x") return s;
}
function ZO(e) {
  var t;
  return {
    baseFeePerGas: e.baseFeePerGas.map((n) => BigInt(n)),
    gasUsedRatio: e.gasUsedRatio,
    oldestBlock: BigInt(e.oldestBlock),
    reward:
      (t = e.reward) == null ? void 0 : t.map((n) => n.map((r) => BigInt(r))),
  };
}
async function JO(
  e,
  {
    blockCount: t,
    blockNumber: n,
    blockTag: r = "latest",
    rewardPercentiles: i,
  }
) {
  const s = n ? he(n) : void 0,
    o = await e.request({
      method: "eth_feeHistory",
      params: [he(t), s || r, i],
    });
  return ZO(o);
}
async function YO(e, { filter: t }) {
  const n = t.strict ?? !1;
  return (await t.request({ method: "eth_getFilterLogs", params: [t.id] }))
    .map((i) => {
      var s;
      try {
        const { eventName: o, args: a } =
          "abi" in t && t.abi
            ? ll({ abi: t.abi, data: i.data, topics: i.topics, strict: n })
            : { eventName: void 0, args: void 0 };
        return pr(i, { args: a, eventName: o });
      } catch (o) {
        let a, u;
        if (o instanceof Xs || o instanceof Fa) {
          if ("strict" in t && t.strict) return;
          (a = o.abiItem.name),
            (u =
              (s = o.abiItem.inputs) == null
                ? void 0
                : s.some((l) => !("name" in l && l.name)));
        }
        return pr(i, { args: u ? [] : {}, eventName: a });
      }
    })
    .filter(Boolean);
}
const XO = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  eR =
    /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
function tR({ domain: e, message: t, primaryType: n, types: r }) {
  const i = typeof e > "u" ? {} : e,
    s = { EIP712Domain: HS({ domain: i }), ...r };
  $S({ domain: i, message: t, primaryType: n, types: s });
  const o = ["0x1901"];
  return (
    i && o.push(nR({ domain: i, types: s })),
    n !== "EIP712Domain" && o.push(LS({ data: t, primaryType: n, types: s })),
    tn(di(o))
  );
}
function nR({ domain: e, types: t }) {
  return LS({ data: e, primaryType: "EIP712Domain", types: t });
}
function LS({ data: e, primaryType: t, types: n }) {
  const r = FS({ data: e, primaryType: t, types: n });
  return tn(r);
}
function FS({ data: e, primaryType: t, types: n }) {
  const r = [{ type: "bytes32" }],
    i = [rR({ primaryType: t, types: n })];
  for (const s of n[t]) {
    const [o, a] = US({
      types: n,
      name: s.name,
      type: s.type,
      value: e[s.name],
    });
    r.push(o), i.push(a);
  }
  return sl(r, i);
}
function rR({ primaryType: e, types: t }) {
  const n = gi(iR({ primaryType: e, types: t }));
  return tn(n);
}
function iR({ primaryType: e, types: t }) {
  let n = "";
  const r = jS({ primaryType: e, types: t });
  r.delete(e);
  const i = [e, ...Array.from(r).sort()];
  for (const s of i)
    n += `${s}(${t[s].map(({ name: o, type: a }) => `${a} ${o}`).join(",")})`;
  return n;
}
function jS({ primaryType: e, types: t }, n = new Set()) {
  const r = e.match(/^\w*/u),
    i = r == null ? void 0 : r[0];
  if (n.has(i) || t[i] === void 0) return n;
  n.add(i);
  for (const s of t[i]) jS({ primaryType: s.type, types: t }, n);
  return n;
}
function US({ types: e, name: t, type: n, value: r }) {
  if (e[n] !== void 0)
    return [{ type: "bytes32" }, tn(FS({ data: r, primaryType: n, types: e }))];
  if (n === "bytes")
    return (
      (r = `0x${(r.length % 2 ? "0" : "") + r.slice(2)}`),
      [{ type: "bytes32" }, tn(r)]
    );
  if (n === "string") return [{ type: "bytes32" }, tn(gi(r))];
  if (n.lastIndexOf("]") === n.length - 1) {
    const i = n.slice(0, n.lastIndexOf("[")),
      s = r.map((o) => US({ name: t, type: i, types: e, value: o }));
    return [
      { type: "bytes32" },
      tn(
        sl(
          s.map(([o]) => o),
          s.map(([, o]) => o)
        )
      ),
    ];
  }
  return [{ type: n }, r];
}
function $S({ domain: e, message: t, primaryType: n, types: r }) {
  const i = r,
    s = (o, a) => {
      for (const u of o) {
        const { name: l, type: c } = u,
          d = c,
          f = a[l],
          p = d.match(eR);
        if (p && (typeof f == "number" || typeof f == "bigint")) {
          const [w, v, y] = p;
          he(f, { signed: v === "int", size: parseInt(y) / 8 });
        }
        if (d === "address" && typeof f == "string" && !ns(f))
          throw new cc({ address: f });
        const m = d.match(XO);
        if (m) {
          const [w, v] = m;
          if (v && pt(f) !== parseInt(v))
            throw new N5({ expectedSize: parseInt(v), givenSize: pt(f) });
        }
        const g = i[d];
        g && s(g, f);
      }
    };
  if ((i.EIP712Domain && e && s(i.EIP712Domain, e), n !== "EIP712Domain")) {
    const o = i[n];
    s(o, t);
  }
}
function HS({ domain: e }) {
  return [
    typeof (e == null ? void 0 : e.name) == "string" && {
      name: "name",
      type: "string",
    },
    (e == null ? void 0 : e.version) && { name: "version", type: "string" },
    typeof (e == null ? void 0 : e.chainId) == "number" && {
      name: "chainId",
      type: "uint256",
    },
    (e == null ? void 0 : e.verifyingContract) && {
      name: "verifyingContract",
      type: "address",
    },
    (e == null ? void 0 : e.salt) && { name: "salt", type: "bytes32" },
  ].filter(Boolean);
}
const Em = "/docs/contract/encodeDeployData";
function zS({ abi: e, args: t, bytecode: n }) {
  if (!t || t.length === 0) return n;
  const r = e.find((s) => "type" in s && s.type === "constructor");
  if (!r) throw new T5({ docsPath: Em });
  if (!("inputs" in r)) throw new V1({ docsPath: Em });
  if (!r.inputs || r.inputs.length === 0) throw new V1({ docsPath: Em });
  const i = sl(r.inputs, t);
  return Uv([n, i]);
}
const sR = `Ethereum Signed Message:
`;
function oR(e, t) {
  const n =
      typeof e == "string"
        ? ii(e)
        : e.raw instanceof Uint8Array
        ? e.raw
        : ts(e.raw),
    r = ii(`${sR}${n.length}`);
  return tn(di([r, n]), t);
}
function aR(e) {
  return e.map((t) => ({ ...t, value: BigInt(t.value) }));
}
function uR(e) {
  return {
    ...e,
    balance: e.balance ? BigInt(e.balance) : void 0,
    nonce: e.nonce ? Jt(e.nonce) : void 0,
    storageProof: e.storageProof ? aR(e.storageProof) : void 0,
  };
}
async function cR(
  e,
  { address: t, blockNumber: n, blockTag: r, storageKeys: i }
) {
  const s = r ?? "latest",
    o = n !== void 0 ? he(n) : void 0,
    a = await e.request({ method: "eth_getProof", params: [t, i, o || s] });
  return uR(a);
}
async function lR(
  e,
  { address: t, blockNumber: n, blockTag: r = "latest", slot: i }
) {
  const s = n !== void 0 ? he(n) : void 0;
  return await e.request({
    method: "eth_getStorageAt",
    params: [t, i, s || r],
  });
}
async function cb(
  e,
  { blockHash: t, blockNumber: n, blockTag: r, hash: i, index: s }
) {
  var c, d, f;
  const o = r || "latest",
    a = n !== void 0 ? he(n) : void 0;
  let u = null;
  if (
    (i
      ? (u = await e.request({
          method: "eth_getTransactionByHash",
          params: [i],
        }))
      : t
      ? (u = await e.request({
          method: "eth_getTransactionByBlockHashAndIndex",
          params: [t, he(s)],
        }))
      : (a || o) &&
        (u = await e.request({
          method: "eth_getTransactionByBlockNumberAndIndex",
          params: [a || o, he(s)],
        })),
    !u)
  )
    throw new yS({
      blockHash: t,
      blockNumber: n,
      blockTag: o,
      hash: i,
      index: s,
    });
  return (
    ((f =
      (d = (c = e.chain) == null ? void 0 : c.formatters) == null
        ? void 0
        : d.transaction) == null
      ? void 0
      : f.format) || Xx
  )(u);
}
async function dR(e, { hash: t, transactionReceipt: n }) {
  const [r, i] = await Promise.all([
      se(e, fl, "getBlockNumber")({}),
      t ? se(e, cb, "getBlockNumber")({ hash: t }) : void 0,
    ]),
    s =
      (n == null ? void 0 : n.blockNumber) ||
      (i == null ? void 0 : i.blockNumber);
  return s ? r - s + 1n : 0n;
}
async function _y(e, { hash: t }) {
  var i, s, o;
  const n = await e.request({
    method: "eth_getTransactionReceipt",
    params: [t],
  });
  if (!n) throw new gS({ hash: t });
  return (
    ((o =
      (s = (i = e.chain) == null ? void 0 : i.formatters) == null
        ? void 0
        : s.transactionReceipt) == null
      ? void 0
      : o.format) || m5
  )(n);
}
async function fR(e, t) {
  var g;
  const {
      allowFailure: n = !0,
      batchSize: r,
      blockNumber: i,
      blockTag: s,
      contracts: o,
      multicallAddress: a,
    } = t,
    u =
      r ??
      ((typeof ((g = e.batch) == null ? void 0 : g.multicall) == "object" &&
        e.batch.multicall.batchSize) ||
        1024);
  let l = a;
  if (!l) {
    if (!e.chain)
      throw new Error(
        "client chain not configured. multicallAddress is required."
      );
    l = Ha({ blockNumber: i, chain: e.chain, contract: "multicall3" });
  }
  const c = [[]];
  let d = 0,
    f = 0;
  for (let w = 0; w < o.length; w++) {
    const { abi: v, address: y, args: b, functionName: _ } = o[w];
    try {
      const A = ms({ abi: v, args: b, functionName: _ });
      (f += (A.length - 2) / 2),
        u > 0 &&
          f > u &&
          c[d].length > 0 &&
          (d++, (f = (A.length - 2) / 2), (c[d] = [])),
        (c[d] = [...c[d], { allowFailure: !0, callData: A, target: y }]);
    } catch (A) {
      const x = Ac(A, {
        abi: v,
        address: y,
        args: b,
        docsPath: "/docs/contract/multicall",
        functionName: _,
      });
      if (!n) throw x;
      c[d] = [...c[d], { allowFailure: !0, callData: "0x", target: y }];
    }
  }
  const p = await Promise.allSettled(
      c.map((w) =>
        se(
          e,
          ss,
          "readContract"
        )({
          abi: vy,
          address: l,
          args: [w],
          blockNumber: i,
          blockTag: s,
          functionName: "aggregate3",
        })
      )
    ),
    m = [];
  for (let w = 0; w < p.length; w++) {
    const v = p[w];
    if (v.status === "rejected") {
      if (!n) throw v.reason;
      for (let b = 0; b < c[w].length; b++)
        m.push({ status: "failure", error: v.reason, result: void 0 });
      continue;
    }
    const y = v.value;
    for (let b = 0; b < y.length; b++) {
      const { returnData: _, success: A } = y[b],
        { callData: x } = c[w][b],
        { abi: h, address: E, functionName: I, args: C } = o[m.length];
      try {
        if (x === "0x") throw new Uh();
        if (!A) throw new Kv({ data: _ });
        const k = $a({ abi: h, args: C, data: _, functionName: I });
        m.push(n ? { result: k, status: "success" } : k);
      } catch (k) {
        const O = Ac(k, {
          abi: h,
          address: E,
          args: C,
          docsPath: "/docs/contract/multicall",
          functionName: I,
        });
        if (!n) throw O;
        m.push({ error: O, result: void 0, status: "failure" });
      }
    }
  }
  if (m.length !== o.length) throw new q("multicall results mismatch");
  return m;
}
const hR =
  "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ BigInt(
  0
);
BigInt(1);
BigInt(2);
function pR(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function mR(e, t) {
  const n = Dr(e) ? ts(e) : e,
    r = Dr(t) ? ts(t) : t;
  return pR(n, r);
}
async function GS(e, { address: t, hash: n, signature: r, ...i }) {
  const s = Dr(r) ? r : gi(r);
  try {
    const { data: o } = await se(
      e,
      Wh,
      "call"
    )({ data: zS({ abi: rO, args: [t, n, s], bytecode: hR }), ...i });
    return mR(o ?? "0x0", "0x1");
  } catch (o) {
    if (o instanceof vS) return !1;
    throw o;
  }
}
async function yR(e, { address: t, message: n, signature: r, ...i }) {
  const s = oR(n);
  return GS(e, { address: t, hash: s, signature: r, ...i });
}
async function gR(
  e,
  {
    address: t,
    signature: n,
    message: r,
    primaryType: i,
    types: s,
    domain: o,
    ...a
  }
) {
  const u = tR({ message: r, primaryType: i, types: s, domain: o });
  return GS(e, { address: t, hash: u, signature: n, ...a });
}
function qS(
  e,
  {
    emitOnBegin: t = !1,
    emitMissed: n = !1,
    onBlockNumber: r,
    onError: i,
    poll: s,
    pollingInterval: o = e.pollingInterval,
  }
) {
  const a = typeof s < "u" ? s : e.transport.type !== "webSocket";
  let u;
  return a
    ? (() => {
        const d = rn(["watchBlockNumber", e.uid, t, n, o]);
        return za(d, { onBlockNumber: r, onError: i }, (f) =>
          dl(
            async () => {
              var p;
              try {
                const m = await se(e, fl, "getBlockNumber")({ cacheTime: 0 });
                if (u) {
                  if (m === u) return;
                  if (m - u > 1 && n)
                    for (let g = u + 1n; g < m; g++)
                      f.onBlockNumber(g, u), (u = g);
                }
                (!u || m > u) && (f.onBlockNumber(m, u), (u = m));
              } catch (m) {
                (p = f.onError) == null || p.call(f, m);
              }
            },
            { emitOnBegin: t, interval: o }
          )
        );
      })()
    : (() => {
        let d = !0,
          f = () => (d = !1);
        return (
          (async () => {
            try {
              const { unsubscribe: p } = await e.transport.subscribe({
                params: ["newHeads"],
                onData(m) {
                  var w;
                  if (!d) return;
                  const g = Mh((w = m.result) == null ? void 0 : w.number);
                  r(g, u), (u = g);
                },
                onError(m) {
                  i == null || i(m);
                },
              });
              (f = p), d || f();
            } catch (p) {
              i == null || i(p);
            }
          })(),
          f
        );
      })();
}
async function vR(
  e,
  {
    confirmations: t = 1,
    hash: n,
    onReplaced: r,
    pollingInterval: i = e.pollingInterval,
    timeout: s,
  }
) {
  const o = rn(["waitForTransactionReceipt", e.uid, n]);
  let a,
    u,
    l,
    c = !1;
  return new Promise((d, f) => {
    s && setTimeout(() => f(new jD({ hash: n })), s);
    const p = za(o, { onReplaced: r, resolve: d, reject: f }, (m) => {
      const g = se(
        e,
        qS,
        "watchBlockNumber"
      )({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: i,
        async onBlockNumber(w) {
          if (c) return;
          let v = w;
          const y = (b) => {
            g(), b(), p();
          };
          try {
            if (l) {
              if (t > 1 && (!l.blockNumber || v - l.blockNumber + 1n < t))
                return;
              y(() => m.resolve(l));
              return;
            }
            if (
              (a ||
                ((c = !0),
                await wy(
                  async () => {
                    (a = await se(e, cb, "getTransaction")({ hash: n })),
                      a.blockNumber && (v = a.blockNumber);
                  },
                  { delay: ({ count: b }) => ~~(1 << b) * 200, retryCount: 6 }
                ),
                (c = !1)),
              (l = await se(e, _y, "getTransactionReceipt")({ hash: n })),
              t > 1 && (!l.blockNumber || v - l.blockNumber + 1n < t))
            )
              return;
            y(() => m.resolve(l));
          } catch (b) {
            if (a && (b instanceof yS || b instanceof gS))
              try {
                (u = a), (c = !0);
                const _ = await wy(
                  () =>
                    se(
                      e,
                      is,
                      "getBlock"
                    )({ blockNumber: v, includeTransactions: !0 }),
                  {
                    delay: ({ count: h }) => ~~(1 << h) * 200,
                    retryCount: 6,
                    shouldRetry: ({ error: h }) => h instanceof bS,
                  }
                );
                c = !1;
                const A = _.transactions.find(
                  ({ from: h, nonce: E }) => h === u.from && E === u.nonce
                );
                if (
                  !A ||
                  ((l = await se(
                    e,
                    _y,
                    "getTransactionReceipt"
                  )({ hash: A.hash })),
                  t > 1 && (!l.blockNumber || v - l.blockNumber + 1n < t))
                )
                  return;
                let x = "replaced";
                A.to === u.to && A.value === u.value
                  ? (x = "repriced")
                  : A.from === A.to && A.value === 0n && (x = "cancelled"),
                  y(() => {
                    var h;
                    (h = m.onReplaced) == null ||
                      h.call(m, {
                        reason: x,
                        replacedTransaction: u,
                        transaction: A,
                        transactionReceipt: l,
                      }),
                      m.resolve(l);
                  });
              } catch (_) {
                y(() => m.reject(_));
              }
            else y(() => m.reject(b));
          }
        },
      });
    });
  });
}
function bR(
  e,
  {
    blockTag: t = "latest",
    emitMissed: n = !1,
    emitOnBegin: r = !1,
    onBlock: i,
    onError: s,
    includeTransactions: o,
    poll: a,
    pollingInterval: u = e.pollingInterval,
  }
) {
  const l = typeof a < "u" ? a : e.transport.type !== "webSocket",
    c = o ?? !1;
  let d;
  return l
    ? (() => {
        const m = rn(["watchBlocks", e.uid, n, r, c, u]);
        return za(m, { onBlock: i, onError: s }, (g) =>
          dl(
            async () => {
              var w;
              try {
                const v = await se(
                  e,
                  is,
                  "getBlock"
                )({ blockTag: t, includeTransactions: c });
                if (v.number && d != null && d.number) {
                  if (v.number === d.number) return;
                  if (v.number - d.number > 1 && n)
                    for (
                      let y = (d == null ? void 0 : d.number) + 1n;
                      y < v.number;
                      y++
                    ) {
                      const b = await se(
                        e,
                        is,
                        "getBlock"
                      )({ blockNumber: y, includeTransactions: c });
                      g.onBlock(b, d), (d = b);
                    }
                }
                (!(d != null && d.number) ||
                  (t === "pending" && !(v != null && v.number)) ||
                  (v.number && v.number > d.number)) &&
                  (g.onBlock(v, d), (d = v));
              } catch (v) {
                (w = g.onError) == null || w.call(g, v);
              }
            },
            { emitOnBegin: r, interval: u }
          )
        );
      })()
    : (() => {
        let m = !0,
          g = () => (m = !1);
        return (
          (async () => {
            try {
              const { unsubscribe: w } = await e.transport.subscribe({
                params: ["newHeads"],
                onData(v) {
                  var _, A, x;
                  if (!m) return;
                  const b = (
                    ((x =
                      (A = (_ = e.chain) == null ? void 0 : _.formatters) ==
                      null
                        ? void 0
                        : A.block) == null
                      ? void 0
                      : x.format) || eS
                  )(v.result);
                  i(b, d), (d = b);
                },
                onError(v) {
                  s == null || s(v);
                },
              });
              (g = w), m || g();
            } catch (w) {
              s == null || s(w);
            }
          })(),
          g
        );
      })();
}
function wR(
  e,
  {
    address: t,
    args: n,
    batch: r = !0,
    event: i,
    events: s,
    onError: o,
    onLogs: a,
    poll: u,
    pollingInterval: l = e.pollingInterval,
    strict: c,
  }
) {
  const d = typeof u < "u" ? u : e.transport.type !== "webSocket",
    f = c ?? !1;
  return d
    ? (() => {
        const g = rn(["watchEvent", t, n, r, e.uid, i, l]);
        return za(g, { onLogs: a, onError: o }, (w) => {
          let v,
            y,
            b = !1;
          const _ = dl(
            async () => {
              var A;
              if (!b) {
                try {
                  y = await se(
                    e,
                    NS,
                    "createEventFilter"
                  )({ address: t, args: n, event: i, events: s, strict: f });
                } catch {}
                b = !0;
                return;
              }
              try {
                let x;
                if (y) x = await se(e, Qh, "getFilterChanges")({ filter: y });
                else {
                  const h = await se(e, fl, "getBlockNumber")({});
                  v && v !== h
                    ? (x = await se(
                        e,
                        nb,
                        "getLogs"
                      )({
                        address: t,
                        args: n,
                        event: i,
                        events: s,
                        fromBlock: v + 1n,
                        toBlock: h,
                      }))
                    : (x = []),
                    (v = h);
                }
                if (x.length === 0) return;
                if (r) w.onLogs(x);
                else for (const h of x) w.onLogs([h]);
              } catch (x) {
                y && x instanceof eo && (b = !1),
                  (A = w.onError) == null || A.call(w, x);
              }
            },
            { emitOnBegin: !0, interval: l }
          );
          return async () => {
            y && (await se(e, Vh, "uninstallFilter")({ filter: y })), _();
          };
        });
      })()
    : (() => {
        let g = !0,
          w = () => (g = !1);
        return (
          (async () => {
            try {
              const v = s ?? (i ? [i] : void 0);
              let y = [];
              v &&
                ((y = [
                  v.flatMap((_) =>
                    al({ abi: [_], eventName: _.name, args: n })
                  ),
                ]),
                i && (y = y[0]));
              const { unsubscribe: b } = await e.transport.subscribe({
                params: ["logs", { address: t, topics: y }],
                onData(_) {
                  var x;
                  if (!g) return;
                  const A = _.result;
                  try {
                    const { eventName: h, args: E } = ll({
                        abi: v,
                        data: A.data,
                        topics: A.topics,
                        strict: f,
                      }),
                      I = pr(A, { args: E, eventName: h });
                    a([I]);
                  } catch (h) {
                    let E, I;
                    if (h instanceof Xs || h instanceof Fa) {
                      if (c) return;
                      (E = h.abiItem.name),
                        (I =
                          (x = h.abiItem.inputs) == null
                            ? void 0
                            : x.some((k) => !("name" in k && k.name)));
                    }
                    const C = pr(A, { args: I ? [] : {}, eventName: E });
                    a([C]);
                  }
                },
                onError(_) {
                  o == null || o(_);
                },
              });
              (w = b), g || w();
            } catch (v) {
              o == null || o(v);
            }
          })(),
          w
        );
      })();
}
function ER(
  e,
  {
    batch: t = !0,
    onError: n,
    onTransactions: r,
    poll: i,
    pollingInterval: s = e.pollingInterval,
  }
) {
  return (typeof i < "u" ? i : e.transport.type !== "webSocket")
    ? (() => {
        const l = rn(["watchPendingTransactions", e.uid, t, s]);
        return za(l, { onTransactions: r, onError: n }, (c) => {
          let d;
          const f = dl(
            async () => {
              var p;
              try {
                if (!d)
                  try {
                    d = await se(e, MS, "createPendingTransactionFilter")({});
                    return;
                  } catch (g) {
                    throw (f(), g);
                  }
                const m = await se(e, Qh, "getFilterChanges")({ filter: d });
                if (m.length === 0) return;
                if (t) c.onTransactions(m);
                else for (const g of m) c.onTransactions([g]);
              } catch (m) {
                (p = c.onError) == null || p.call(c, m);
              }
            },
            { emitOnBegin: !0, interval: s }
          );
          return async () => {
            d && (await se(e, Vh, "uninstallFilter")({ filter: d })), f();
          };
        });
      })()
    : (() => {
        let l = !0,
          c = () => (l = !1);
        return (
          (async () => {
            try {
              const { unsubscribe: d } = await e.transport.subscribe({
                params: ["newPendingTransactions"],
                onData(f) {
                  if (!l) return;
                  const p = f.result;
                  r([p]);
                },
                onError(f) {
                  n == null || n(f);
                },
              });
              (c = d), l || c();
            } catch (d) {
              n == null || n(d);
            }
          })(),
          c
        );
      })();
}
function _R(e) {
  return {
    call: (t) => Wh(e, t),
    createBlockFilter: () => WO(e),
    createContractEventFilter: (t) => hS(e, t),
    createEventFilter: (t) => NS(e, t),
    createPendingTransactionFilter: () => MS(e),
    estimateContractGas: (t) => YD(e, t),
    estimateGas: (t) => tb(e, t),
    getBalance: (t) => QO(e, t),
    getBlock: (t) => is(e, t),
    getBlockNumber: (t) => fl(e, t),
    getBlockTransactionCount: (t) => VO(e, t),
    getBytecode: (t) => KO(e, t),
    getChainId: () => xc(e),
    getContractEvents: (t) => _S(e, t),
    getEnsAddress: (t) => PO(e, t),
    getEnsAvatar: (t) => zO(e, t),
    getEnsName: (t) => GO(e, t),
    getEnsResolver: (t) => qO(e, t),
    getEnsText: (t) => BS(e, t),
    getFeeHistory: (t) => JO(e, t),
    estimateFeesPerGas: (t) => ZD(e, t),
    getFilterChanges: (t) => Qh(e, t),
    getFilterLogs: (t) => YO(e, t),
    getGasPrice: () => eb(e),
    getLogs: (t) => nb(e, t),
    getProof: (t) => cR(e, t),
    estimateMaxPriorityFeePerGas: (t) => KD(e, t),
    getStorageAt: (t) => lR(e, t),
    getTransaction: (t) => cb(e, t),
    getTransactionConfirmations: (t) => dR(e, t),
    getTransactionCount: (t) => ES(e, t),
    getTransactionReceipt: (t) => _y(e, t),
    multicall: (t) => fR(e, t),
    prepareTransactionRequest: (t) => Gh(e, t),
    readContract: (t) => ss(e, t),
    sendRawTransaction: (t) => ib(e, t),
    simulateContract: (t) => cO(e, t),
    verifyMessage: (t) => yR(e, t),
    verifyTypedData: (t) => gR(e, t),
    uninstallFilter: (t) => Vh(e, t),
    waitForTransactionReceipt: (t) => vR(e, t),
    watchBlocks: (t) => bR(e, t),
    watchBlockNumber: (t) => qS(e, t),
    watchContractEvent: (t) => yO(e, t),
    watchEvent: (t) => wR(e, t),
    watchPendingTransactions: (t) => ER(e, t),
  };
}
function lE(e) {
  const { key: t = "public", name: n = "Public Client" } = e;
  return CS({ ...e, key: t, name: n, type: "publicClient" }).extend(_R);
}
function AR(e, { abi: t, args: n, bytecode: r, ...i }) {
  const s = zS({ abi: t, args: n, bytecode: r });
  return sb(e, { ...i, data: s });
}
async function xR(e) {
  var n;
  return ((n = e.account) == null ? void 0 : n.type) === "local"
    ? [e.account.address]
    : (await e.request({ method: "eth_accounts" })).map((r) => Wv(r));
}
async function SR(e) {
  return await e.request({ method: "wallet_getPermissions" });
}
async function CR(e) {
  return (await e.request({ method: "eth_requestAccounts" })).map((n) => Yi(n));
}
async function TR(e, t) {
  return e.request({ method: "wallet_requestPermissions", params: [t] });
}
async function IR(e, { account: t = e.account, message: n }) {
  if (!t) throw new Ua({ docsPath: "/docs/actions/wallet/signMessage" });
  const r = tr(t);
  if (r.type === "local") return r.signMessage({ message: n });
  const i =
    typeof n == "string"
      ? Lv(n)
      : n.raw instanceof Uint8Array
      ? gi(n.raw)
      : n.raw;
  return e.request({ method: "personal_sign", params: [i, r.address] });
}
async function kR(e, t) {
  var l, c, d, f;
  const { account: n = e.account, chain: r = e.chain, ...i } = t;
  if (!n) throw new Ua({ docsPath: "/docs/actions/wallet/signTransaction" });
  const s = tr(n);
  cl({ account: s, ...t });
  const o = await se(e, xc, "getChainId")({});
  r !== null && SS({ currentChainId: o, chain: r });
  const a =
      (r == null ? void 0 : r.formatters) ||
      ((l = e.chain) == null ? void 0 : l.formatters),
    u =
      ((c = a == null ? void 0 : a.transactionRequest) == null
        ? void 0
        : c.format) || Lh;
  return s.type === "local"
    ? s.signTransaction(
        { ...i, chainId: o },
        {
          serializer:
            (f = (d = e.chain) == null ? void 0 : d.serializers) == null
              ? void 0
              : f.transaction,
        }
      )
    : await e.request({
        method: "eth_signTransaction",
        params: [{ ...u(i), chainId: he(o), from: s.address }],
      });
}
async function PR(
  e,
  { account: t = e.account, domain: n, message: r, primaryType: i, types: s }
) {
  if (!t) throw new Ua({ docsPath: "/docs/actions/wallet/signTypedData" });
  const o = tr(t),
    a = { EIP712Domain: HS({ domain: n }), ...s };
  if (
    ($S({ domain: n, message: r, primaryType: i, types: a }),
    o.type === "local")
  )
    return o.signTypedData({ domain: n, primaryType: i, types: a, message: r });
  const u = rn(
    { domain: n ?? {}, primaryType: i, types: a, message: r },
    (l, c) => (Dr(c) ? c.toLowerCase() : c)
  );
  return e.request({ method: "eth_signTypedData_v4", params: [o.address, u] });
}
async function DR(e, { id: t }) {
  await e.request({
    method: "wallet_switchEthereumChain",
    params: [{ chainId: he(t) }],
  });
}
async function OR(e, t) {
  return await e.request({ method: "wallet_watchAsset", params: t });
}
function RR(e) {
  return {
    addChain: (t) => bO(e, t),
    deployContract: (t) => AR(e, t),
    getAddresses: () => xR(e),
    getChainId: () => xc(e),
    getPermissions: () => SR(e),
    prepareTransactionRequest: (t) => Gh(e, t),
    requestAddresses: () => CR(e),
    requestPermissions: (t) => TR(e, t),
    sendRawTransaction: (t) => ib(e, t),
    sendTransaction: (t) => sb(e, t),
    signMessage: (t) => IR(e, t),
    signTransaction: (t) => kR(e, t),
    signTypedData: (t) => PR(e, t),
    switchChain: (t) => DR(e, t),
    watchAsset: (t) => OR(e, t),
    writeContract: (t) => vO(e, t),
  };
}
function WS(e) {
  const { key: t = "wallet", name: n = "Wallet Client", transport: r } = e;
  return CS({
    ...e,
    key: t,
    name: n,
    transport: (s) => r({ ...s, retryCount: 0 }),
    type: "walletClient",
  }).extend(RR);
}
function BR(e, t = {}) {
  const {
    key: n = "webSocket",
    name: r = "WebSocket JSON-RPC",
    retryDelay: i,
  } = t;
  return ({ chain: s, retryCount: o, timeout: a }) => {
    var d;
    const u = t.retryCount ?? o,
      l = a ?? t.timeout ?? 1e4,
      c =
        e ||
        ((d = s == null ? void 0 : s.rpcUrls.default.webSocket) == null
          ? void 0
          : d[0]);
    if (!c) throw new kS();
    return Kh(
      {
        key: n,
        name: r,
        async request({ method: f, params: p }) {
          const m = { method: f, params: p },
            g = await wm(c),
            { error: w, result: v } = await ra.webSocketAsync(g, {
              body: m,
              timeout: l,
            });
          if (w) throw new Zv({ body: m, error: w, url: c });
          return v;
        },
        retryCount: u,
        retryDelay: i,
        timeout: l,
        type: "webSocket",
      },
      {
        getSocket() {
          return wm(c);
        },
        async subscribe({ params: f, onData: p, onError: m }) {
          const g = await wm(c),
            { result: w } = await new Promise((v, y) =>
              ra.webSocket(g, {
                body: { method: "eth_subscribe", params: f },
                onResponse(b) {
                  if (b.error) {
                    y(b.error), m == null || m(b.error);
                    return;
                  }
                  if (typeof b.id == "number") {
                    v(b);
                    return;
                  }
                  b.method === "eth_subscription" && p(b.params);
                },
              })
            );
          return {
            subscriptionId: w,
            async unsubscribe() {
              return new Promise((v) =>
                ra.webSocket(g, {
                  body: { method: "eth_unsubscribe", params: [w] },
                  onResponse: v,
                })
              );
            },
          };
        },
      }
    );
  };
}
const QS = Qx({
    id: 5,
    network: "goerli",
    name: "Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://eth-goerli.g.alchemy.com/v2"],
      },
      infura: {
        http: ["https://goerli.infura.io/v3"],
        webSocket: ["wss://goerli.infura.io/ws/v3"],
      },
      default: { http: ["https://rpc.ankr.com/eth_goerli"] },
      public: { http: ["https://rpc.ankr.com/eth_goerli"] },
    },
    blockExplorers: {
      etherscan: { name: "Etherscan", url: "https://goerli.etherscan.io" },
      default: { name: "Etherscan", url: "https://goerli.etherscan.io" },
    },
    contracts: {
      ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
      ensUniversalResolver: {
        address: "0x56522D00C410a43BFfDF00a9A569489297385790",
        blockCreated: 8765204,
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6507670,
      },
    },
    testnet: !0,
  }),
  VS = Qx({
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"],
      },
      infura: {
        http: ["https://mainnet.infura.io/v3"],
        webSocket: ["wss://mainnet.infura.io/ws/v3"],
      },
      default: { http: ["https://cloudflare-eth.com"] },
      public: { http: ["https://cloudflare-eth.com"] },
    },
    blockExplorers: {
      etherscan: { name: "Etherscan", url: "https://etherscan.io" },
      default: { name: "Etherscan", url: "https://etherscan.io" },
    },
    contracts: {
      ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
      ensUniversalResolver: {
        address: "0xc0497E381f536Be9ce14B0dD3817cBcAe57d2F62",
        blockCreated: 16966585,
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601,
      },
    },
  });
var NR = class extends Error {
    constructor({ chainId: e, connectorId: t }) {
      super(`Chain "${e}" not configured for connector "${t}".`),
        (this.name = "ChainNotConfiguredForConnectorError");
    }
  },
  Ts = class extends Error {
    constructor() {
      super(...arguments),
        (this.name = "ConnectorNotFoundError"),
        (this.message = "Connector not found");
    }
  };
function dE(e) {
  return typeof e == "string"
    ? Number.parseInt(e, e.trim().substring(0, 2) === "0x" ? 16 : 10)
    : typeof e == "bigint"
    ? Number(e)
    : e;
}
var KS = { exports: {} };
(function (e) {
  var t = Object.prototype.hasOwnProperty,
    n = "~";
  function r() {}
  Object.create &&
    ((r.prototype = Object.create(null)), new r().__proto__ || (n = !1));
  function i(u, l, c) {
    (this.fn = u), (this.context = l), (this.once = c || !1);
  }
  function s(u, l, c, d, f) {
    if (typeof c != "function")
      throw new TypeError("The listener must be a function");
    var p = new i(c, d || u, f),
      m = n ? n + l : l;
    return (
      u._events[m]
        ? u._events[m].fn
          ? (u._events[m] = [u._events[m], p])
          : u._events[m].push(p)
        : ((u._events[m] = p), u._eventsCount++),
      u
    );
  }
  function o(u, l) {
    --u._eventsCount === 0 ? (u._events = new r()) : delete u._events[l];
  }
  function a() {
    (this._events = new r()), (this._eventsCount = 0);
  }
  (a.prototype.eventNames = function () {
    var l = [],
      c,
      d;
    if (this._eventsCount === 0) return l;
    for (d in (c = this._events)) t.call(c, d) && l.push(n ? d.slice(1) : d);
    return Object.getOwnPropertySymbols
      ? l.concat(Object.getOwnPropertySymbols(c))
      : l;
  }),
    (a.prototype.listeners = function (l) {
      var c = n ? n + l : l,
        d = this._events[c];
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, p = d.length, m = new Array(p); f < p; f++)
        m[f] = d[f].fn;
      return m;
    }),
    (a.prototype.listenerCount = function (l) {
      var c = n ? n + l : l,
        d = this._events[c];
      return d ? (d.fn ? 1 : d.length) : 0;
    }),
    (a.prototype.emit = function (l, c, d, f, p, m) {
      var g = n ? n + l : l;
      if (!this._events[g]) return !1;
      var w = this._events[g],
        v = arguments.length,
        y,
        b;
      if (w.fn) {
        switch ((w.once && this.removeListener(l, w.fn, void 0, !0), v)) {
          case 1:
            return w.fn.call(w.context), !0;
          case 2:
            return w.fn.call(w.context, c), !0;
          case 3:
            return w.fn.call(w.context, c, d), !0;
          case 4:
            return w.fn.call(w.context, c, d, f), !0;
          case 5:
            return w.fn.call(w.context, c, d, f, p), !0;
          case 6:
            return w.fn.call(w.context, c, d, f, p, m), !0;
        }
        for (b = 1, y = new Array(v - 1); b < v; b++) y[b - 1] = arguments[b];
        w.fn.apply(w.context, y);
      } else {
        var _ = w.length,
          A;
        for (b = 0; b < _; b++)
          switch (
            (w[b].once && this.removeListener(l, w[b].fn, void 0, !0), v)
          ) {
            case 1:
              w[b].fn.call(w[b].context);
              break;
            case 2:
              w[b].fn.call(w[b].context, c);
              break;
            case 3:
              w[b].fn.call(w[b].context, c, d);
              break;
            case 4:
              w[b].fn.call(w[b].context, c, d, f);
              break;
            default:
              if (!y)
                for (A = 1, y = new Array(v - 1); A < v; A++)
                  y[A - 1] = arguments[A];
              w[b].fn.apply(w[b].context, y);
          }
      }
      return !0;
    }),
    (a.prototype.on = function (l, c, d) {
      return s(this, l, c, d, !1);
    }),
    (a.prototype.once = function (l, c, d) {
      return s(this, l, c, d, !0);
    }),
    (a.prototype.removeListener = function (l, c, d, f) {
      var p = n ? n + l : l;
      if (!this._events[p]) return this;
      if (!c) return o(this, p), this;
      var m = this._events[p];
      if (m.fn)
        m.fn === c && (!f || m.once) && (!d || m.context === d) && o(this, p);
      else {
        for (var g = 0, w = [], v = m.length; g < v; g++)
          (m[g].fn !== c || (f && !m[g].once) || (d && m[g].context !== d)) &&
            w.push(m[g]);
        w.length ? (this._events[p] = w.length === 1 ? w[0] : w) : o(this, p);
      }
      return this;
    }),
    (a.prototype.removeAllListeners = function (l) {
      var c;
      return (
        l
          ? ((c = n ? n + l : l), this._events[c] && o(this, c))
          : ((this._events = new r()), (this._eventsCount = 0)),
        this
      );
    }),
    (a.prototype.off = a.prototype.removeListener),
    (a.prototype.addListener = a.prototype.on),
    (a.prefixed = n),
    (a.EventEmitter = a),
    (e.exports = a);
})(KS);
var MR = KS.exports;
const LR = Xc(MR);
var lb = (e, t, n) => {
    if (!t.has(e)) throw TypeError("Cannot " + n);
  },
  Ye = (e, t, n) => (
    lb(e, t, "read from private field"), n ? n.call(e) : t.get(e)
  ),
  jn = (e, t, n) => {
    if (t.has(e))
      throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, n);
  },
  db = (e, t, n, r) => (
    lb(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n
  ),
  yt = (e, t, n) => (lb(e, t, "access private method"), n),
  ZS = class extends LR {
    constructor({ chains: e = [VS, QS], options: t }) {
      super(), (this.chains = e), (this.options = t);
    }
    getBlockExplorerUrls(e) {
      const { default: t, ...n } = e.blockExplorers ?? {};
      if (t) return [t.url, ...Object.values(n).map((r) => r.url)];
    }
    isChainUnsupported(e) {
      return !this.chains.some((t) => t.id === e);
    }
    setStorage(e) {
      this.storage = e;
    }
  };
function FR(e) {
  var n;
  if (!e) return "Injected";
  const t = (r) => {
    if (r.isApexWallet) return "Apex Wallet";
    if (r.isAvalanche) return "Core Wallet";
    if (r.isBackpack) return "Backpack";
    if (r.isBifrost) return "Bifrost Wallet";
    if (r.isBitKeep) return "BitKeep";
    if (r.isBitski) return "Bitski";
    if (r.isBlockWallet) return "BlockWallet";
    if (r.isBraveWallet) return "Brave Wallet";
    if (r.isCoin98) return "Coin98 Wallet";
    if (r.isCoinbaseWallet) return "Coinbase Wallet";
    if (r.isDawn) return "Dawn Wallet";
    if (r.isDefiant) return "Defiant";
    if (r.isDesig) return "Desig Wallet";
    if (r.isEnkrypt) return "Enkrypt";
    if (r.isExodus) return "Exodus";
    if (r.isFordefi) return "Fordefi";
    if (r.isFrame) return "Frame";
    if (r.isFrontier) return "Frontier Wallet";
    if (r.isGamestop) return "GameStop Wallet";
    if (r.isHaqqWallet) return "HAQQ Wallet";
    if (r.isHyperPay) return "HyperPay Wallet";
    if (r.isImToken) return "ImToken";
    if (r.isHaloWallet) return "Halo Wallet";
    if (r.isKuCoinWallet) return "KuCoin Wallet";
    if (r.isMathWallet) return "MathWallet";
    if (r.isNovaWallet) return "Nova Wallet";
    if (r.isOkxWallet || r.isOKExWallet) return "OKX Wallet";
    if (r.isOktoWallet) return "Okto Wallet";
    if (r.isOneInchIOSWallet || r.isOneInchAndroidWallet) return "1inch Wallet";
    if (r.isOneKey) return "OneKey Wallet";
    if (r.isOpera) return "Opera";
    if (r.isPhantom) return "Phantom";
    if (r.isPortal) return "Ripio Portal";
    if (r.isRabby) return "Rabby Wallet";
    if (r.isRainbow) return "Rainbow";
    if (r.isSafePal) return "SafePal Wallet";
    if (r.isStatus) return "Status";
    if (r.isSubWallet) return "SubWallet";
    if (r.isTalisman) return "Talisman";
    if (r.isTally) return "Taho";
    if (r.isTokenPocket) return "TokenPocket";
    if (r.isTokenary) return "Tokenary";
    if (r.isTrust || r.isTrustWallet) return "Trust Wallet";
    if (r.isTTWallet) return "TTWallet";
    if (r.isXDEFI) return "XDEFI Wallet";
    if (r.isZeal) return "Zeal";
    if (r.isZerion) return "Zerion";
    if (r.isMetaMask) return "MetaMask";
  };
  if ((n = e.providers) != null && n.length) {
    const r = new Set();
    let i = 1;
    for (const o of e.providers) {
      let a = t(o);
      a || ((a = `Unknown Wallet #${i}`), (i += 1)), r.add(a);
    }
    const s = [...r];
    return s.length ? s : s[0] ?? "Injected";
  }
  return t(e) ?? "Injected";
}
var wd,
  JS = class extends ZS {
    constructor({ chains: e, options: t } = {}) {
      const n = {
        shimDisconnect: !0,
        getProvider() {
          if (typeof window > "u") return;
          const i = window.ethereum;
          return i != null && i.providers && i.providers.length > 0
            ? i.providers[0]
            : i;
        },
        ...t,
      };
      super({ chains: e, options: n }),
        (this.id = "injected"),
        jn(this, wd, void 0),
        (this.shimDisconnectKey = `${this.id}.shimDisconnect`),
        (this.onAccountsChanged = (i) => {
          i.length === 0
            ? this.emit("disconnect")
            : this.emit("change", { account: Yi(i[0]) });
        }),
        (this.onChainChanged = (i) => {
          const s = dE(i),
            o = this.isChainUnsupported(s);
          this.emit("change", { chain: { id: s, unsupported: o } });
        }),
        (this.onDisconnect = async (i) => {
          var s;
          (i.code === 1013 &&
            (await this.getProvider()) &&
            (await this.getAccount())) ||
            (this.emit("disconnect"),
            this.options.shimDisconnect &&
              ((s = this.storage) == null ||
                s.removeItem(this.shimDisconnectKey)));
        });
      const r = n.getProvider();
      if (typeof n.name == "string") this.name = n.name;
      else if (r) {
        const i = FR(r);
        n.name
          ? (this.name = n.name(i))
          : typeof i == "string"
          ? (this.name = i)
          : (this.name = i[0]);
      } else this.name = "Injected";
      this.ready = !!r;
    }
    async connect({ chainId: e } = {}) {
      var t;
      try {
        const n = await this.getProvider();
        if (!n) throw new Ts();
        n.on &&
          (n.on("accountsChanged", this.onAccountsChanged),
          n.on("chainChanged", this.onChainChanged),
          n.on("disconnect", this.onDisconnect)),
          this.emit("message", { type: "connecting" });
        const r = await n.request({ method: "eth_requestAccounts" }),
          i = Yi(r[0]);
        let s = await this.getChainId(),
          o = this.isChainUnsupported(s);
        return (
          e &&
            s !== e &&
            ((s = (await this.switchChain(e)).id),
            (o = this.isChainUnsupported(s))),
          this.options.shimDisconnect &&
            ((t = this.storage) == null ||
              t.setItem(this.shimDisconnectKey, !0)),
          { account: i, chain: { id: s, unsupported: o } }
        );
      } catch (n) {
        throw this.isUserRejectedRequestError(n)
          ? new Vn(n)
          : n.code === -32002
          ? new va(n)
          : n;
      }
    }
    async disconnect() {
      var t;
      const e = await this.getProvider();
      e != null &&
        e.removeListener &&
        (e.removeListener("accountsChanged", this.onAccountsChanged),
        e.removeListener("chainChanged", this.onChainChanged),
        e.removeListener("disconnect", this.onDisconnect),
        this.options.shimDisconnect &&
          ((t = this.storage) == null || t.removeItem(this.shimDisconnectKey)));
    }
    async getAccount() {
      const e = await this.getProvider();
      if (!e) throw new Ts();
      const t = await e.request({ method: "eth_accounts" });
      return Yi(t[0]);
    }
    async getChainId() {
      const e = await this.getProvider();
      if (!e) throw new Ts();
      return e.request({ method: "eth_chainId" }).then(dE);
    }
    async getProvider() {
      const e = this.options.getProvider();
      return e && db(this, wd, e), Ye(this, wd);
    }
    async getWalletClient({ chainId: e } = {}) {
      const [t, n] = await Promise.all([this.getProvider(), this.getAccount()]),
        r = this.chains.find((i) => i.id === e);
      if (!t) throw new Error("provider is required.");
      return WS({ account: n, chain: r, transport: IS(t) });
    }
    async isAuthorized() {
      var e;
      try {
        if (
          this.options.shimDisconnect &&
          !((e = this.storage) != null && e.getItem(this.shimDisconnectKey))
        )
          return !1;
        if (!(await this.getProvider())) throw new Ts();
        return !!(await this.getAccount());
      } catch {
        return !1;
      }
    }
    async switchChain(e) {
      var r, i, s;
      const t = await this.getProvider();
      if (!t) throw new Ts();
      const n = he(e);
      try {
        return (
          await Promise.all([
            t.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: n }],
            }),
            new Promise((o) =>
              this.on("change", ({ chain: a }) => {
                (a == null ? void 0 : a.id) === e && o();
              })
            ),
          ]),
          this.chains.find((o) => o.id === e) ?? {
            id: e,
            name: `Chain ${n}`,
            network: `${n}`,
            nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
            rpcUrls: { default: { http: [""] }, public: { http: [""] } },
          }
        );
      } catch (o) {
        const a = this.chains.find((u) => u.id === e);
        if (!a) throw new NR({ chainId: e, connectorId: this.id });
        if (
          o.code === 4902 ||
          ((i =
            (r = o == null ? void 0 : o.data) == null
              ? void 0
              : r.originalError) == null
            ? void 0
            : i.code) === 4902
        )
          try {
            if (
              (await t.request({
                method: "wallet_addEthereumChain",
                params: [
                  {
                    chainId: n,
                    chainName: a.name,
                    nativeCurrency: a.nativeCurrency,
                    rpcUrls: [
                      ((s = a.rpcUrls.public) == null ? void 0 : s.http[0]) ??
                        "",
                    ],
                    blockExplorerUrls: this.getBlockExplorerUrls(a),
                  },
                ],
              }),
              (await this.getChainId()) !== e)
            )
              throw new Vn(
                new Error("User rejected switch after adding network.")
              );
            return a;
          } catch (u) {
            throw new Vn(u);
          }
        throw this.isUserRejectedRequestError(o) ? new Vn(o) : new rs(o);
      }
    }
    async watchAsset({ address: e, decimals: t = 18, image: n, symbol: r }) {
      const i = await this.getProvider();
      if (!i) throw new Ts();
      return i.request({
        method: "wallet_watchAsset",
        params: {
          type: "ERC20",
          options: { address: e, decimals: t, image: n, symbol: r },
        },
      });
    }
    isUserRejectedRequestError(e) {
      return e.code === 4001;
    }
  };
wd = new WeakMap();
var fb = (e, t, n) => {
    if (!t.has(e)) throw TypeError("Cannot " + n);
  },
  _m = (e, t, n) => (
    fb(e, t, "read from private field"), n ? n.call(e) : t.get(e)
  ),
  Am = (e, t, n) => {
    if (t.has(e))
      throw TypeError("Cannot add the same private member more than once");
    t instanceof WeakSet ? t.add(e) : t.set(e, n);
  },
  Ql = (e, t, n, r) => (
    fb(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n
  ),
  jR = (e, t, n) => (fb(e, t, "access private method"), n),
  UR = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const $R = (e) => (t, n, r) => {
    const i = r.subscribe;
    return (
      (r.subscribe = (o, a, u) => {
        let l = o;
        if (a) {
          const c = (u == null ? void 0 : u.equalityFn) || Object.is;
          let d = o(r.getState());
          (l = (f) => {
            const p = o(f);
            if (!c(d, p)) {
              const m = d;
              a((d = p), m);
            }
          }),
            u != null && u.fireImmediately && a(d, d);
        }
        return i(l);
      }),
      e(t, n, r)
    );
  },
  HR = $R;
function zR(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var s;
      const o = (u) =>
          u === null ? null : JSON.parse(u, t == null ? void 0 : t.reviver),
        a = (s = n.getItem(i)) != null ? s : null;
      return a instanceof Promise ? a.then(o) : o(a);
    },
    setItem: (i, s) =>
      n.setItem(i, JSON.stringify(s, t == null ? void 0 : t.replacer)),
    removeItem: (i) => n.removeItem(i),
  };
}
const Sc = (e) => (t) => {
    try {
      const n = e(t);
      return n instanceof Promise
        ? n
        : {
            then(r) {
              return Sc(r)(n);
            },
            catch(r) {
              return this;
            },
          };
    } catch (n) {
      return {
        then(r) {
          return this;
        },
        catch(r) {
          return Sc(r)(n);
        },
      };
    }
  },
  GR = (e, t) => (n, r, i) => {
    let s = {
        getStorage: () => localStorage,
        serialize: JSON.stringify,
        deserialize: JSON.parse,
        partialize: (w) => w,
        version: 0,
        merge: (w, v) => ({ ...v, ...w }),
        ...t,
      },
      o = !1;
    const a = new Set(),
      u = new Set();
    let l;
    try {
      l = s.getStorage();
    } catch {}
    if (!l)
      return e(
        (...w) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
          ),
            n(...w);
        },
        r,
        i
      );
    const c = Sc(s.serialize),
      d = () => {
        const w = s.partialize({ ...r() });
        let v;
        const y = c({ state: w, version: s.version })
          .then((b) => l.setItem(s.name, b))
          .catch((b) => {
            v = b;
          });
        if (v) throw v;
        return y;
      },
      f = i.setState;
    i.setState = (w, v) => {
      f(w, v), d();
    };
    const p = e(
      (...w) => {
        n(...w), d();
      },
      r,
      i
    );
    let m;
    const g = () => {
      var w;
      if (!l) return;
      (o = !1), a.forEach((y) => y(r()));
      const v =
        ((w = s.onRehydrateStorage) == null ? void 0 : w.call(s, r())) ||
        void 0;
      return Sc(l.getItem.bind(l))(s.name)
        .then((y) => {
          if (y) return s.deserialize(y);
        })
        .then((y) => {
          if (y)
            if (typeof y.version == "number" && y.version !== s.version) {
              if (s.migrate) return s.migrate(y.state, y.version);
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              );
            } else return y.state;
        })
        .then((y) => {
          var b;
          return (m = s.merge(y, (b = r()) != null ? b : p)), n(m, !0), d();
        })
        .then(() => {
          v == null || v(m, void 0), (o = !0), u.forEach((y) => y(m));
        })
        .catch((y) => {
          v == null || v(void 0, y);
        });
    };
    return (
      (i.persist = {
        setOptions: (w) => {
          (s = { ...s, ...w }), w.getStorage && (l = w.getStorage());
        },
        clearStorage: () => {
          l == null || l.removeItem(s.name);
        },
        getOptions: () => s,
        rehydrate: () => g(),
        hasHydrated: () => o,
        onHydrate: (w) => (
          a.add(w),
          () => {
            a.delete(w);
          }
        ),
        onFinishHydration: (w) => (
          u.add(w),
          () => {
            u.delete(w);
          }
        ),
      }),
      g(),
      m || p
    );
  },
  qR = (e, t) => (n, r, i) => {
    let s = {
        storage: zR(() => localStorage),
        partialize: (g) => g,
        version: 0,
        merge: (g, w) => ({ ...w, ...g }),
        ...t,
      },
      o = !1;
    const a = new Set(),
      u = new Set();
    let l = s.storage;
    if (!l)
      return e(
        (...g) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`
          ),
            n(...g);
        },
        r,
        i
      );
    const c = () => {
        const g = s.partialize({ ...r() });
        return l.setItem(s.name, { state: g, version: s.version });
      },
      d = i.setState;
    i.setState = (g, w) => {
      d(g, w), c();
    };
    const f = e(
      (...g) => {
        n(...g), c();
      },
      r,
      i
    );
    let p;
    const m = () => {
      var g, w;
      if (!l) return;
      (o = !1),
        a.forEach((y) => {
          var b;
          return y((b = r()) != null ? b : f);
        });
      const v =
        ((w = s.onRehydrateStorage) == null
          ? void 0
          : w.call(s, (g = r()) != null ? g : f)) || void 0;
      return Sc(l.getItem.bind(l))(s.name)
        .then((y) => {
          if (y)
            if (typeof y.version == "number" && y.version !== s.version) {
              if (s.migrate) return s.migrate(y.state, y.version);
              console.error(
                "State loaded from storage couldn't be migrated since no migrate function was provided"
              );
            } else return y.state;
        })
        .then((y) => {
          var b;
          return (p = s.merge(y, (b = r()) != null ? b : f)), n(p, !0), c();
        })
        .then(() => {
          v == null || v(p, void 0),
            (p = r()),
            (o = !0),
            u.forEach((y) => y(p));
        })
        .catch((y) => {
          v == null || v(void 0, y);
        });
    };
    return (
      (i.persist = {
        setOptions: (g) => {
          (s = { ...s, ...g }), g.storage && (l = g.storage);
        },
        clearStorage: () => {
          l == null || l.removeItem(s.name);
        },
        getOptions: () => s,
        rehydrate: () => m(),
        hasHydrated: () => o,
        onHydrate: (g) => (
          a.add(g),
          () => {
            a.delete(g);
          }
        ),
        onFinishHydration: (g) => (
          u.add(g),
          () => {
            u.delete(g);
          }
        ),
      }),
      s.skipHydration || m(),
      p || f
    );
  },
  WR = (e, t) =>
    "getStorage" in t || "serialize" in t || "deserialize" in t
      ? ((UR ? "production" : void 0) !== "production" &&
          console.warn(
            "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
          ),
        GR(e, t))
      : qR(e, t),
  QR = WR;
var VR = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const fE = (e) => {
    let t;
    const n = new Set(),
      r = (u, l) => {
        const c = typeof u == "function" ? u(t) : u;
        if (!Object.is(c, t)) {
          const d = t;
          (t =
            l ?? (typeof c != "object" || c === null)
              ? c
              : Object.assign({}, t, c)),
            n.forEach((f) => f(t, d));
        }
      },
      i = () => t,
      a = {
        setState: r,
        getState: i,
        subscribe: (u) => (n.add(u), () => n.delete(u)),
        destroy: () => {
          (VR ? "production" : void 0) !== "production" &&
            console.warn(
              "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
            ),
            n.clear();
        },
      };
    return (t = e(r, i, a)), a;
  },
  KR = (e) => (e ? fE(e) : fE);
function hb(e, t) {
  if (Object.is(e, t)) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, i] of e) if (!Object.is(i, t.get(r))) return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e) if (!t.has(r)) return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length) return !1;
  for (let r = 0; r < n.length; r++)
    if (
      !Object.prototype.hasOwnProperty.call(t, n[r]) ||
      !Object.is(e[n[r]], t[n[r]])
    )
      return !1;
  return !0;
}
function ZR(
  e,
  t,
  {
    batch: n = { multicall: { wait: 32 } },
    pollingInterval: r = 4e3,
    rank: i,
    retryCount: s,
    retryDelay: o,
    stallTimeout: a,
  } = {}
) {
  if (!e.length) throw new Error("must have at least one chain");
  let u = [];
  const l = {},
    c = {};
  for (const d of e) {
    let f = !1;
    for (const p of t) {
      const m = p(d);
      m &&
        ((f = !0),
        u.some(({ id: g }) => g === d.id) || (u = [...u, m.chain]),
        (l[d.id] = [...(l[d.id] || []), ...m.rpcUrls.http]),
        m.rpcUrls.webSocket &&
          (c[d.id] = [...(c[d.id] || []), ...m.rpcUrls.webSocket]));
    }
    if (!f)
      throw new Error(
        [
          `Could not find valid provider configuration for chain "${d.name}".
`,
          "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
          "Read more: https://wagmi.sh/core/providers/jsonRpc",
        ].join(`
`)
      );
  }
  return {
    chains: u,
    publicClient: ({ chainId: d }) => {
      const f = u.find((g) => g.id === d) ?? e[0],
        p = l[f.id];
      if (!p || !p[0])
        throw new Error(`No providers configured for chain "${f.id}"`);
      const m = lE({
        batch: n,
        chain: f,
        transport: aE(
          p.map((g) => TO(g, { timeout: a })),
          { rank: i, retryCount: s, retryDelay: o }
        ),
        pollingInterval: r,
      });
      return Object.assign(m, { chains: u });
    },
    webSocketPublicClient: ({ chainId: d }) => {
      const f = u.find((g) => g.id === d) ?? e[0],
        p = c[f.id];
      if (!p || !p[0]) return;
      const m = lE({
        batch: n,
        chain: f,
        transport: aE(
          p.map((g) => BR(g, { timeout: a })),
          { rank: i, retryCount: s, retryDelay: o }
        ),
        pollingInterval: r,
      });
      return Object.assign(m, { chains: u });
    },
  };
}
var JR = class extends Error {
    constructor({ chainId: e, connectorId: t }) {
      super(`Chain "${e}" not configured${t ? ` for connector "${t}"` : ""}.`),
        (this.name = "ChainNotConfigured");
    }
  },
  YR = class extends Error {
    constructor() {
      super(...arguments),
        (this.name = "ConnectorAlreadyConnectedError"),
        (this.message = "Connector already connected");
    }
  },
  XR = class extends Error {
    constructor() {
      super(...arguments),
        (this.name = "ConfigChainsNotFound"),
        (this.message =
          "No chains were found on the wagmi config. Some functions that require a chain may not work.");
    }
  },
  e8 = class extends Error {
    constructor({ connector: e }) {
      super(`"${e.name}" does not support programmatic chain switching.`),
        (this.name = "SwitchChainNotSupportedError");
    }
  };
function Ay(e, t) {
  if (e === t) return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor !== t.constructor) return !1;
    let n, r;
    if (Array.isArray(e) && Array.isArray(t)) {
      if (((n = e.length), n != t.length)) return !1;
      for (r = n; r-- !== 0; ) if (!Ay(e[r], t[r])) return !1;
      return !0;
    }
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === t.toString();
    const i = Object.keys(e);
    if (((n = i.length), n !== Object.keys(t).length)) return !1;
    for (r = n; r-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, i[r])) return !1;
    for (r = n; r-- !== 0; ) {
      const s = i[r];
      if (s && !Ay(e[s], t[s])) return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
var xy = (e, { find: t, replace: n }) =>
  e && t(e)
    ? n(e)
    : typeof e != "object"
    ? e
    : Array.isArray(e)
    ? e.map((r) => xy(r, { find: t, replace: n }))
    : e instanceof Object
    ? Object.entries(e).reduce(
        (r, [i, s]) => ({ ...r, [i]: xy(s, { find: t, replace: n }) }),
        {}
      )
    : e;
function t8(e) {
  const t = JSON.parse(e);
  return xy(t, {
    find: (r) => typeof r == "string" && r.startsWith("#bigint."),
    replace: (r) => BigInt(r.replace("#bigint.", "")),
  });
}
function hE(e) {
  return typeof e == "number" ? e : e === "wei" ? 0 : Math.abs(E5[e]);
}
function pE(e, t) {
  return e.slice(0, t).join(".") || ".";
}
function mE(e, t) {
  const { length: n } = e;
  for (let r = 0; r < n; ++r) if (e[r] === t) return r + 1;
  return 0;
}
function n8(e, t) {
  const n = typeof e == "function",
    r = typeof t == "function",
    i = [],
    s = [];
  return function (a, u) {
    if (typeof u == "object")
      if (i.length) {
        const l = mE(i, this);
        l === 0 ? (i[i.length] = this) : (i.splice(l), s.splice(l)),
          (s[s.length] = a);
        const c = mE(i, u);
        if (c !== 0)
          return r ? t.call(this, a, u, pE(s, c)) : `[ref=${pE(s, c)}]`;
      } else (i[0] = u), (s[0] = a);
    return n ? e.call(this, a, u) : u;
  };
}
function r8(e, t, n, r) {
  return JSON.stringify(
    e,
    n8((i, s) => {
      const o = typeof s == "bigint" ? `#bigint.${s.toString()}` : s;
      return (t == null ? void 0 : t(i, o)) || o;
    }, r),
    n ?? void 0
  );
}
var YS = {
  getItem: (e) => "",
  setItem: (e, t) => null,
  removeItem: (e) => null,
};
function XS({
  deserialize: e = t8,
  key: t = "wagmi",
  serialize: n = r8,
  storage: r,
}) {
  return {
    ...r,
    getItem: (i, s = null) => {
      const o = r.getItem(`${t}.${i}`);
      try {
        return o ? e(o) : s;
      } catch (a) {
        return console.warn(a), s;
      }
    },
    setItem: (i, s) => {
      if (s === null) r.removeItem(`${t}.${i}`);
      else
        try {
          r.setItem(`${t}.${i}`, n(s));
        } catch (o) {
          console.error(o);
        }
    },
    removeItem: (i) => r.removeItem(`${t}.${i}`),
  };
}
var yE = "store",
  Io,
  bu,
  Sy,
  eC,
  i8 = class {
    constructor({
      autoConnect: e = !1,
      connectors: t = [new JS()],
      publicClient: n,
      storage: r = XS({
        storage: typeof window < "u" ? window.localStorage : YS,
      }),
      logger: i = { warn: console.warn },
      webSocketPublicClient: s,
    }) {
      var l, c;
      Am(this, Sy),
        (this.publicClients = new Map()),
        (this.webSocketPublicClients = new Map()),
        Am(this, Io, void 0),
        Am(this, bu, void 0),
        (this.args = {
          autoConnect: e,
          connectors: t,
          logger: i,
          publicClient: n,
          storage: r,
          webSocketPublicClient: s,
        });
      let o = "disconnected",
        a;
      if (e)
        try {
          const d = r.getItem(yE),
            f = (l = d == null ? void 0 : d.state) == null ? void 0 : l.data;
          (o = f != null && f.account ? "reconnecting" : "connecting"),
            (a = (c = f == null ? void 0 : f.chain) == null ? void 0 : c.id);
        } catch {}
      const u = typeof t == "function" ? t() : t;
      u.forEach((d) => d.setStorage(r)),
        (this.store = KR(
          HR(
            QR(
              () => ({
                connectors: u,
                publicClient: this.getPublicClient({ chainId: a }),
                status: o,
                webSocketPublicClient: this.getWebSocketPublicClient({
                  chainId: a,
                }),
              }),
              {
                name: yE,
                storage: r,
                partialize: (d) => {
                  var f, p;
                  return {
                    ...(e && {
                      data: {
                        account:
                          (f = d == null ? void 0 : d.data) == null
                            ? void 0
                            : f.account,
                        chain:
                          (p = d == null ? void 0 : d.data) == null
                            ? void 0
                            : p.chain,
                      },
                    }),
                    chains: d == null ? void 0 : d.chains,
                  };
                },
                version: 2,
              }
            )
          )
        )),
        (this.storage = r),
        Ql(this, bu, r == null ? void 0 : r.getItem("wallet")),
        jR(this, Sy, eC).call(this),
        e &&
          typeof window < "u" &&
          setTimeout(async () => await this.autoConnect(), 0);
    }
    get chains() {
      return this.store.getState().chains;
    }
    get connectors() {
      return this.store.getState().connectors;
    }
    get connector() {
      return this.store.getState().connector;
    }
    get data() {
      return this.store.getState().data;
    }
    get error() {
      return this.store.getState().error;
    }
    get lastUsedChainId() {
      var e, t;
      return (t = (e = this.data) == null ? void 0 : e.chain) == null
        ? void 0
        : t.id;
    }
    get publicClient() {
      return this.store.getState().publicClient;
    }
    get status() {
      return this.store.getState().status;
    }
    get subscribe() {
      return this.store.subscribe;
    }
    get webSocketPublicClient() {
      return this.store.getState().webSocketPublicClient;
    }
    setState(e) {
      const t = typeof e == "function" ? e(this.store.getState()) : e;
      this.store.setState(t, !0);
    }
    clearState() {
      this.setState((e) => ({
        ...e,
        chains: void 0,
        connector: void 0,
        data: void 0,
        error: void 0,
        status: "disconnected",
      }));
    }
    async destroy() {
      var e, t;
      this.connector &&
        (await ((t = (e = this.connector).disconnect) == null
          ? void 0
          : t.call(e))),
        Ql(this, Io, !1),
        this.clearState(),
        this.store.destroy();
    }
    async autoConnect() {
      if (_m(this, Io)) return;
      Ql(this, Io, !0),
        this.setState((n) => {
          var r;
          return {
            ...n,
            status:
              (r = n.data) != null && r.account ? "reconnecting" : "connecting",
          };
        });
      const e = _m(this, bu)
        ? [...this.connectors].sort((n) => (n.id === _m(this, bu) ? -1 : 1))
        : this.connectors;
      let t = !1;
      for (const n of e) {
        if (!n.ready || !n.isAuthorized || !(await n.isAuthorized())) continue;
        const i = await n.connect();
        this.setState((s) => ({
          ...s,
          connector: n,
          chains: n == null ? void 0 : n.chains,
          data: i,
          status: "connected",
        })),
          (t = !0);
        break;
      }
      return (
        t ||
          this.setState((n) => ({
            ...n,
            data: void 0,
            status: "disconnected",
          })),
        Ql(this, Io, !1),
        this.data
      );
    }
    setConnectors(e) {
      this.args = { ...this.args, connectors: e };
      const t = typeof e == "function" ? e() : e;
      t.forEach((n) => n.setStorage(this.args.storage)),
        this.setState((n) => ({ ...n, connectors: t }));
    }
    getPublicClient({ chainId: e } = {}) {
      let t = this.publicClients.get(-1);
      if (
        (t && (t == null ? void 0 : t.chain.id) === e) ||
        ((t = this.publicClients.get(e ?? -1)), t)
      )
        return t;
      const { publicClient: n } = this.args;
      return (
        (t = typeof n == "function" ? n({ chainId: e }) : n),
        this.publicClients.set(e ?? -1, t),
        t
      );
    }
    setPublicClient(e) {
      var n, r;
      const t =
        (r = (n = this.data) == null ? void 0 : n.chain) == null
          ? void 0
          : r.id;
      (this.args = { ...this.args, publicClient: e }),
        this.publicClients.clear(),
        this.setState((i) => ({
          ...i,
          publicClient: this.getPublicClient({ chainId: t }),
        }));
    }
    getWebSocketPublicClient({ chainId: e } = {}) {
      let t = this.webSocketPublicClients.get(-1);
      if (
        (t && (t == null ? void 0 : t.chain.id) === e) ||
        ((t = this.webSocketPublicClients.get(e ?? -1)), t)
      )
        return t;
      const { webSocketPublicClient: n } = this.args;
      return (
        (t = typeof n == "function" ? n({ chainId: e }) : n),
        t && this.webSocketPublicClients.set(e ?? -1, t),
        t
      );
    }
    setWebSocketPublicClient(e) {
      var n, r;
      const t =
        (r = (n = this.data) == null ? void 0 : n.chain) == null
          ? void 0
          : r.id;
      (this.args = { ...this.args, webSocketPublicClient: e }),
        this.webSocketPublicClients.clear(),
        this.setState((i) => ({
          ...i,
          webSocketPublicClient: this.getWebSocketPublicClient({ chainId: t }),
        }));
    }
    setLastUsedConnector(e = null) {
      var t;
      (t = this.storage) == null || t.setItem("wallet", e);
    }
  };
Io = new WeakMap();
bu = new WeakMap();
Sy = new WeakSet();
eC = function () {
  const e = (a) => {
      this.setState((u) => ({ ...u, data: { ...u.data, ...a } }));
    },
    t = () => {
      this.clearState();
    },
    n = (a) => {
      this.setState((u) => ({ ...u, error: a }));
    };
  this.store.subscribe(
    ({ connector: a }) => a,
    (a, u) => {
      var l, c, d, f, p, m;
      (l = u == null ? void 0 : u.off) == null || l.call(u, "change", e),
        (c = u == null ? void 0 : u.off) == null || c.call(u, "disconnect", t),
        (d = u == null ? void 0 : u.off) == null || d.call(u, "error", n),
        a &&
          ((f = a.on) == null || f.call(a, "change", e),
          (p = a.on) == null || p.call(a, "disconnect", t),
          (m = a.on) == null || m.call(a, "error", n));
    }
  );
  const { publicClient: r, webSocketPublicClient: i } = this.args;
  (typeof r == "function" || typeof i == "function") &&
    this.store.subscribe(
      ({ data: a }) => {
        var u;
        return (u = a == null ? void 0 : a.chain) == null ? void 0 : u.id;
      },
      (a) => {
        this.setState((u) => ({
          ...u,
          publicClient: this.getPublicClient({ chainId: a }),
          webSocketPublicClient: this.getWebSocketPublicClient({ chainId: a }),
        }));
      }
    );
};
var Cy;
function s8(e) {
  const t = new i8(e);
  return (Cy = t), t;
}
function Dn() {
  if (!Cy)
    throw new Error(
      "No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config"
    );
  return Cy;
}
async function gE({ chainId: e, connector: t }) {
  const n = Dn(),
    r = n.connector;
  if (r && t.id === r.id) throw new YR();
  try {
    n.setState((s) => ({ ...s, status: "connecting" }));
    const i = await t.connect({ chainId: e });
    return (
      n.setLastUsedConnector(t.id),
      n.setState((s) => ({
        ...s,
        connector: t,
        chains: t == null ? void 0 : t.chains,
        data: i,
        status: "connected",
      })),
      n.storage.setItem("connected", !0),
      { ...i, connector: t }
    );
  } catch (i) {
    throw (
      (n.setState((s) => ({
        ...s,
        status: s.connector ? "connected" : "disconnected",
      })),
      i)
    );
  }
}
async function o8() {
  const e = Dn();
  e.connector && (await e.connector.disconnect()),
    e.clearState(),
    e.storage.removeItem("connected");
}
var a8 = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        { indexed: !0, name: "owner", type: "address" },
        { indexed: !0, name: "spender", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        { indexed: !0, name: "from", type: "address" },
        { indexed: !0, name: "to", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
    },
    {
      type: "function",
      name: "allowance",
      stateMutability: "view",
      inputs: [
        { name: "owner", type: "address" },
        { name: "spender", type: "address" },
      ],
      outputs: [{ name: "", type: "uint256" }],
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        { name: "spender", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [{ name: "account", type: "address" }],
      outputs: [{ name: "", type: "uint256" }],
    },
    {
      type: "function",
      name: "decimals",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "uint8" }],
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "string" }],
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "string" }],
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "uint256" }],
    },
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        { name: "sender", type: "address" },
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
  ],
  u8 = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        { indexed: !0, name: "owner", type: "address" },
        { indexed: !0, name: "spender", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        { indexed: !0, name: "from", type: "address" },
        { indexed: !0, name: "to", type: "address" },
        { indexed: !1, name: "value", type: "uint256" },
      ],
    },
    {
      type: "function",
      name: "allowance",
      stateMutability: "view",
      inputs: [
        { name: "owner", type: "address" },
        { name: "spender", type: "address" },
      ],
      outputs: [{ name: "", type: "uint256" }],
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        { name: "spender", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [{ name: "account", type: "address" }],
      outputs: [{ name: "", type: "uint256" }],
    },
    {
      type: "function",
      name: "decimals",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "uint8" }],
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "bytes32" }],
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "bytes32" }],
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [{ name: "", type: "uint256" }],
    },
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        { name: "sender", type: "address" },
        { name: "recipient", type: "address" },
        { name: "amount", type: "uint256" },
      ],
      outputs: [{ name: "", type: "bool" }],
    },
  ];
function Or({ chainId: e } = {}) {
  const t = Dn();
  return (e && t.getPublicClient({ chainId: e })) || t.publicClient;
}
async function tC({ chainId: e } = {}) {
  var r, i;
  return (
    (await ((i = (r = Dn().connector) == null ? void 0 : r.getWalletClient) ==
    null
      ? void 0
      : i.call(r, { chainId: e }))) || null
  );
}
function c8(e, t) {
  const n = Dn(),
    r = async () => t(Or(e));
  return n.subscribe(({ publicClient: s }) => s, r);
}
function l8({ chainId: e }, t) {
  const n = Dn(),
    r = async ({ chainId: s }) => {
      if (e && s && e !== s) return;
      const o = await tC({ chainId: e });
      return Dn().connector ? t(o) : t(null);
    };
  return n.subscribe(
    ({ data: s, connector: o }) => {
      var a;
      return {
        account: s == null ? void 0 : s.account,
        chainId: (a = s == null ? void 0 : s.chain) == null ? void 0 : a.id,
        connector: o,
      };
    },
    r,
    { equalityFn: hb }
  );
}
async function d8({
  chainId: e,
  contracts: t,
  blockNumber: n,
  blockTag: r,
  ...i
}) {
  const s = Or({ chainId: e });
  if (!s.chains) throw new XR();
  if (e && s.chain.id !== e) throw new JR({ chainId: e });
  return s.multicall({
    allowFailure: i.allowFailure ?? !0,
    blockNumber: n,
    blockTag: r,
    contracts: t,
  });
}
async function f8({
  address: e,
  account: t,
  chainId: n,
  abi: r,
  args: i,
  functionName: s,
  blockNumber: o,
  blockTag: a,
}) {
  return Or({ chainId: n }).readContract({
    abi: r,
    address: e,
    account: t,
    functionName: s,
    args: i,
    blockNumber: o,
    blockTag: a,
  });
}
async function h8({ contracts: e, blockNumber: t, blockTag: n, ...r }) {
  const { allowFailure: i = !0 } = r;
  try {
    const s = Or(),
      o = e.reduce((c, d, f) => {
        const p = d.chainId ?? s.chain.id;
        return { ...c, [p]: [...(c[p] || []), { contract: d, index: f }] };
      }, {}),
      a = () =>
        Object.entries(o).map(([c, d]) =>
          d8({
            allowFailure: i,
            chainId: parseInt(c),
            contracts: d.map(({ contract: f }) => f),
            blockNumber: t,
            blockTag: n,
          })
        ),
      u = (await Promise.all(a())).flat(),
      l = Object.values(o).flatMap((c) => c.map(({ index: d }) => d));
    return u.reduce((c, d, f) => (c && (c[l[f]] = d), c), []);
  } catch (s) {
    if (s instanceof Vv) throw s;
    const o = () => e.map((a) => f8({ ...a, blockNumber: t, blockTag: n }));
    return i
      ? (await Promise.allSettled(o())).map((a) =>
          a.status === "fulfilled"
            ? { result: a.value, status: "success" }
            : { error: a.reason, result: void 0, status: "failure" }
        )
      : await Promise.all(o());
  }
}
async function p8({ address: e, chainId: t, formatUnits: n, token: r }) {
  const i = Dn(),
    s = Or({ chainId: t });
  if (r) {
    const l = async ({ abi: c }) => {
      const d = { abi: c, address: r, chainId: t },
        [f, p, m] = await h8({
          allowFailure: !1,
          contracts: [
            { ...d, functionName: "balanceOf", args: [e] },
            { ...d, functionName: "decimals" },
            { ...d, functionName: "symbol" },
          ],
        });
      return {
        decimals: p,
        formatted: lf(f ?? "0", hE(n ?? p)),
        symbol: m,
        value: f,
      };
    };
    try {
      return await l({ abi: a8 });
    } catch (c) {
      if (c instanceof Vv) {
        const { symbol: d, ...f } = await l({ abi: u8 });
        return { symbol: jv(Hs(d, { dir: "right" })), ...f };
      }
      throw c;
    }
  }
  const o = [...(i.publicClient.chains || []), ...(i.chains ?? [])],
    a = await s.getBalance({ address: e }),
    u = o.find((l) => l.id === s.chain.id);
  return {
    decimals: (u == null ? void 0 : u.nativeCurrency.decimals) ?? 18,
    formatted: lf(a ?? "0", hE(n ?? 18)),
    symbol: (u == null ? void 0 : u.nativeCurrency.symbol) ?? "ETH",
    value: a,
  };
}
function pb() {
  const { data: e, connector: t, status: n } = Dn();
  switch (n) {
    case "connected":
      return {
        address: e == null ? void 0 : e.account,
        connector: t,
        isConnected: !0,
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !1,
        status: n,
      };
    case "reconnecting":
      return {
        address: e == null ? void 0 : e.account,
        connector: t,
        isConnected: !!(e != null && e.account),
        isConnecting: !1,
        isDisconnected: !1,
        isReconnecting: !0,
        status: n,
      };
    case "connecting":
      return {
        address: e == null ? void 0 : e.account,
        connector: t,
        isConnected: !1,
        isConnecting: !0,
        isDisconnected: !1,
        isReconnecting: !1,
        status: n,
      };
    case "disconnected":
      return {
        address: void 0,
        connector: void 0,
        isConnected: !1,
        isConnecting: !1,
        isDisconnected: !0,
        isReconnecting: !1,
        status: n,
      };
  }
}
function mb() {
  var i, s, o, a;
  const e = Dn(),
    t = (s = (i = e.data) == null ? void 0 : i.chain) == null ? void 0 : s.id,
    n = e.chains ?? [],
    r = [
      ...(((o = e.publicClient) == null ? void 0 : o.chains) || []),
      ...n,
    ].find((u) => u.id === t) ?? {
      id: t,
      name: `Chain ${t}`,
      network: `${t}`,
      nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
      rpcUrls: { default: { http: [""] }, public: { http: [""] } },
    };
  return {
    chain: t
      ? { ...r, ...((a = e.data) == null ? void 0 : a.chain), id: t }
      : void 0,
    chains: n,
  };
}
async function m8({ chainId: e }) {
  const { connector: t } = Dn();
  if (!t) throw new Ts();
  if (!t.switchChain) throw new e8({ connector: t });
  return t.switchChain(e);
}
function nC(e, { selector: t = (n) => n } = {}) {
  const n = Dn(),
    r = () => e(pb());
  return n.subscribe(
    ({ data: s, connector: o, status: a }) =>
      t({ address: s == null ? void 0 : s.account, connector: o, status: a }),
    r,
    { equalityFn: hb }
  );
}
function rC(e, { selector: t = (n) => n } = {}) {
  const n = Dn(),
    r = () => e(mb());
  return n.subscribe(
    ({ data: s, chains: o }) => {
      var a;
      return t({
        chainId: (a = s == null ? void 0 : s.chain) == null ? void 0 : a.id,
        chains: o,
      });
    },
    r,
    { equalityFn: hb }
  );
}
async function y8({ name: e, chainId: t }) {
  const { normalize: n } = await qh(
    () => import("./index-hX7qCKNp.js"),
    __vite__mapDeps([])
  );
  return await Or({ chainId: t }).getEnsAvatar({ name: n(e) });
}
async function g8({ address: e, chainId: t }) {
  return Or({ chainId: t }).getEnsName({ address: Yi(e) });
}
async function vE({
  chainId: e,
  confirmations: t = 1,
  hash: n,
  onReplaced: r,
  timeout: i = 0,
}) {
  const s = Or({ chainId: e }),
    o = await s.waitForTransactionReceipt({
      hash: n,
      confirmations: t,
      onReplaced: r,
      timeout: i,
    });
  if (o.status === "reverted") {
    const a = await s.getTransaction({ hash: o.transactionHash }),
      u = await s.call({
        ...a,
        gasPrice: a.type !== "eip1559" ? a.gasPrice : void 0,
        maxFeePerGas: a.type === "eip1559" ? a.maxFeePerGas : void 0,
        maxPriorityFeePerGas:
          a.type === "eip1559" ? a.maxPriorityFeePerGas : void 0,
      }),
      l = jv(`0x${u.substring(138)}`);
    throw new Error(l);
  }
  return o;
}
var v8 = {},
  Jh = {},
  pe = {},
  iC = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  function t(a, u) {
    var l = (a >>> 16) & 65535,
      c = a & 65535,
      d = (u >>> 16) & 65535,
      f = u & 65535;
    return (c * f + (((l * f + c * d) << 16) >>> 0)) | 0;
  }
  e.mul = Math.imul || t;
  function n(a, u) {
    return (a + u) | 0;
  }
  e.add = n;
  function r(a, u) {
    return (a - u) | 0;
  }
  e.sub = r;
  function i(a, u) {
    return (a << u) | (a >>> (32 - u));
  }
  e.rotl = i;
  function s(a, u) {
    return (a << (32 - u)) | (a >>> u);
  }
  e.rotr = s;
  function o(a) {
    return typeof a == "number" && isFinite(a) && Math.floor(a) === a;
  }
  (e.isInteger = Number.isInteger || o),
    (e.MAX_SAFE_INTEGER = 9007199254740991),
    (e.isSafeInteger = function (a) {
      return (
        e.isInteger(a) && a >= -e.MAX_SAFE_INTEGER && a <= e.MAX_SAFE_INTEGER
      );
    });
})(iC);
Object.defineProperty(pe, "__esModule", { value: !0 });
var sC = iC;
function b8(e, t) {
  return t === void 0 && (t = 0), (((e[t + 0] << 8) | e[t + 1]) << 16) >> 16;
}
pe.readInt16BE = b8;
function w8(e, t) {
  return t === void 0 && (t = 0), ((e[t + 0] << 8) | e[t + 1]) >>> 0;
}
pe.readUint16BE = w8;
function E8(e, t) {
  return t === void 0 && (t = 0), (((e[t + 1] << 8) | e[t]) << 16) >> 16;
}
pe.readInt16LE = E8;
function _8(e, t) {
  return t === void 0 && (t = 0), ((e[t + 1] << 8) | e[t]) >>> 0;
}
pe.readUint16LE = _8;
function oC(e, t, n) {
  return (
    t === void 0 && (t = new Uint8Array(2)),
    n === void 0 && (n = 0),
    (t[n + 0] = e >>> 8),
    (t[n + 1] = e >>> 0),
    t
  );
}
pe.writeUint16BE = oC;
pe.writeInt16BE = oC;
function aC(e, t, n) {
  return (
    t === void 0 && (t = new Uint8Array(2)),
    n === void 0 && (n = 0),
    (t[n + 0] = e >>> 0),
    (t[n + 1] = e >>> 8),
    t
  );
}
pe.writeUint16LE = aC;
pe.writeInt16LE = aC;
function Ty(e, t) {
  return (
    t === void 0 && (t = 0),
    (e[t] << 24) | (e[t + 1] << 16) | (e[t + 2] << 8) | e[t + 3]
  );
}
pe.readInt32BE = Ty;
function Iy(e, t) {
  return (
    t === void 0 && (t = 0),
    ((e[t] << 24) | (e[t + 1] << 16) | (e[t + 2] << 8) | e[t + 3]) >>> 0
  );
}
pe.readUint32BE = Iy;
function ky(e, t) {
  return (
    t === void 0 && (t = 0),
    (e[t + 3] << 24) | (e[t + 2] << 16) | (e[t + 1] << 8) | e[t]
  );
}
pe.readInt32LE = ky;
function Py(e, t) {
  return (
    t === void 0 && (t = 0),
    ((e[t + 3] << 24) | (e[t + 2] << 16) | (e[t + 1] << 8) | e[t]) >>> 0
  );
}
pe.readUint32LE = Py;
function yf(e, t, n) {
  return (
    t === void 0 && (t = new Uint8Array(4)),
    n === void 0 && (n = 0),
    (t[n + 0] = e >>> 24),
    (t[n + 1] = e >>> 16),
    (t[n + 2] = e >>> 8),
    (t[n + 3] = e >>> 0),
    t
  );
}
pe.writeUint32BE = yf;
pe.writeInt32BE = yf;
function gf(e, t, n) {
  return (
    t === void 0 && (t = new Uint8Array(4)),
    n === void 0 && (n = 0),
    (t[n + 0] = e >>> 0),
    (t[n + 1] = e >>> 8),
    (t[n + 2] = e >>> 16),
    (t[n + 3] = e >>> 24),
    t
  );
}
pe.writeUint32LE = gf;
pe.writeInt32LE = gf;
function A8(e, t) {
  t === void 0 && (t = 0);
  var n = Ty(e, t),
    r = Ty(e, t + 4);
  return n * 4294967296 + r - (r >> 31) * 4294967296;
}
pe.readInt64BE = A8;
function x8(e, t) {
  t === void 0 && (t = 0);
  var n = Iy(e, t),
    r = Iy(e, t + 4);
  return n * 4294967296 + r;
}
pe.readUint64BE = x8;
function S8(e, t) {
  t === void 0 && (t = 0);
  var n = ky(e, t),
    r = ky(e, t + 4);
  return r * 4294967296 + n - (n >> 31) * 4294967296;
}
pe.readInt64LE = S8;
function C8(e, t) {
  t === void 0 && (t = 0);
  var n = Py(e, t),
    r = Py(e, t + 4);
  return r * 4294967296 + n;
}
pe.readUint64LE = C8;
function uC(e, t, n) {
  return (
    t === void 0 && (t = new Uint8Array(8)),
    n === void 0 && (n = 0),
    yf((e / 4294967296) >>> 0, t, n),
    yf(e >>> 0, t, n + 4),
    t
  );
}
pe.writeUint64BE = uC;
pe.writeInt64BE = uC;
function cC(e, t, n) {
  return (
    t === void 0 && (t = new Uint8Array(8)),
    n === void 0 && (n = 0),
    gf(e >>> 0, t, n),
    gf((e / 4294967296) >>> 0, t, n + 4),
    t
  );
}
pe.writeUint64LE = cC;
pe.writeInt64LE = cC;
function T8(e, t, n) {
  if ((n === void 0 && (n = 0), e % 8 !== 0))
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - n)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = e / 8 + n - 1; s >= n; s--)
    (r += t[s] * i), (i *= 256);
  return r;
}
pe.readUintBE = T8;
function I8(e, t, n) {
  if ((n === void 0 && (n = 0), e % 8 !== 0))
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (e / 8 > t.length - n)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var r = 0, i = 1, s = n; s < n + e / 8; s++) (r += t[s] * i), (i *= 256);
  return r;
}
pe.readUintLE = I8;
function k8(e, t, n, r) {
  if (
    (n === void 0 && (n = new Uint8Array(e / 8)),
    r === void 0 && (r = 0),
    e % 8 !== 0)
  )
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!sC.isSafeInteger(t))
    throw new Error("writeUintBE value must be an integer");
  for (var i = 1, s = e / 8 + r - 1; s >= r; s--)
    (n[s] = (t / i) & 255), (i *= 256);
  return n;
}
pe.writeUintBE = k8;
function P8(e, t, n, r) {
  if (
    (n === void 0 && (n = new Uint8Array(e / 8)),
    r === void 0 && (r = 0),
    e % 8 !== 0)
  )
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!sC.isSafeInteger(t))
    throw new Error("writeUintLE value must be an integer");
  for (var i = 1, s = r; s < r + e / 8; s++) (n[s] = (t / i) & 255), (i *= 256);
  return n;
}
pe.writeUintLE = P8;
function D8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat32(t);
}
pe.readFloat32BE = D8;
function O8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat32(t, !0);
}
pe.readFloat32LE = O8;
function R8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat64(t);
}
pe.readFloat64BE = R8;
function B8(e, t) {
  t === void 0 && (t = 0);
  var n = new DataView(e.buffer, e.byteOffset, e.byteLength);
  return n.getFloat64(t, !0);
}
pe.readFloat64LE = B8;
function N8(e, t, n) {
  t === void 0 && (t = new Uint8Array(4)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat32(n, e), t;
}
pe.writeFloat32BE = N8;
function M8(e, t, n) {
  t === void 0 && (t = new Uint8Array(4)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat32(n, e, !0), t;
}
pe.writeFloat32LE = M8;
function L8(e, t, n) {
  t === void 0 && (t = new Uint8Array(8)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat64(n, e), t;
}
pe.writeFloat64BE = L8;
function F8(e, t, n) {
  t === void 0 && (t = new Uint8Array(8)), n === void 0 && (n = 0);
  var r = new DataView(t.buffer, t.byteOffset, t.byteLength);
  return r.setFloat64(n, e, !0), t;
}
pe.writeFloat64LE = F8;
var gr = {};
Object.defineProperty(gr, "__esModule", { value: !0 });
function j8(e) {
  for (var t = 0; t < e.length; t++) e[t] = 0;
  return e;
}
gr.wipe = j8;
Object.defineProperty(Jh, "__esModule", { value: !0 });
var qt = pe,
  Dy = gr,
  U8 = 20;
function $8(e, t, n) {
  for (
    var r = 1634760805,
      i = 857760878,
      s = 2036477234,
      o = 1797285236,
      a = (n[3] << 24) | (n[2] << 16) | (n[1] << 8) | n[0],
      u = (n[7] << 24) | (n[6] << 16) | (n[5] << 8) | n[4],
      l = (n[11] << 24) | (n[10] << 16) | (n[9] << 8) | n[8],
      c = (n[15] << 24) | (n[14] << 16) | (n[13] << 8) | n[12],
      d = (n[19] << 24) | (n[18] << 16) | (n[17] << 8) | n[16],
      f = (n[23] << 24) | (n[22] << 16) | (n[21] << 8) | n[20],
      p = (n[27] << 24) | (n[26] << 16) | (n[25] << 8) | n[24],
      m = (n[31] << 24) | (n[30] << 16) | (n[29] << 8) | n[28],
      g = (t[3] << 24) | (t[2] << 16) | (t[1] << 8) | t[0],
      w = (t[7] << 24) | (t[6] << 16) | (t[5] << 8) | t[4],
      v = (t[11] << 24) | (t[10] << 16) | (t[9] << 8) | t[8],
      y = (t[15] << 24) | (t[14] << 16) | (t[13] << 8) | t[12],
      b = r,
      _ = i,
      A = s,
      x = o,
      h = a,
      E = u,
      I = l,
      C = c,
      k = d,
      O = f,
      R = p,
      N = m,
      S = g,
      T = w,
      D = v,
      P = y,
      B = 0;
    B < U8;
    B += 2
  )
    (b = (b + h) | 0),
      (S ^= b),
      (S = (S >>> 16) | (S << 16)),
      (k = (k + S) | 0),
      (h ^= k),
      (h = (h >>> 20) | (h << 12)),
      (_ = (_ + E) | 0),
      (T ^= _),
      (T = (T >>> 16) | (T << 16)),
      (O = (O + T) | 0),
      (E ^= O),
      (E = (E >>> 20) | (E << 12)),
      (A = (A + I) | 0),
      (D ^= A),
      (D = (D >>> 16) | (D << 16)),
      (R = (R + D) | 0),
      (I ^= R),
      (I = (I >>> 20) | (I << 12)),
      (x = (x + C) | 0),
      (P ^= x),
      (P = (P >>> 16) | (P << 16)),
      (N = (N + P) | 0),
      (C ^= N),
      (C = (C >>> 20) | (C << 12)),
      (A = (A + I) | 0),
      (D ^= A),
      (D = (D >>> 24) | (D << 8)),
      (R = (R + D) | 0),
      (I ^= R),
      (I = (I >>> 25) | (I << 7)),
      (x = (x + C) | 0),
      (P ^= x),
      (P = (P >>> 24) | (P << 8)),
      (N = (N + P) | 0),
      (C ^= N),
      (C = (C >>> 25) | (C << 7)),
      (_ = (_ + E) | 0),
      (T ^= _),
      (T = (T >>> 24) | (T << 8)),
      (O = (O + T) | 0),
      (E ^= O),
      (E = (E >>> 25) | (E << 7)),
      (b = (b + h) | 0),
      (S ^= b),
      (S = (S >>> 24) | (S << 8)),
      (k = (k + S) | 0),
      (h ^= k),
      (h = (h >>> 25) | (h << 7)),
      (b = (b + E) | 0),
      (P ^= b),
      (P = (P >>> 16) | (P << 16)),
      (R = (R + P) | 0),
      (E ^= R),
      (E = (E >>> 20) | (E << 12)),
      (_ = (_ + I) | 0),
      (S ^= _),
      (S = (S >>> 16) | (S << 16)),
      (N = (N + S) | 0),
      (I ^= N),
      (I = (I >>> 20) | (I << 12)),
      (A = (A + C) | 0),
      (T ^= A),
      (T = (T >>> 16) | (T << 16)),
      (k = (k + T) | 0),
      (C ^= k),
      (C = (C >>> 20) | (C << 12)),
      (x = (x + h) | 0),
      (D ^= x),
      (D = (D >>> 16) | (D << 16)),
      (O = (O + D) | 0),
      (h ^= O),
      (h = (h >>> 20) | (h << 12)),
      (A = (A + C) | 0),
      (T ^= A),
      (T = (T >>> 24) | (T << 8)),
      (k = (k + T) | 0),
      (C ^= k),
      (C = (C >>> 25) | (C << 7)),
      (x = (x + h) | 0),
      (D ^= x),
      (D = (D >>> 24) | (D << 8)),
      (O = (O + D) | 0),
      (h ^= O),
      (h = (h >>> 25) | (h << 7)),
      (_ = (_ + I) | 0),
      (S ^= _),
      (S = (S >>> 24) | (S << 8)),
      (N = (N + S) | 0),
      (I ^= N),
      (I = (I >>> 25) | (I << 7)),
      (b = (b + E) | 0),
      (P ^= b),
      (P = (P >>> 24) | (P << 8)),
      (R = (R + P) | 0),
      (E ^= R),
      (E = (E >>> 25) | (E << 7));
  qt.writeUint32LE((b + r) | 0, e, 0),
    qt.writeUint32LE((_ + i) | 0, e, 4),
    qt.writeUint32LE((A + s) | 0, e, 8),
    qt.writeUint32LE((x + o) | 0, e, 12),
    qt.writeUint32LE((h + a) | 0, e, 16),
    qt.writeUint32LE((E + u) | 0, e, 20),
    qt.writeUint32LE((I + l) | 0, e, 24),
    qt.writeUint32LE((C + c) | 0, e, 28),
    qt.writeUint32LE((k + d) | 0, e, 32),
    qt.writeUint32LE((O + f) | 0, e, 36),
    qt.writeUint32LE((R + p) | 0, e, 40),
    qt.writeUint32LE((N + m) | 0, e, 44),
    qt.writeUint32LE((S + g) | 0, e, 48),
    qt.writeUint32LE((T + w) | 0, e, 52),
    qt.writeUint32LE((D + v) | 0, e, 56),
    qt.writeUint32LE((P + y) | 0, e, 60);
}
function lC(e, t, n, r, i) {
  if ((i === void 0 && (i = 0), e.length !== 32))
    throw new Error("ChaCha: key size must be 32 bytes");
  if (r.length < n.length)
    throw new Error("ChaCha: destination is shorter than source");
  var s, o;
  if (i === 0) {
    if (t.length !== 8 && t.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    (s = new Uint8Array(16)), (o = s.length - t.length), s.set(t, o);
  } else {
    if (t.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    (s = t), (o = i);
  }
  for (var a = new Uint8Array(64), u = 0; u < n.length; u += 64) {
    $8(a, s, e);
    for (var l = u; l < u + 64 && l < n.length; l++) r[l] = n[l] ^ a[l - u];
    z8(s, 0, o);
  }
  return Dy.wipe(a), i === 0 && Dy.wipe(s), r;
}
Jh.streamXOR = lC;
function H8(e, t, n, r) {
  return r === void 0 && (r = 0), Dy.wipe(n), lC(e, t, n, n, r);
}
Jh.stream = H8;
function z8(e, t, n) {
  for (var r = 1; n--; )
    (r = (r + (e[t] & 255)) | 0), (e[t] = r & 255), (r >>>= 8), t++;
  if (r > 0) throw new Error("ChaCha: counter overflow");
}
var dC = {},
  ys = {};
Object.defineProperty(ys, "__esModule", { value: !0 });
function G8(e, t, n) {
  return (~(e - 1) & t) | ((e - 1) & n);
}
ys.select = G8;
function q8(e, t) {
  return (((e | 0) - (t | 0) - 1) >>> 31) & 1;
}
ys.lessOrEqual = q8;
function fC(e, t) {
  if (e.length !== t.length) return 0;
  for (var n = 0, r = 0; r < e.length; r++) n |= e[r] ^ t[r];
  return 1 & ((n - 1) >>> 8);
}
ys.compare = fC;
function W8(e, t) {
  return e.length === 0 || t.length === 0 ? !1 : fC(e, t) !== 0;
}
ys.equal = W8;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = ys,
    n = gr;
  e.DIGEST_LENGTH = 16;
  var r = (function () {
    function o(a) {
      (this.digestLength = e.DIGEST_LENGTH),
        (this._buffer = new Uint8Array(16)),
        (this._r = new Uint16Array(10)),
        (this._h = new Uint16Array(10)),
        (this._pad = new Uint16Array(8)),
        (this._leftover = 0),
        (this._fin = 0),
        (this._finished = !1);
      var u = a[0] | (a[1] << 8);
      this._r[0] = u & 8191;
      var l = a[2] | (a[3] << 8);
      this._r[1] = ((u >>> 13) | (l << 3)) & 8191;
      var c = a[4] | (a[5] << 8);
      this._r[2] = ((l >>> 10) | (c << 6)) & 7939;
      var d = a[6] | (a[7] << 8);
      this._r[3] = ((c >>> 7) | (d << 9)) & 8191;
      var f = a[8] | (a[9] << 8);
      (this._r[4] = ((d >>> 4) | (f << 12)) & 255),
        (this._r[5] = (f >>> 1) & 8190);
      var p = a[10] | (a[11] << 8);
      this._r[6] = ((f >>> 14) | (p << 2)) & 8191;
      var m = a[12] | (a[13] << 8);
      this._r[7] = ((p >>> 11) | (m << 5)) & 8065;
      var g = a[14] | (a[15] << 8);
      (this._r[8] = ((m >>> 8) | (g << 8)) & 8191),
        (this._r[9] = (g >>> 5) & 127),
        (this._pad[0] = a[16] | (a[17] << 8)),
        (this._pad[1] = a[18] | (a[19] << 8)),
        (this._pad[2] = a[20] | (a[21] << 8)),
        (this._pad[3] = a[22] | (a[23] << 8)),
        (this._pad[4] = a[24] | (a[25] << 8)),
        (this._pad[5] = a[26] | (a[27] << 8)),
        (this._pad[6] = a[28] | (a[29] << 8)),
        (this._pad[7] = a[30] | (a[31] << 8));
    }
    return (
      (o.prototype._blocks = function (a, u, l) {
        for (
          var c = this._fin ? 0 : 2048,
            d = this._h[0],
            f = this._h[1],
            p = this._h[2],
            m = this._h[3],
            g = this._h[4],
            w = this._h[5],
            v = this._h[6],
            y = this._h[7],
            b = this._h[8],
            _ = this._h[9],
            A = this._r[0],
            x = this._r[1],
            h = this._r[2],
            E = this._r[3],
            I = this._r[4],
            C = this._r[5],
            k = this._r[6],
            O = this._r[7],
            R = this._r[8],
            N = this._r[9];
          l >= 16;

        ) {
          var S = a[u + 0] | (a[u + 1] << 8);
          d += S & 8191;
          var T = a[u + 2] | (a[u + 3] << 8);
          f += ((S >>> 13) | (T << 3)) & 8191;
          var D = a[u + 4] | (a[u + 5] << 8);
          p += ((T >>> 10) | (D << 6)) & 8191;
          var P = a[u + 6] | (a[u + 7] << 8);
          m += ((D >>> 7) | (P << 9)) & 8191;
          var B = a[u + 8] | (a[u + 9] << 8);
          (g += ((P >>> 4) | (B << 12)) & 8191), (w += (B >>> 1) & 8191);
          var L = a[u + 10] | (a[u + 11] << 8);
          v += ((B >>> 14) | (L << 2)) & 8191;
          var Q = a[u + 12] | (a[u + 13] << 8);
          y += ((L >>> 11) | (Q << 5)) & 8191;
          var z = a[u + 14] | (a[u + 15] << 8);
          (b += ((Q >>> 8) | (z << 8)) & 8191), (_ += (z >>> 5) | c);
          var j = 0,
            W = j;
          (W += d * A),
            (W += f * (5 * N)),
            (W += p * (5 * R)),
            (W += m * (5 * O)),
            (W += g * (5 * k)),
            (j = W >>> 13),
            (W &= 8191),
            (W += w * (5 * C)),
            (W += v * (5 * I)),
            (W += y * (5 * E)),
            (W += b * (5 * h)),
            (W += _ * (5 * x)),
            (j += W >>> 13),
            (W &= 8191);
          var ee = j;
          (ee += d * x),
            (ee += f * A),
            (ee += p * (5 * N)),
            (ee += m * (5 * R)),
            (ee += g * (5 * O)),
            (j = ee >>> 13),
            (ee &= 8191),
            (ee += w * (5 * k)),
            (ee += v * (5 * C)),
            (ee += y * (5 * I)),
            (ee += b * (5 * E)),
            (ee += _ * (5 * h)),
            (j += ee >>> 13),
            (ee &= 8191);
          var Z = j;
          (Z += d * h),
            (Z += f * x),
            (Z += p * A),
            (Z += m * (5 * N)),
            (Z += g * (5 * R)),
            (j = Z >>> 13),
            (Z &= 8191),
            (Z += w * (5 * O)),
            (Z += v * (5 * k)),
            (Z += y * (5 * C)),
            (Z += b * (5 * I)),
            (Z += _ * (5 * E)),
            (j += Z >>> 13),
            (Z &= 8191);
          var ne = j;
          (ne += d * E),
            (ne += f * h),
            (ne += p * x),
            (ne += m * A),
            (ne += g * (5 * N)),
            (j = ne >>> 13),
            (ne &= 8191),
            (ne += w * (5 * R)),
            (ne += v * (5 * O)),
            (ne += y * (5 * k)),
            (ne += b * (5 * C)),
            (ne += _ * (5 * I)),
            (j += ne >>> 13),
            (ne &= 8191);
          var Ae = j;
          (Ae += d * I),
            (Ae += f * E),
            (Ae += p * h),
            (Ae += m * x),
            (Ae += g * A),
            (j = Ae >>> 13),
            (Ae &= 8191),
            (Ae += w * (5 * N)),
            (Ae += v * (5 * R)),
            (Ae += y * (5 * O)),
            (Ae += b * (5 * k)),
            (Ae += _ * (5 * C)),
            (j += Ae >>> 13),
            (Ae &= 8191);
          var de = j;
          (de += d * C),
            (de += f * I),
            (de += p * E),
            (de += m * h),
            (de += g * x),
            (j = de >>> 13),
            (de &= 8191),
            (de += w * A),
            (de += v * (5 * N)),
            (de += y * (5 * R)),
            (de += b * (5 * O)),
            (de += _ * (5 * k)),
            (j += de >>> 13),
            (de &= 8191);
          var ge = j;
          (ge += d * k),
            (ge += f * C),
            (ge += p * I),
            (ge += m * E),
            (ge += g * h),
            (j = ge >>> 13),
            (ge &= 8191),
            (ge += w * x),
            (ge += v * A),
            (ge += y * (5 * N)),
            (ge += b * (5 * R)),
            (ge += _ * (5 * O)),
            (j += ge >>> 13),
            (ge &= 8191);
          var Oe = j;
          (Oe += d * O),
            (Oe += f * k),
            (Oe += p * C),
            (Oe += m * I),
            (Oe += g * E),
            (j = Oe >>> 13),
            (Oe &= 8191),
            (Oe += w * h),
            (Oe += v * x),
            (Oe += y * A),
            (Oe += b * (5 * N)),
            (Oe += _ * (5 * R)),
            (j += Oe >>> 13),
            (Oe &= 8191);
          var Ie = j;
          (Ie += d * R),
            (Ie += f * O),
            (Ie += p * k),
            (Ie += m * C),
            (Ie += g * I),
            (j = Ie >>> 13),
            (Ie &= 8191),
            (Ie += w * E),
            (Ie += v * h),
            (Ie += y * x),
            (Ie += b * A),
            (Ie += _ * (5 * N)),
            (j += Ie >>> 13),
            (Ie &= 8191);
          var we = j;
          (we += d * N),
            (we += f * R),
            (we += p * O),
            (we += m * k),
            (we += g * C),
            (j = we >>> 13),
            (we &= 8191),
            (we += w * I),
            (we += v * E),
            (we += y * h),
            (we += b * x),
            (we += _ * A),
            (j += we >>> 13),
            (we &= 8191),
            (j = ((j << 2) + j) | 0),
            (j = (j + W) | 0),
            (W = j & 8191),
            (j = j >>> 13),
            (ee += j),
            (d = W),
            (f = ee),
            (p = Z),
            (m = ne),
            (g = Ae),
            (w = de),
            (v = ge),
            (y = Oe),
            (b = Ie),
            (_ = we),
            (u += 16),
            (l -= 16);
        }
        (this._h[0] = d),
          (this._h[1] = f),
          (this._h[2] = p),
          (this._h[3] = m),
          (this._h[4] = g),
          (this._h[5] = w),
          (this._h[6] = v),
          (this._h[7] = y),
          (this._h[8] = b),
          (this._h[9] = _);
      }),
      (o.prototype.finish = function (a, u) {
        u === void 0 && (u = 0);
        var l = new Uint16Array(10),
          c,
          d,
          f,
          p;
        if (this._leftover) {
          for (p = this._leftover, this._buffer[p++] = 1; p < 16; p++)
            this._buffer[p] = 0;
          (this._fin = 1), this._blocks(this._buffer, 0, 16);
        }
        for (c = this._h[1] >>> 13, this._h[1] &= 8191, p = 2; p < 10; p++)
          (this._h[p] += c), (c = this._h[p] >>> 13), (this._h[p] &= 8191);
        for (
          this._h[0] += c * 5,
            c = this._h[0] >>> 13,
            this._h[0] &= 8191,
            this._h[1] += c,
            c = this._h[1] >>> 13,
            this._h[1] &= 8191,
            this._h[2] += c,
            l[0] = this._h[0] + 5,
            c = l[0] >>> 13,
            l[0] &= 8191,
            p = 1;
          p < 10;
          p++
        )
          (l[p] = this._h[p] + c), (c = l[p] >>> 13), (l[p] &= 8191);
        for (l[9] -= 8192, d = (c ^ 1) - 1, p = 0; p < 10; p++) l[p] &= d;
        for (d = ~d, p = 0; p < 10; p++) this._h[p] = (this._h[p] & d) | l[p];
        for (
          this._h[0] = (this._h[0] | (this._h[1] << 13)) & 65535,
            this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 65535,
            this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 65535,
            this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 65535,
            this._h[4] =
              ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) &
              65535,
            this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 65535,
            this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 65535,
            this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 65535,
            f = this._h[0] + this._pad[0],
            this._h[0] = f & 65535,
            p = 1;
          p < 8;
          p++
        )
          (f = (((this._h[p] + this._pad[p]) | 0) + (f >>> 16)) | 0),
            (this._h[p] = f & 65535);
        return (
          (a[u + 0] = this._h[0] >>> 0),
          (a[u + 1] = this._h[0] >>> 8),
          (a[u + 2] = this._h[1] >>> 0),
          (a[u + 3] = this._h[1] >>> 8),
          (a[u + 4] = this._h[2] >>> 0),
          (a[u + 5] = this._h[2] >>> 8),
          (a[u + 6] = this._h[3] >>> 0),
          (a[u + 7] = this._h[3] >>> 8),
          (a[u + 8] = this._h[4] >>> 0),
          (a[u + 9] = this._h[4] >>> 8),
          (a[u + 10] = this._h[5] >>> 0),
          (a[u + 11] = this._h[5] >>> 8),
          (a[u + 12] = this._h[6] >>> 0),
          (a[u + 13] = this._h[6] >>> 8),
          (a[u + 14] = this._h[7] >>> 0),
          (a[u + 15] = this._h[7] >>> 8),
          (this._finished = !0),
          this
        );
      }),
      (o.prototype.update = function (a) {
        var u = 0,
          l = a.length,
          c;
        if (this._leftover) {
          (c = 16 - this._leftover), c > l && (c = l);
          for (var d = 0; d < c; d++)
            this._buffer[this._leftover + d] = a[u + d];
          if (((l -= c), (u += c), (this._leftover += c), this._leftover < 16))
            return this;
          this._blocks(this._buffer, 0, 16), (this._leftover = 0);
        }
        if (
          (l >= 16 &&
            ((c = l - (l % 16)), this._blocks(a, u, c), (u += c), (l -= c)),
          l)
        ) {
          for (var d = 0; d < l; d++)
            this._buffer[this._leftover + d] = a[u + d];
          this._leftover += l;
        }
        return this;
      }),
      (o.prototype.digest = function () {
        if (this._finished) throw new Error("Poly1305 was finished");
        var a = new Uint8Array(16);
        return this.finish(a), a;
      }),
      (o.prototype.clean = function () {
        return (
          n.wipe(this._buffer),
          n.wipe(this._r),
          n.wipe(this._h),
          n.wipe(this._pad),
          (this._leftover = 0),
          (this._fin = 0),
          (this._finished = !0),
          this
        );
      }),
      o
    );
  })();
  e.Poly1305 = r;
  function i(o, a) {
    var u = new r(o);
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  e.oneTimeAuth = i;
  function s(o, a) {
    return o.length !== e.DIGEST_LENGTH || a.length !== e.DIGEST_LENGTH
      ? !1
      : t.equal(o, a);
  }
  e.equal = s;
})(dC);
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = Jh,
    n = dC,
    r = gr,
    i = pe,
    s = ys;
  (e.KEY_LENGTH = 32), (e.NONCE_LENGTH = 12), (e.TAG_LENGTH = 16);
  var o = new Uint8Array(16),
    a = (function () {
      function u(l) {
        if (
          ((this.nonceLength = e.NONCE_LENGTH),
          (this.tagLength = e.TAG_LENGTH),
          l.length !== e.KEY_LENGTH)
        )
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(l);
      }
      return (
        (u.prototype.seal = function (l, c, d, f) {
          if (l.length > 16)
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          var p = new Uint8Array(16);
          p.set(l, p.length - l.length);
          var m = new Uint8Array(32);
          t.stream(this._key, p, m, 4);
          var g = c.length + this.tagLength,
            w;
          if (f) {
            if (f.length !== g)
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            w = f;
          } else w = new Uint8Array(g);
          return (
            t.streamXOR(this._key, p, c, w, 4),
            this._authenticate(
              w.subarray(w.length - this.tagLength, w.length),
              m,
              w.subarray(0, w.length - this.tagLength),
              d
            ),
            r.wipe(p),
            w
          );
        }),
        (u.prototype.open = function (l, c, d, f) {
          if (l.length > 16)
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          if (c.length < this.tagLength) return null;
          var p = new Uint8Array(16);
          p.set(l, p.length - l.length);
          var m = new Uint8Array(32);
          t.stream(this._key, p, m, 4);
          var g = new Uint8Array(this.tagLength);
          if (
            (this._authenticate(
              g,
              m,
              c.subarray(0, c.length - this.tagLength),
              d
            ),
            !s.equal(g, c.subarray(c.length - this.tagLength, c.length)))
          )
            return null;
          var w = c.length - this.tagLength,
            v;
          if (f) {
            if (f.length !== w)
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            v = f;
          } else v = new Uint8Array(w);
          return (
            t.streamXOR(
              this._key,
              p,
              c.subarray(0, c.length - this.tagLength),
              v,
              4
            ),
            r.wipe(p),
            v
          );
        }),
        (u.prototype.clean = function () {
          return r.wipe(this._key), this;
        }),
        (u.prototype._authenticate = function (l, c, d, f) {
          var p = new n.Poly1305(c);
          f &&
            (p.update(f),
            f.length % 16 > 0 && p.update(o.subarray(f.length % 16))),
            p.update(d),
            d.length % 16 > 0 && p.update(o.subarray(d.length % 16));
          var m = new Uint8Array(8);
          f && i.writeUint64LE(f.length, m),
            p.update(m),
            i.writeUint64LE(d.length, m),
            p.update(m);
          for (var g = p.digest(), w = 0; w < g.length; w++) l[w] = g[w];
          p.clean(), r.wipe(g), r.wipe(m);
        }),
        u
      );
    })();
  e.ChaCha20Poly1305 = a;
})(v8);
var hC = {},
  hl = {},
  yb = {};
Object.defineProperty(yb, "__esModule", { value: !0 });
function Q8(e) {
  return (
    typeof e.saveState < "u" &&
    typeof e.restoreState < "u" &&
    typeof e.cleanSavedState < "u"
  );
}
yb.isSerializableHash = Q8;
Object.defineProperty(hl, "__esModule", { value: !0 });
var br = yb,
  V8 = ys,
  K8 = gr,
  pC = (function () {
    function e(t, n) {
      (this._finished = !1),
        (this._inner = new t()),
        (this._outer = new t()),
        (this.blockSize = this._outer.blockSize),
        (this.digestLength = this._outer.digestLength);
      var r = new Uint8Array(this.blockSize);
      n.length > this.blockSize
        ? this._inner.update(n).finish(r).clean()
        : r.set(n);
      for (var i = 0; i < r.length; i++) r[i] ^= 54;
      this._inner.update(r);
      for (var i = 0; i < r.length; i++) r[i] ^= 106;
      this._outer.update(r),
        br.isSerializableHash(this._inner) &&
          br.isSerializableHash(this._outer) &&
          ((this._innerKeyedState = this._inner.saveState()),
          (this._outerKeyedState = this._outer.saveState())),
        K8.wipe(r);
    }
    return (
      (e.prototype.reset = function () {
        if (
          !br.isSerializableHash(this._inner) ||
          !br.isSerializableHash(this._outer)
        )
          throw new Error(
            "hmac: can't reset() because hash doesn't implement restoreState()"
          );
        return (
          this._inner.restoreState(this._innerKeyedState),
          this._outer.restoreState(this._outerKeyedState),
          (this._finished = !1),
          this
        );
      }),
      (e.prototype.clean = function () {
        br.isSerializableHash(this._inner) &&
          this._inner.cleanSavedState(this._innerKeyedState),
          br.isSerializableHash(this._outer) &&
            this._outer.cleanSavedState(this._outerKeyedState),
          this._inner.clean(),
          this._outer.clean();
      }),
      (e.prototype.update = function (t) {
        return this._inner.update(t), this;
      }),
      (e.prototype.finish = function (t) {
        return this._finished
          ? (this._outer.finish(t), this)
          : (this._inner.finish(t),
            this._outer.update(t.subarray(0, this.digestLength)).finish(t),
            (this._finished = !0),
            this);
      }),
      (e.prototype.digest = function () {
        var t = new Uint8Array(this.digestLength);
        return this.finish(t), t;
      }),
      (e.prototype.saveState = function () {
        if (!br.isSerializableHash(this._inner))
          throw new Error(
            "hmac: can't saveState() because hash doesn't implement it"
          );
        return this._inner.saveState();
      }),
      (e.prototype.restoreState = function (t) {
        if (
          !br.isSerializableHash(this._inner) ||
          !br.isSerializableHash(this._outer)
        )
          throw new Error(
            "hmac: can't restoreState() because hash doesn't implement it"
          );
        return (
          this._inner.restoreState(t),
          this._outer.restoreState(this._outerKeyedState),
          (this._finished = !1),
          this
        );
      }),
      (e.prototype.cleanSavedState = function (t) {
        if (!br.isSerializableHash(this._inner))
          throw new Error(
            "hmac: can't cleanSavedState() because hash doesn't implement it"
          );
        this._inner.cleanSavedState(t);
      }),
      e
    );
  })();
hl.HMAC = pC;
function Z8(e, t, n) {
  var r = new pC(e, t);
  r.update(n);
  var i = r.digest();
  return r.clean(), i;
}
hl.hmac = Z8;
hl.equal = V8.equal;
Object.defineProperty(hC, "__esModule", { value: !0 });
var bE = hl,
  wE = gr,
  J8 = (function () {
    function e(t, n, r, i) {
      r === void 0 && (r = new Uint8Array(0)),
        (this._counter = new Uint8Array(1)),
        (this._hash = t),
        (this._info = i);
      var s = bE.hmac(this._hash, r, n);
      (this._hmac = new bE.HMAC(t, s)),
        (this._buffer = new Uint8Array(this._hmac.digestLength)),
        (this._bufpos = this._buffer.length);
    }
    return (
      (e.prototype._fillBuffer = function () {
        this._counter[0]++;
        var t = this._counter[0];
        if (t === 0) throw new Error("hkdf: cannot expand more");
        this._hmac.reset(),
          t > 1 && this._hmac.update(this._buffer),
          this._info && this._hmac.update(this._info),
          this._hmac.update(this._counter),
          this._hmac.finish(this._buffer),
          (this._bufpos = 0);
      }),
      (e.prototype.expand = function (t) {
        for (var n = new Uint8Array(t), r = 0; r < n.length; r++)
          this._bufpos === this._buffer.length && this._fillBuffer(),
            (n[r] = this._buffer[this._bufpos++]);
        return n;
      }),
      (e.prototype.clean = function () {
        this._hmac.clean(),
          wE.wipe(this._buffer),
          wE.wipe(this._counter),
          (this._bufpos = 0);
      }),
      e
    );
  })(),
  KV = (hC.HKDF = J8),
  mC = {},
  Yh = {},
  Xh = {};
Object.defineProperty(Xh, "__esModule", { value: !0 });
Xh.BrowserRandomSource = void 0;
const EE = 65536;
class Y8 {
  constructor() {
    (this.isAvailable = !1), (this.isInstantiated = !1);
    const t = typeof self < "u" ? self.crypto || self.msCrypto : null;
    t &&
      t.getRandomValues !== void 0 &&
      ((this._crypto = t), (this.isAvailable = !0), (this.isInstantiated = !0));
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const n = new Uint8Array(t);
    for (let r = 0; r < n.length; r += EE)
      this._crypto.getRandomValues(
        n.subarray(r, r + Math.min(n.length - r, EE))
      );
    return n;
  }
}
Xh.BrowserRandomSource = Y8;
function X8(e) {
  throw new Error(
    'Could not dynamically require "' +
      e +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  );
}
var ep = {};
const eB = {},
  tB = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: eB },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  nB = R2(tB);
Object.defineProperty(ep, "__esModule", { value: !0 });
ep.NodeRandomSource = void 0;
const rB = gr;
class iB {
  constructor() {
    if (
      ((this.isAvailable = !1), (this.isInstantiated = !1), typeof X8 < "u")
    ) {
      const t = nB;
      t &&
        t.randomBytes &&
        ((this._crypto = t),
        (this.isAvailable = !0),
        (this.isInstantiated = !0));
    }
  }
  randomBytes(t) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let n = this._crypto.randomBytes(t);
    if (n.length !== t)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const r = new Uint8Array(t);
    for (let i = 0; i < r.length; i++) r[i] = n[i];
    return (0, rB.wipe)(n), r;
  }
}
ep.NodeRandomSource = iB;
Object.defineProperty(Yh, "__esModule", { value: !0 });
Yh.SystemRandomSource = void 0;
const sB = Xh,
  oB = ep;
class aB {
  constructor() {
    if (
      ((this.isAvailable = !1),
      (this.name = ""),
      (this._source = new sB.BrowserRandomSource()),
      this._source.isAvailable)
    ) {
      (this.isAvailable = !0), (this.name = "Browser");
      return;
    }
    if (
      ((this._source = new oB.NodeRandomSource()), this._source.isAvailable)
    ) {
      (this.isAvailable = !0), (this.name = "Node");
      return;
    }
  }
  randomBytes(t) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(t);
  }
}
Yh.SystemRandomSource = aB;
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.randomStringForEntropy =
      e.randomString =
      e.randomUint32 =
      e.randomBytes =
      e.defaultRandomSource =
        void 0);
  const t = Yh,
    n = pe,
    r = gr;
  e.defaultRandomSource = new t.SystemRandomSource();
  function i(l, c = e.defaultRandomSource) {
    return c.randomBytes(l);
  }
  e.randomBytes = i;
  function s(l = e.defaultRandomSource) {
    const c = i(4, l),
      d = (0, n.readUint32LE)(c);
    return (0, r.wipe)(c), d;
  }
  e.randomUint32 = s;
  const o = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function a(l, c = o, d = e.defaultRandomSource) {
    if (c.length < 2) throw new Error("randomString charset is too short");
    if (c.length > 256) throw new Error("randomString charset is too long");
    let f = "";
    const p = c.length,
      m = 256 - (256 % p);
    for (; l > 0; ) {
      const g = i(Math.ceil((l * 256) / m), d);
      for (let w = 0; w < g.length && l > 0; w++) {
        const v = g[w];
        v < m && ((f += c.charAt(v % p)), l--);
      }
      (0, r.wipe)(g);
    }
    return f;
  }
  e.randomString = a;
  function u(l, c = o, d = e.defaultRandomSource) {
    const f = Math.ceil(l / (Math.log(c.length) / Math.LN2));
    return a(f, c, d);
  }
  e.randomStringForEntropy = u;
})(mC);
var uB = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  var t = pe,
    n = gr;
  (e.DIGEST_LENGTH = 32), (e.BLOCK_SIZE = 64);
  var r = (function () {
    function a() {
      (this.digestLength = e.DIGEST_LENGTH),
        (this.blockSize = e.BLOCK_SIZE),
        (this._state = new Int32Array(8)),
        (this._temp = new Int32Array(64)),
        (this._buffer = new Uint8Array(128)),
        (this._bufferLength = 0),
        (this._bytesHashed = 0),
        (this._finished = !1),
        this.reset();
    }
    return (
      (a.prototype._initState = function () {
        (this._state[0] = 1779033703),
          (this._state[1] = 3144134277),
          (this._state[2] = 1013904242),
          (this._state[3] = 2773480762),
          (this._state[4] = 1359893119),
          (this._state[5] = 2600822924),
          (this._state[6] = 528734635),
          (this._state[7] = 1541459225);
      }),
      (a.prototype.reset = function () {
        return (
          this._initState(),
          (this._bufferLength = 0),
          (this._bytesHashed = 0),
          (this._finished = !1),
          this
        );
      }),
      (a.prototype.clean = function () {
        n.wipe(this._buffer), n.wipe(this._temp), this.reset();
      }),
      (a.prototype.update = function (u, l) {
        if ((l === void 0 && (l = u.length), this._finished))
          throw new Error("SHA256: can't update because hash was finished.");
        var c = 0;
        if (((this._bytesHashed += l), this._bufferLength > 0)) {
          for (; this._bufferLength < this.blockSize && l > 0; )
            (this._buffer[this._bufferLength++] = u[c++]), l--;
          this._bufferLength === this.blockSize &&
            (s(this._temp, this._state, this._buffer, 0, this.blockSize),
            (this._bufferLength = 0));
        }
        for (
          l >= this.blockSize &&
          ((c = s(this._temp, this._state, u, c, l)), (l %= this.blockSize));
          l > 0;

        )
          (this._buffer[this._bufferLength++] = u[c++]), l--;
        return this;
      }),
      (a.prototype.finish = function (u) {
        if (!this._finished) {
          var l = this._bytesHashed,
            c = this._bufferLength,
            d = (l / 536870912) | 0,
            f = l << 3,
            p = l % 64 < 56 ? 64 : 128;
          this._buffer[c] = 128;
          for (var m = c + 1; m < p - 8; m++) this._buffer[m] = 0;
          t.writeUint32BE(d, this._buffer, p - 8),
            t.writeUint32BE(f, this._buffer, p - 4),
            s(this._temp, this._state, this._buffer, 0, p),
            (this._finished = !0);
        }
        for (var m = 0; m < this.digestLength / 4; m++)
          t.writeUint32BE(this._state[m], u, m * 4);
        return this;
      }),
      (a.prototype.digest = function () {
        var u = new Uint8Array(this.digestLength);
        return this.finish(u), u;
      }),
      (a.prototype.saveState = function () {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer:
            this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed,
        };
      }),
      (a.prototype.restoreState = function (u) {
        return (
          this._state.set(u.state),
          (this._bufferLength = u.bufferLength),
          u.buffer && this._buffer.set(u.buffer),
          (this._bytesHashed = u.bytesHashed),
          (this._finished = !1),
          this
        );
      }),
      (a.prototype.cleanSavedState = function (u) {
        n.wipe(u.state),
          u.buffer && n.wipe(u.buffer),
          (u.bufferLength = 0),
          (u.bytesHashed = 0);
      }),
      a
    );
  })();
  e.SHA256 = r;
  var i = new Int32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]);
  function s(a, u, l, c, d) {
    for (; d >= 64; ) {
      for (
        var f = u[0],
          p = u[1],
          m = u[2],
          g = u[3],
          w = u[4],
          v = u[5],
          y = u[6],
          b = u[7],
          _ = 0;
        _ < 16;
        _++
      ) {
        var A = c + _ * 4;
        a[_] = t.readUint32BE(l, A);
      }
      for (var _ = 16; _ < 64; _++) {
        var x = a[_ - 2],
          h = ((x >>> 17) | (x << 15)) ^ ((x >>> 19) | (x << 13)) ^ (x >>> 10);
        x = a[_ - 15];
        var E = ((x >>> 7) | (x << 25)) ^ ((x >>> 18) | (x << 14)) ^ (x >>> 3);
        a[_] = ((h + a[_ - 7]) | 0) + ((E + a[_ - 16]) | 0);
      }
      for (var _ = 0; _ < 64; _++) {
        var h =
            ((((((w >>> 6) | (w << 26)) ^
              ((w >>> 11) | (w << 21)) ^
              ((w >>> 25) | (w << 7))) +
              ((w & v) ^ (~w & y))) |
              0) +
              ((b + ((i[_] + a[_]) | 0)) | 0)) |
            0,
          E =
            ((((f >>> 2) | (f << 30)) ^
              ((f >>> 13) | (f << 19)) ^
              ((f >>> 22) | (f << 10))) +
              ((f & p) ^ (f & m) ^ (p & m))) |
            0;
        (b = y),
          (y = v),
          (v = w),
          (w = (g + h) | 0),
          (g = m),
          (m = p),
          (p = f),
          (f = (h + E) | 0);
      }
      (u[0] += f),
        (u[1] += p),
        (u[2] += m),
        (u[3] += g),
        (u[4] += w),
        (u[5] += v),
        (u[6] += y),
        (u[7] += b),
        (c += 64),
        (d -= 64);
    }
    return c;
  }
  function o(a) {
    var u = new r();
    u.update(a);
    var l = u.digest();
    return u.clean(), l;
  }
  e.hash = o;
})(uB);
var cB = {};
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.sharedKey =
      e.generateKeyPair =
      e.generateKeyPairFromSeed =
      e.scalarMultBase =
      e.scalarMult =
      e.SHARED_KEY_LENGTH =
      e.SECRET_KEY_LENGTH =
      e.PUBLIC_KEY_LENGTH =
        void 0);
  const t = mC,
    n = gr;
  (e.PUBLIC_KEY_LENGTH = 32),
    (e.SECRET_KEY_LENGTH = 32),
    (e.SHARED_KEY_LENGTH = 32);
  function r(_) {
    const A = new Float64Array(16);
    if (_) for (let x = 0; x < _.length; x++) A[x] = _[x];
    return A;
  }
  const i = new Uint8Array(32);
  i[0] = 9;
  const s = r([56129, 1]);
  function o(_) {
    let A = 1;
    for (let x = 0; x < 16; x++) {
      let h = _[x] + A + 65535;
      (A = Math.floor(h / 65536)), (_[x] = h - A * 65536);
    }
    _[0] += A - 1 + 37 * (A - 1);
  }
  function a(_, A, x) {
    const h = ~(x - 1);
    for (let E = 0; E < 16; E++) {
      const I = h & (_[E] ^ A[E]);
      (_[E] ^= I), (A[E] ^= I);
    }
  }
  function u(_, A) {
    const x = r(),
      h = r();
    for (let E = 0; E < 16; E++) h[E] = A[E];
    o(h), o(h), o(h);
    for (let E = 0; E < 2; E++) {
      x[0] = h[0] - 65517;
      for (let C = 1; C < 15; C++)
        (x[C] = h[C] - 65535 - ((x[C - 1] >> 16) & 1)), (x[C - 1] &= 65535);
      x[15] = h[15] - 32767 - ((x[14] >> 16) & 1);
      const I = (x[15] >> 16) & 1;
      (x[14] &= 65535), a(h, x, 1 - I);
    }
    for (let E = 0; E < 16; E++)
      (_[2 * E] = h[E] & 255), (_[2 * E + 1] = h[E] >> 8);
  }
  function l(_, A) {
    for (let x = 0; x < 16; x++) _[x] = A[2 * x] + (A[2 * x + 1] << 8);
    _[15] &= 32767;
  }
  function c(_, A, x) {
    for (let h = 0; h < 16; h++) _[h] = A[h] + x[h];
  }
  function d(_, A, x) {
    for (let h = 0; h < 16; h++) _[h] = A[h] - x[h];
  }
  function f(_, A, x) {
    let h,
      E,
      I = 0,
      C = 0,
      k = 0,
      O = 0,
      R = 0,
      N = 0,
      S = 0,
      T = 0,
      D = 0,
      P = 0,
      B = 0,
      L = 0,
      Q = 0,
      z = 0,
      j = 0,
      W = 0,
      ee = 0,
      Z = 0,
      ne = 0,
      Ae = 0,
      de = 0,
      ge = 0,
      Oe = 0,
      Ie = 0,
      we = 0,
      ln = 0,
      jr = 0,
      _i = 0,
      Cl = 0,
      zp = 0,
      Mw = 0,
      Tt = x[0],
      It = x[1],
      kt = x[2],
      Pt = x[3],
      Dt = x[4],
      Ot = x[5],
      Rt = x[6],
      Bt = x[7],
      Nt = x[8],
      Mt = x[9],
      Lt = x[10],
      Ft = x[11],
      jt = x[12],
      Ut = x[13],
      $t = x[14],
      Ht = x[15];
    (h = A[0]),
      (I += h * Tt),
      (C += h * It),
      (k += h * kt),
      (O += h * Pt),
      (R += h * Dt),
      (N += h * Ot),
      (S += h * Rt),
      (T += h * Bt),
      (D += h * Nt),
      (P += h * Mt),
      (B += h * Lt),
      (L += h * Ft),
      (Q += h * jt),
      (z += h * Ut),
      (j += h * $t),
      (W += h * Ht),
      (h = A[1]),
      (C += h * Tt),
      (k += h * It),
      (O += h * kt),
      (R += h * Pt),
      (N += h * Dt),
      (S += h * Ot),
      (T += h * Rt),
      (D += h * Bt),
      (P += h * Nt),
      (B += h * Mt),
      (L += h * Lt),
      (Q += h * Ft),
      (z += h * jt),
      (j += h * Ut),
      (W += h * $t),
      (ee += h * Ht),
      (h = A[2]),
      (k += h * Tt),
      (O += h * It),
      (R += h * kt),
      (N += h * Pt),
      (S += h * Dt),
      (T += h * Ot),
      (D += h * Rt),
      (P += h * Bt),
      (B += h * Nt),
      (L += h * Mt),
      (Q += h * Lt),
      (z += h * Ft),
      (j += h * jt),
      (W += h * Ut),
      (ee += h * $t),
      (Z += h * Ht),
      (h = A[3]),
      (O += h * Tt),
      (R += h * It),
      (N += h * kt),
      (S += h * Pt),
      (T += h * Dt),
      (D += h * Ot),
      (P += h * Rt),
      (B += h * Bt),
      (L += h * Nt),
      (Q += h * Mt),
      (z += h * Lt),
      (j += h * Ft),
      (W += h * jt),
      (ee += h * Ut),
      (Z += h * $t),
      (ne += h * Ht),
      (h = A[4]),
      (R += h * Tt),
      (N += h * It),
      (S += h * kt),
      (T += h * Pt),
      (D += h * Dt),
      (P += h * Ot),
      (B += h * Rt),
      (L += h * Bt),
      (Q += h * Nt),
      (z += h * Mt),
      (j += h * Lt),
      (W += h * Ft),
      (ee += h * jt),
      (Z += h * Ut),
      (ne += h * $t),
      (Ae += h * Ht),
      (h = A[5]),
      (N += h * Tt),
      (S += h * It),
      (T += h * kt),
      (D += h * Pt),
      (P += h * Dt),
      (B += h * Ot),
      (L += h * Rt),
      (Q += h * Bt),
      (z += h * Nt),
      (j += h * Mt),
      (W += h * Lt),
      (ee += h * Ft),
      (Z += h * jt),
      (ne += h * Ut),
      (Ae += h * $t),
      (de += h * Ht),
      (h = A[6]),
      (S += h * Tt),
      (T += h * It),
      (D += h * kt),
      (P += h * Pt),
      (B += h * Dt),
      (L += h * Ot),
      (Q += h * Rt),
      (z += h * Bt),
      (j += h * Nt),
      (W += h * Mt),
      (ee += h * Lt),
      (Z += h * Ft),
      (ne += h * jt),
      (Ae += h * Ut),
      (de += h * $t),
      (ge += h * Ht),
      (h = A[7]),
      (T += h * Tt),
      (D += h * It),
      (P += h * kt),
      (B += h * Pt),
      (L += h * Dt),
      (Q += h * Ot),
      (z += h * Rt),
      (j += h * Bt),
      (W += h * Nt),
      (ee += h * Mt),
      (Z += h * Lt),
      (ne += h * Ft),
      (Ae += h * jt),
      (de += h * Ut),
      (ge += h * $t),
      (Oe += h * Ht),
      (h = A[8]),
      (D += h * Tt),
      (P += h * It),
      (B += h * kt),
      (L += h * Pt),
      (Q += h * Dt),
      (z += h * Ot),
      (j += h * Rt),
      (W += h * Bt),
      (ee += h * Nt),
      (Z += h * Mt),
      (ne += h * Lt),
      (Ae += h * Ft),
      (de += h * jt),
      (ge += h * Ut),
      (Oe += h * $t),
      (Ie += h * Ht),
      (h = A[9]),
      (P += h * Tt),
      (B += h * It),
      (L += h * kt),
      (Q += h * Pt),
      (z += h * Dt),
      (j += h * Ot),
      (W += h * Rt),
      (ee += h * Bt),
      (Z += h * Nt),
      (ne += h * Mt),
      (Ae += h * Lt),
      (de += h * Ft),
      (ge += h * jt),
      (Oe += h * Ut),
      (Ie += h * $t),
      (we += h * Ht),
      (h = A[10]),
      (B += h * Tt),
      (L += h * It),
      (Q += h * kt),
      (z += h * Pt),
      (j += h * Dt),
      (W += h * Ot),
      (ee += h * Rt),
      (Z += h * Bt),
      (ne += h * Nt),
      (Ae += h * Mt),
      (de += h * Lt),
      (ge += h * Ft),
      (Oe += h * jt),
      (Ie += h * Ut),
      (we += h * $t),
      (ln += h * Ht),
      (h = A[11]),
      (L += h * Tt),
      (Q += h * It),
      (z += h * kt),
      (j += h * Pt),
      (W += h * Dt),
      (ee += h * Ot),
      (Z += h * Rt),
      (ne += h * Bt),
      (Ae += h * Nt),
      (de += h * Mt),
      (ge += h * Lt),
      (Oe += h * Ft),
      (Ie += h * jt),
      (we += h * Ut),
      (ln += h * $t),
      (jr += h * Ht),
      (h = A[12]),
      (Q += h * Tt),
      (z += h * It),
      (j += h * kt),
      (W += h * Pt),
      (ee += h * Dt),
      (Z += h * Ot),
      (ne += h * Rt),
      (Ae += h * Bt),
      (de += h * Nt),
      (ge += h * Mt),
      (Oe += h * Lt),
      (Ie += h * Ft),
      (we += h * jt),
      (ln += h * Ut),
      (jr += h * $t),
      (_i += h * Ht),
      (h = A[13]),
      (z += h * Tt),
      (j += h * It),
      (W += h * kt),
      (ee += h * Pt),
      (Z += h * Dt),
      (ne += h * Ot),
      (Ae += h * Rt),
      (de += h * Bt),
      (ge += h * Nt),
      (Oe += h * Mt),
      (Ie += h * Lt),
      (we += h * Ft),
      (ln += h * jt),
      (jr += h * Ut),
      (_i += h * $t),
      (Cl += h * Ht),
      (h = A[14]),
      (j += h * Tt),
      (W += h * It),
      (ee += h * kt),
      (Z += h * Pt),
      (ne += h * Dt),
      (Ae += h * Ot),
      (de += h * Rt),
      (ge += h * Bt),
      (Oe += h * Nt),
      (Ie += h * Mt),
      (we += h * Lt),
      (ln += h * Ft),
      (jr += h * jt),
      (_i += h * Ut),
      (Cl += h * $t),
      (zp += h * Ht),
      (h = A[15]),
      (W += h * Tt),
      (ee += h * It),
      (Z += h * kt),
      (ne += h * Pt),
      (Ae += h * Dt),
      (de += h * Ot),
      (ge += h * Rt),
      (Oe += h * Bt),
      (Ie += h * Nt),
      (we += h * Mt),
      (ln += h * Lt),
      (jr += h * Ft),
      (_i += h * jt),
      (Cl += h * Ut),
      (zp += h * $t),
      (Mw += h * Ht),
      (I += 38 * ee),
      (C += 38 * Z),
      (k += 38 * ne),
      (O += 38 * Ae),
      (R += 38 * de),
      (N += 38 * ge),
      (S += 38 * Oe),
      (T += 38 * Ie),
      (D += 38 * we),
      (P += 38 * ln),
      (B += 38 * jr),
      (L += 38 * _i),
      (Q += 38 * Cl),
      (z += 38 * zp),
      (j += 38 * Mw),
      (E = 1),
      (h = I + E + 65535),
      (E = Math.floor(h / 65536)),
      (I = h - E * 65536),
      (h = C + E + 65535),
      (E = Math.floor(h / 65536)),
      (C = h - E * 65536),
      (h = k + E + 65535),
      (E = Math.floor(h / 65536)),
      (k = h - E * 65536),
      (h = O + E + 65535),
      (E = Math.floor(h / 65536)),
      (O = h - E * 65536),
      (h = R + E + 65535),
      (E = Math.floor(h / 65536)),
      (R = h - E * 65536),
      (h = N + E + 65535),
      (E = Math.floor(h / 65536)),
      (N = h - E * 65536),
      (h = S + E + 65535),
      (E = Math.floor(h / 65536)),
      (S = h - E * 65536),
      (h = T + E + 65535),
      (E = Math.floor(h / 65536)),
      (T = h - E * 65536),
      (h = D + E + 65535),
      (E = Math.floor(h / 65536)),
      (D = h - E * 65536),
      (h = P + E + 65535),
      (E = Math.floor(h / 65536)),
      (P = h - E * 65536),
      (h = B + E + 65535),
      (E = Math.floor(h / 65536)),
      (B = h - E * 65536),
      (h = L + E + 65535),
      (E = Math.floor(h / 65536)),
      (L = h - E * 65536),
      (h = Q + E + 65535),
      (E = Math.floor(h / 65536)),
      (Q = h - E * 65536),
      (h = z + E + 65535),
      (E = Math.floor(h / 65536)),
      (z = h - E * 65536),
      (h = j + E + 65535),
      (E = Math.floor(h / 65536)),
      (j = h - E * 65536),
      (h = W + E + 65535),
      (E = Math.floor(h / 65536)),
      (W = h - E * 65536),
      (I += E - 1 + 37 * (E - 1)),
      (E = 1),
      (h = I + E + 65535),
      (E = Math.floor(h / 65536)),
      (I = h - E * 65536),
      (h = C + E + 65535),
      (E = Math.floor(h / 65536)),
      (C = h - E * 65536),
      (h = k + E + 65535),
      (E = Math.floor(h / 65536)),
      (k = h - E * 65536),
      (h = O + E + 65535),
      (E = Math.floor(h / 65536)),
      (O = h - E * 65536),
      (h = R + E + 65535),
      (E = Math.floor(h / 65536)),
      (R = h - E * 65536),
      (h = N + E + 65535),
      (E = Math.floor(h / 65536)),
      (N = h - E * 65536),
      (h = S + E + 65535),
      (E = Math.floor(h / 65536)),
      (S = h - E * 65536),
      (h = T + E + 65535),
      (E = Math.floor(h / 65536)),
      (T = h - E * 65536),
      (h = D + E + 65535),
      (E = Math.floor(h / 65536)),
      (D = h - E * 65536),
      (h = P + E + 65535),
      (E = Math.floor(h / 65536)),
      (P = h - E * 65536),
      (h = B + E + 65535),
      (E = Math.floor(h / 65536)),
      (B = h - E * 65536),
      (h = L + E + 65535),
      (E = Math.floor(h / 65536)),
      (L = h - E * 65536),
      (h = Q + E + 65535),
      (E = Math.floor(h / 65536)),
      (Q = h - E * 65536),
      (h = z + E + 65535),
      (E = Math.floor(h / 65536)),
      (z = h - E * 65536),
      (h = j + E + 65535),
      (E = Math.floor(h / 65536)),
      (j = h - E * 65536),
      (h = W + E + 65535),
      (E = Math.floor(h / 65536)),
      (W = h - E * 65536),
      (I += E - 1 + 37 * (E - 1)),
      (_[0] = I),
      (_[1] = C),
      (_[2] = k),
      (_[3] = O),
      (_[4] = R),
      (_[5] = N),
      (_[6] = S),
      (_[7] = T),
      (_[8] = D),
      (_[9] = P),
      (_[10] = B),
      (_[11] = L),
      (_[12] = Q),
      (_[13] = z),
      (_[14] = j),
      (_[15] = W);
  }
  function p(_, A) {
    f(_, A, A);
  }
  function m(_, A) {
    const x = r();
    for (let h = 0; h < 16; h++) x[h] = A[h];
    for (let h = 253; h >= 0; h--) p(x, x), h !== 2 && h !== 4 && f(x, x, A);
    for (let h = 0; h < 16; h++) _[h] = x[h];
  }
  function g(_, A) {
    const x = new Uint8Array(32),
      h = new Float64Array(80),
      E = r(),
      I = r(),
      C = r(),
      k = r(),
      O = r(),
      R = r();
    for (let D = 0; D < 31; D++) x[D] = _[D];
    (x[31] = (_[31] & 127) | 64), (x[0] &= 248), l(h, A);
    for (let D = 0; D < 16; D++) I[D] = h[D];
    E[0] = k[0] = 1;
    for (let D = 254; D >= 0; --D) {
      const P = (x[D >>> 3] >>> (D & 7)) & 1;
      a(E, I, P),
        a(C, k, P),
        c(O, E, C),
        d(E, E, C),
        c(C, I, k),
        d(I, I, k),
        p(k, O),
        p(R, E),
        f(E, C, E),
        f(C, I, O),
        c(O, E, C),
        d(E, E, C),
        p(I, E),
        d(C, k, R),
        f(E, C, s),
        c(E, E, k),
        f(C, C, E),
        f(E, k, R),
        f(k, I, h),
        p(I, O),
        a(E, I, P),
        a(C, k, P);
    }
    for (let D = 0; D < 16; D++)
      (h[D + 16] = E[D]),
        (h[D + 32] = C[D]),
        (h[D + 48] = I[D]),
        (h[D + 64] = k[D]);
    const N = h.subarray(32),
      S = h.subarray(16);
    m(N, N), f(S, S, N);
    const T = new Uint8Array(32);
    return u(T, S), T;
  }
  e.scalarMult = g;
  function w(_) {
    return g(_, i);
  }
  e.scalarMultBase = w;
  function v(_) {
    if (_.length !== e.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${e.SECRET_KEY_LENGTH} bytes`);
    const A = new Uint8Array(_);
    return { publicKey: w(A), secretKey: A };
  }
  e.generateKeyPairFromSeed = v;
  function y(_) {
    const A = (0, t.randomBytes)(32, _),
      x = v(A);
    return (0, n.wipe)(A), x;
  }
  e.generateKeyPair = y;
  function b(_, A, x = !1) {
    if (_.length !== e.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (A.length !== e.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const h = g(_, A);
    if (x) {
      let E = 0;
      for (let I = 0; I < h.length; I++) E |= h[I];
      if (E === 0) throw new Error("X25519: invalid shared key");
    }
    return h;
  }
  e.sharedKey = b;
})(cB);
function lB(e, t) {
  if (e.length >= 255) throw new TypeError("Alphabet too long");
  for (var n = new Uint8Array(256), r = 0; r < n.length; r++) n[r] = 255;
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      o = s.charCodeAt(0);
    if (n[o] !== 255) throw new TypeError(s + " is ambiguous");
    n[o] = i;
  }
  var a = e.length,
    u = e.charAt(0),
    l = Math.log(a) / Math.log(256),
    c = Math.log(256) / Math.log(a);
  function d(m) {
    if (
      (m instanceof Uint8Array ||
        (ArrayBuffer.isView(m)
          ? (m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength))
          : Array.isArray(m) && (m = Uint8Array.from(m))),
      !(m instanceof Uint8Array))
    )
      throw new TypeError("Expected Uint8Array");
    if (m.length === 0) return "";
    for (var g = 0, w = 0, v = 0, y = m.length; v !== y && m[v] === 0; )
      v++, g++;
    for (var b = ((y - v) * c + 1) >>> 0, _ = new Uint8Array(b); v !== y; ) {
      for (
        var A = m[v], x = 0, h = b - 1;
        (A !== 0 || x < w) && h !== -1;
        h--, x++
      )
        (A += (256 * _[h]) >>> 0), (_[h] = A % a >>> 0), (A = (A / a) >>> 0);
      if (A !== 0) throw new Error("Non-zero carry");
      (w = x), v++;
    }
    for (var E = b - w; E !== b && _[E] === 0; ) E++;
    for (var I = u.repeat(g); E < b; ++E) I += e.charAt(_[E]);
    return I;
  }
  function f(m) {
    if (typeof m != "string") throw new TypeError("Expected String");
    if (m.length === 0) return new Uint8Array();
    var g = 0;
    if (m[g] !== " ") {
      for (var w = 0, v = 0; m[g] === u; ) w++, g++;
      for (
        var y = ((m.length - g) * l + 1) >>> 0, b = new Uint8Array(y);
        m[g];

      ) {
        var _ = n[m.charCodeAt(g)];
        if (_ === 255) return;
        for (var A = 0, x = y - 1; (_ !== 0 || A < v) && x !== -1; x--, A++)
          (_ += (a * b[x]) >>> 0),
            (b[x] = _ % 256 >>> 0),
            (_ = (_ / 256) >>> 0);
        if (_ !== 0) throw new Error("Non-zero carry");
        (v = A), g++;
      }
      if (m[g] !== " ") {
        for (var h = y - v; h !== y && b[h] === 0; ) h++;
        for (var E = new Uint8Array(w + (y - h)), I = w; h !== y; )
          E[I++] = b[h++];
        return E;
      }
    }
  }
  function p(m) {
    var g = f(m);
    if (g) return g;
    throw new Error(`Non-${t} character`);
  }
  return { encode: d, decodeUnsafe: f, decode: p };
}
var dB = lB,
  fB = dB;
const hB = (e) => {
    if (e instanceof Uint8Array && e.constructor.name === "Uint8Array")
      return e;
    if (e instanceof ArrayBuffer) return new Uint8Array(e);
    if (ArrayBuffer.isView(e))
      return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
  pB = (e) => new TextEncoder().encode(e),
  mB = (e) => new TextDecoder().decode(e);
class yB {
  constructor(t, n, r) {
    (this.name = t), (this.prefix = n), (this.baseEncode = r);
  }
  encode(t) {
    if (t instanceof Uint8Array) return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class gB {
  constructor(t, n, r) {
    if (((this.name = t), (this.prefix = n), n.codePointAt(0) === void 0))
      throw new Error("Invalid prefix character");
    (this.prefixCodePoint = n.codePointAt(0)), (this.baseDecode = r);
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(
          `Unable to decode multibase string ${JSON.stringify(t)}, ${
            this.name
          } decoder only supports inputs prefixed with ${this.prefix}`
        );
      return this.baseDecode(t.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(t) {
    return yC(this, t);
  }
}
class vB {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return yC(this, t);
  }
  decode(t) {
    const n = t[0],
      r = this.decoders[n];
    if (r) return r.decode(t);
    throw RangeError(
      `Unable to decode multibase string ${JSON.stringify(
        t
      )}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`
    );
  }
}
const yC = (e, t) =>
  new vB({
    ...(e.decoders || { [e.prefix]: e }),
    ...(t.decoders || { [t.prefix]: t }),
  });
class bB {
  constructor(t, n, r, i) {
    (this.name = t),
      (this.prefix = n),
      (this.baseEncode = r),
      (this.baseDecode = i),
      (this.encoder = new yB(t, n, r)),
      (this.decoder = new gB(t, n, i));
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
}
const tp = ({ name: e, prefix: t, encode: n, decode: r }) => new bB(e, t, n, r),
  pl = ({ prefix: e, name: t, alphabet: n }) => {
    const { encode: r, decode: i } = fB(n, t);
    return tp({ prefix: e, name: t, encode: r, decode: (s) => hB(i(s)) });
  },
  wB = (e, t, n, r) => {
    const i = {};
    for (let c = 0; c < t.length; ++c) i[t[c]] = c;
    let s = e.length;
    for (; e[s - 1] === "="; ) --s;
    const o = new Uint8Array(((s * n) / 8) | 0);
    let a = 0,
      u = 0,
      l = 0;
    for (let c = 0; c < s; ++c) {
      const d = i[e[c]];
      if (d === void 0) throw new SyntaxError(`Non-${r} character`);
      (u = (u << n) | d),
        (a += n),
        a >= 8 && ((a -= 8), (o[l++] = 255 & (u >> a)));
    }
    if (a >= n || 255 & (u << (8 - a)))
      throw new SyntaxError("Unexpected end of data");
    return o;
  },
  EB = (e, t, n) => {
    const r = t[t.length - 1] === "=",
      i = (1 << n) - 1;
    let s = "",
      o = 0,
      a = 0;
    for (let u = 0; u < e.length; ++u)
      for (a = (a << 8) | e[u], o += 8; o > n; )
        (o -= n), (s += t[i & (a >> o)]);
    if ((o && (s += t[i & (a << (n - o))]), r))
      for (; (s.length * n) & 7; ) s += "=";
    return s;
  },
  Ct = ({ name: e, prefix: t, bitsPerChar: n, alphabet: r }) =>
    tp({
      prefix: t,
      name: e,
      encode(i) {
        return EB(i, r, n);
      },
      decode(i) {
        return wB(i, r, n, e);
      },
    }),
  _B = tp({
    prefix: "\0",
    name: "identity",
    encode: (e) => mB(e),
    decode: (e) => pB(e),
  }),
  ZV = Object.freeze(
    Object.defineProperty(
      { __proto__: null, identity: _B },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  AB = Ct({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 }),
  JV = Object.freeze(
    Object.defineProperty({ __proto__: null, base2: AB }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  xB = Ct({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 }),
  YV = Object.freeze(
    Object.defineProperty({ __proto__: null, base8: xB }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  SB = pl({ prefix: "9", name: "base10", alphabet: "0123456789" }),
  XV = Object.freeze(
    Object.defineProperty({ __proto__: null, base10: SB }, Symbol.toStringTag, {
      value: "Module",
    })
  ),
  CB = Ct({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4,
  }),
  TB = Ct({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4,
  }),
  eK = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base16: CB, base16upper: TB },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  IB = Ct({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5,
  }),
  kB = Ct({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5,
  }),
  PB = Ct({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5,
  }),
  DB = Ct({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5,
  }),
  OB = Ct({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5,
  }),
  RB = Ct({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5,
  }),
  BB = Ct({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5,
  }),
  NB = Ct({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5,
  }),
  MB = Ct({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5,
  }),
  tK = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base32: IB,
        base32hex: OB,
        base32hexpad: BB,
        base32hexpadupper: NB,
        base32hexupper: RB,
        base32pad: PB,
        base32padupper: DB,
        base32upper: kB,
        base32z: MB,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  LB = pl({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz",
  }),
  FB = pl({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",
  }),
  nK = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base36: LB, base36upper: FB },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  jB = pl({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  }),
  UB = pl({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
  }),
  rK = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base58btc: jB, base58flickr: UB },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  $B = Ct({
    prefix: "m",
    name: "base64",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6,
  }),
  HB = Ct({
    prefix: "M",
    name: "base64pad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6,
  }),
  zB = Ct({
    prefix: "u",
    name: "base64url",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6,
  }),
  GB = Ct({
    prefix: "U",
    name: "base64urlpad",
    alphabet:
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6,
  }),
  iK = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        base64: $B,
        base64pad: HB,
        base64url: zB,
        base64urlpad: GB,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  gC = Array.from(
    ""
  ),
  qB = gC.reduce((e, t, n) => ((e[n] = t), e), []),
  WB = gC.reduce((e, t, n) => ((e[t.codePointAt(0)] = n), e), []);
function QB(e) {
  return e.reduce((t, n) => ((t += qB[n]), t), "");
}
function VB(e) {
  const t = [];
  for (const n of e) {
    const r = WB[n.codePointAt(0)];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${n}`);
    t.push(r);
  }
  return new Uint8Array(t);
}
const KB = tp({ prefix: "", name: "base256emoji", encode: QB, decode: VB }),
  sK = Object.freeze(
    Object.defineProperty(
      { __proto__: null, base256emoji: KB },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
new TextEncoder();
new TextDecoder();
var ZB = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */ var Oy =
  function (e, t) {
    return (
      (Oy =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (n, r) {
            n.__proto__ = r;
          }) ||
        function (n, r) {
          for (var i in r) r.hasOwnProperty(i) && (n[i] = r[i]);
        }),
      Oy(e, t)
    );
  };
function JB(e, t) {
  Oy(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype =
    t === null ? Object.create(t) : ((n.prototype = t.prototype), new n());
}
var Ry = function () {
  return (
    (Ry =
      Object.assign ||
      function (t) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
          n = arguments[r];
          for (var s in n)
            Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
        }
        return t;
      }),
    Ry.apply(this, arguments)
  );
};
function YB(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) &&
      t.indexOf(r) < 0 &&
      (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
        (n[r[i]] = e[r[i]]);
  return n;
}
function XB(e, t, n, r) {
  var i = arguments.length,
    s =
      i < 3 ? t : r === null ? (r = Object.getOwnPropertyDescriptor(t, n)) : r,
    o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(e, t, n, r);
  else
    for (var a = e.length - 1; a >= 0; a--)
      (o = e[a]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s);
  return i > 3 && s && Object.defineProperty(t, n, s), s;
}
function eN(e, t) {
  return function (n, r) {
    t(n, r, e);
  };
}
function tN(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e, t);
}
function nN(e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
}
function rN(e, t) {
  var n = {
      label: 0,
      sent: function () {
        if (s[0] & 1) throw s[1];
        return s[1];
      },
      trys: [],
      ops: [],
    },
    r,
    i,
    s,
    o;
  return (
    (o = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol == "function" &&
      (o[Symbol.iterator] = function () {
        return this;
      }),
    o
  );
  function a(l) {
    return function (c) {
      return u([l, c]);
    };
  }
  function u(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; )
      try {
        if (
          ((r = 1),
          i &&
            (s =
              l[0] & 2
                ? i.return
                : l[0]
                ? i.throw || ((s = i.return) && s.call(i), 0)
                : i.next) &&
            !(s = s.call(i, l[1])).done)
        )
          return s;
        switch (((i = 0), s && (l = [l[0] & 2, s.value]), l[0])) {
          case 0:
          case 1:
            s = l;
            break;
          case 4:
            return n.label++, { value: l[1], done: !1 };
          case 5:
            n.label++, (i = l[1]), (l = [0]);
            continue;
          case 7:
            (l = n.ops.pop()), n.trys.pop();
            continue;
          default:
            if (
              ((s = n.trys),
              !(s = s.length > 0 && s[s.length - 1]) &&
                (l[0] === 6 || l[0] === 2))
            ) {
              n = 0;
              continue;
            }
            if (l[0] === 3 && (!s || (l[1] > s[0] && l[1] < s[3]))) {
              n.label = l[1];
              break;
            }
            if (l[0] === 6 && n.label < s[1]) {
              (n.label = s[1]), (s = l);
              break;
            }
            if (s && n.label < s[2]) {
              (n.label = s[2]), n.ops.push(l);
              break;
            }
            s[2] && n.ops.pop(), n.trys.pop();
            continue;
        }
        l = t.call(e, n);
      } catch (c) {
        (l = [6, c]), (i = 0);
      } finally {
        r = s = 0;
      }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function iN(e, t, n, r) {
  r === void 0 && (r = n), (e[r] = t[n]);
}
function sN(e, t) {
  for (var n in e) n !== "default" && !t.hasOwnProperty(n) && (t[n] = e[n]);
}
function By(e) {
  var t = typeof Symbol == "function" && Symbol.iterator,
    n = t && e[t],
    r = 0;
  if (n) return n.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function () {
        return (
          e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e }
        );
      },
    };
  throw new TypeError(
    t ? "Object is not iterable." : "Symbol.iterator is not defined."
  );
}
function vC(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e),
    i,
    s = [],
    o;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) s.push(i.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (o) throw o.error;
    }
  }
  return s;
}
function oN() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(vC(arguments[t]));
  return e;
}
function aN() {
  for (var e = 0, t = 0, n = arguments.length; t < n; t++)
    e += arguments[t].length;
  for (var r = Array(e), i = 0, t = 0; t < n; t++)
    for (var s = arguments[t], o = 0, a = s.length; o < a; o++, i++)
      r[i] = s[o];
  return r;
}
function Cc(e) {
  return this instanceof Cc ? ((this.v = e), this) : new Cc(e);
}
function uN(e, t, n) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var r = n.apply(e, t || []),
    i,
    s = [];
  return (
    (i = {}),
    o("next"),
    o("throw"),
    o("return"),
    (i[Symbol.asyncIterator] = function () {
      return this;
    }),
    i
  );
  function o(f) {
    r[f] &&
      (i[f] = function (p) {
        return new Promise(function (m, g) {
          s.push([f, p, m, g]) > 1 || a(f, p);
        });
      });
  }
  function a(f, p) {
    try {
      u(r[f](p));
    } catch (m) {
      d(s[0][3], m);
    }
  }
  function u(f) {
    f.value instanceof Cc
      ? Promise.resolve(f.value.v).then(l, c)
      : d(s[0][2], f);
  }
  function l(f) {
    a("next", f);
  }
  function c(f) {
    a("throw", f);
  }
  function d(f, p) {
    f(p), s.shift(), s.length && a(s[0][0], s[0][1]);
  }
}
function cN(e) {
  var t, n;
  return (
    (t = {}),
    r("next"),
    r("throw", function (i) {
      throw i;
    }),
    r("return"),
    (t[Symbol.iterator] = function () {
      return this;
    }),
    t
  );
  function r(i, s) {
    t[i] = e[i]
      ? function (o) {
          return (n = !n)
            ? { value: Cc(e[i](o)), done: i === "return" }
            : s
            ? s(o)
            : o;
        }
      : s;
  }
}
function lN(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator],
    n;
  return t
    ? t.call(e)
    : ((e = typeof By == "function" ? By(e) : e[Symbol.iterator]()),
      (n = {}),
      r("next"),
      r("throw"),
      r("return"),
      (n[Symbol.asyncIterator] = function () {
        return this;
      }),
      n);
  function r(s) {
    n[s] =
      e[s] &&
      function (o) {
        return new Promise(function (a, u) {
          (o = e[s](o)), i(a, u, o.done, o.value);
        });
      };
  }
  function i(s, o, a, u) {
    Promise.resolve(u).then(function (l) {
      s({ value: l, done: a });
    }, o);
  }
}
function dN(e, t) {
  return (
    Object.defineProperty
      ? Object.defineProperty(e, "raw", { value: t })
      : (e.raw = t),
    e
  );
}
function fN(e) {
  if (e && e.__esModule) return e;
  var t = {};
  if (e != null)
    for (var n in e) Object.hasOwnProperty.call(e, n) && (t[n] = e[n]);
  return (t.default = e), t;
}
function hN(e) {
  return e && e.__esModule ? e : { default: e };
}
function pN(e, t) {
  if (!t.has(e))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(e);
}
function mN(e, t, n) {
  if (!t.has(e))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(e, n), n;
}
const yN = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        get __assign() {
          return Ry;
        },
        __asyncDelegator: cN,
        __asyncGenerator: uN,
        __asyncValues: lN,
        __await: Cc,
        __awaiter: nN,
        __classPrivateFieldGet: pN,
        __classPrivateFieldSet: mN,
        __createBinding: iN,
        __decorate: XB,
        __exportStar: sN,
        __extends: JB,
        __generator: rN,
        __importDefault: hN,
        __importStar: fN,
        __makeTemplateObject: dN,
        __metadata: tN,
        __param: eN,
        __read: vC,
        __rest: YB,
        __spread: oN,
        __spreadArrays: aN,
        __values: By,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  np = R2(yN);
var xm = {},
  ou = {},
  _E;
function gN() {
  if (_E) return ou;
  (_E = 1),
    Object.defineProperty(ou, "__esModule", { value: !0 }),
    (ou.delay = void 0);
  function e(t) {
    return new Promise((n) => {
      setTimeout(() => {
        n(!0);
      }, t);
    });
  }
  return (ou.delay = e), ou;
}
var Es = {},
  Sm = {},
  _s = {},
  AE;
function vN() {
  return (
    AE ||
      ((AE = 1),
      Object.defineProperty(_s, "__esModule", { value: !0 }),
      (_s.ONE_THOUSAND = _s.ONE_HUNDRED = void 0),
      (_s.ONE_HUNDRED = 100),
      (_s.ONE_THOUSAND = 1e3)),
    _s
  );
}
var Cm = {},
  xE;
function bN() {
  return (
    xE ||
      ((xE = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ONE_YEAR =
            e.FOUR_WEEKS =
            e.THREE_WEEKS =
            e.TWO_WEEKS =
            e.ONE_WEEK =
            e.THIRTY_DAYS =
            e.SEVEN_DAYS =
            e.FIVE_DAYS =
            e.THREE_DAYS =
            e.ONE_DAY =
            e.TWENTY_FOUR_HOURS =
            e.TWELVE_HOURS =
            e.SIX_HOURS =
            e.THREE_HOURS =
            e.ONE_HOUR =
            e.SIXTY_MINUTES =
            e.THIRTY_MINUTES =
            e.TEN_MINUTES =
            e.FIVE_MINUTES =
            e.ONE_MINUTE =
            e.SIXTY_SECONDS =
            e.THIRTY_SECONDS =
            e.TEN_SECONDS =
            e.FIVE_SECONDS =
            e.ONE_SECOND =
              void 0),
          (e.ONE_SECOND = 1),
          (e.FIVE_SECONDS = 5),
          (e.TEN_SECONDS = 10),
          (e.THIRTY_SECONDS = 30),
          (e.SIXTY_SECONDS = 60),
          (e.ONE_MINUTE = e.SIXTY_SECONDS),
          (e.FIVE_MINUTES = e.ONE_MINUTE * 5),
          (e.TEN_MINUTES = e.ONE_MINUTE * 10),
          (e.THIRTY_MINUTES = e.ONE_MINUTE * 30),
          (e.SIXTY_MINUTES = e.ONE_MINUTE * 60),
          (e.ONE_HOUR = e.SIXTY_MINUTES),
          (e.THREE_HOURS = e.ONE_HOUR * 3),
          (e.SIX_HOURS = e.ONE_HOUR * 6),
          (e.TWELVE_HOURS = e.ONE_HOUR * 12),
          (e.TWENTY_FOUR_HOURS = e.ONE_HOUR * 24),
          (e.ONE_DAY = e.TWENTY_FOUR_HOURS),
          (e.THREE_DAYS = e.ONE_DAY * 3),
          (e.FIVE_DAYS = e.ONE_DAY * 5),
          (e.SEVEN_DAYS = e.ONE_DAY * 7),
          (e.THIRTY_DAYS = e.ONE_DAY * 30),
          (e.ONE_WEEK = e.SEVEN_DAYS),
          (e.TWO_WEEKS = e.ONE_WEEK * 2),
          (e.THREE_WEEKS = e.ONE_WEEK * 3),
          (e.FOUR_WEEKS = e.ONE_WEEK * 4),
          (e.ONE_YEAR = e.ONE_DAY * 365);
      })(Cm)),
    Cm
  );
}
var SE;
function bC() {
  return (
    SE ||
      ((SE = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 });
        const t = np;
        t.__exportStar(vN(), e), t.__exportStar(bN(), e);
      })(Sm)),
    Sm
  );
}
var CE;
function wN() {
  if (CE) return Es;
  (CE = 1),
    Object.defineProperty(Es, "__esModule", { value: !0 }),
    (Es.fromMiliseconds = Es.toMiliseconds = void 0);
  const e = bC();
  function t(r) {
    return r * e.ONE_THOUSAND;
  }
  Es.toMiliseconds = t;
  function n(r) {
    return Math.floor(r / e.ONE_THOUSAND);
  }
  return (Es.fromMiliseconds = n), Es;
}
var TE;
function EN() {
  return (
    TE ||
      ((TE = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 });
        const t = np;
        t.__exportStar(gN(), e), t.__exportStar(wN(), e);
      })(xm)),
    xm
  );
}
var wo = {},
  IE;
function _N() {
  if (IE) return wo;
  (IE = 1),
    Object.defineProperty(wo, "__esModule", { value: !0 }),
    (wo.Watch = void 0);
  class e {
    constructor() {
      this.timestamps = new Map();
    }
    start(n) {
      if (this.timestamps.has(n))
        throw new Error(`Watch already started for label: ${n}`);
      this.timestamps.set(n, { started: Date.now() });
    }
    stop(n) {
      const r = this.get(n);
      if (typeof r.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${n}`);
      const i = Date.now() - r.started;
      this.timestamps.set(n, { started: r.started, elapsed: i });
    }
    get(n) {
      const r = this.timestamps.get(n);
      if (typeof r > "u") throw new Error(`No timestamp found for label: ${n}`);
      return r;
    }
    elapsed(n) {
      const r = this.get(n);
      return r.elapsed || Date.now() - r.started;
    }
  }
  return (wo.Watch = e), (wo.default = e), wo;
}
var Tm = {},
  au = {},
  kE;
function AN() {
  if (kE) return au;
  (kE = 1),
    Object.defineProperty(au, "__esModule", { value: !0 }),
    (au.IWatch = void 0);
  class e {}
  return (au.IWatch = e), au;
}
var PE;
function xN() {
  return (
    PE ||
      ((PE = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          np.__exportStar(AN(), e);
      })(Tm)),
    Tm
  );
}
(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  const t = np;
  t.__exportStar(EN(), e),
    t.__exportStar(_N(), e),
    t.__exportStar(xN(), e),
    t.__exportStar(bC(), e);
})(ZB);
var $e = {};
Object.defineProperty($e, "__esModule", { value: !0 });
$e.getLocalStorage =
  $e.getLocalStorageOrThrow =
  $e.getCrypto =
  $e.getCryptoOrThrow =
  RN =
  $e.getLocation =
  $e.getLocationOrThrow =
  PN =
  $e.getNavigator =
  $e.getNavigatorOrThrow =
  TN =
  $e.getDocument =
  $e.getDocumentOrThrow =
  $e.getFromWindowOrThrow =
  $e.getFromWindow =
    void 0;
function mo(e) {
  let t;
  return typeof window < "u" && typeof window[e] < "u" && (t = window[e]), t;
}
$e.getFromWindow = mo;
function Ga(e) {
  const t = mo(e);
  if (!t) throw new Error(`${e} is not defined in Window`);
  return t;
}
$e.getFromWindowOrThrow = Ga;
function SN() {
  return Ga("document");
}
$e.getDocumentOrThrow = SN;
function CN() {
  return mo("document");
}
var TN = ($e.getDocument = CN);
function IN() {
  return Ga("navigator");
}
$e.getNavigatorOrThrow = IN;
function kN() {
  return mo("navigator");
}
var PN = ($e.getNavigator = kN);
function DN() {
  return Ga("location");
}
$e.getLocationOrThrow = DN;
function ON() {
  return mo("location");
}
var RN = ($e.getLocation = ON);
function BN() {
  return Ga("crypto");
}
$e.getCryptoOrThrow = BN;
function NN() {
  return mo("crypto");
}
$e.getCrypto = NN;
function MN() {
  return Ga("localStorage");
}
$e.getLocalStorageOrThrow = MN;
function LN() {
  return mo("localStorage");
}
$e.getLocalStorage = LN;
var gb = {};
Object.defineProperty(gb, "__esModule", { value: !0 });
var FN = (gb.getWindowMetadata = void 0);
const DE = $e;
function jN() {
  let e, t;
  try {
    (e = DE.getDocumentOrThrow()), (t = DE.getLocationOrThrow());
  } catch {
    return null;
  }
  function n() {
    const d = e.getElementsByTagName("link"),
      f = [];
    for (let p = 0; p < d.length; p++) {
      const m = d[p],
        g = m.getAttribute("rel");
      if (g && g.toLowerCase().indexOf("icon") > -1) {
        const w = m.getAttribute("href");
        if (w)
          if (
            w.toLowerCase().indexOf("https:") === -1 &&
            w.toLowerCase().indexOf("http:") === -1 &&
            w.indexOf("//") !== 0
          ) {
            let v = t.protocol + "//" + t.host;
            if (w.indexOf("/") === 0) v += w;
            else {
              const y = t.pathname.split("/");
              y.pop();
              const b = y.join("/");
              v += b + "/" + w;
            }
            f.push(v);
          } else if (w.indexOf("//") === 0) {
            const v = t.protocol + w;
            f.push(v);
          } else f.push(w);
      }
    }
    return f;
  }
  function r(...d) {
    const f = e.getElementsByTagName("meta");
    for (let p = 0; p < f.length; p++) {
      const m = f[p],
        g = ["itemprop", "property", "name"]
          .map((w) => m.getAttribute(w))
          .filter((w) => (w ? d.includes(w) : !1));
      if (g.length && g) {
        const w = m.getAttribute("content");
        if (w) return w;
      }
    }
    return "";
  }
  function i() {
    let d = r("name", "og:site_name", "og:title", "twitter:title");
    return d || (d = e.title), d;
  }
  function s() {
    return r(
      "description",
      "og:description",
      "twitter:description",
      "keywords"
    );
  }
  const o = i(),
    a = s(),
    u = t.origin,
    l = n();
  return { description: a, url: u, icons: l, name: o };
}
FN = gb.getWindowMetadata = jN;
var UN = {},
  $N = (e) =>
    encodeURIComponent(e).replace(
      /[!'()*]/g,
      (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`
    ),
  wC = "%[a-f0-9]{2}",
  OE = new RegExp("(" + wC + ")|([^%]+?)", "gi"),
  RE = new RegExp("(" + wC + ")+", "gi");
function Ny(e, t) {
  try {
    return [decodeURIComponent(e.join(""))];
  } catch {}
  if (e.length === 1) return e;
  t = t || 1;
  var n = e.slice(0, t),
    r = e.slice(t);
  return Array.prototype.concat.call([], Ny(n), Ny(r));
}
function HN(e) {
  try {
    return decodeURIComponent(e);
  } catch {
    for (var t = e.match(OE) || [], n = 1; n < t.length; n++)
      (e = Ny(t, n).join("")), (t = e.match(OE) || []);
    return e;
  }
}
function zN(e) {
  for (var t = { "%FE%FF": "", "%FF%FE": "" }, n = RE.exec(e); n; ) {
    try {
      t[n[0]] = decodeURIComponent(n[0]);
    } catch {
      var r = HN(n[0]);
      r !== n[0] && (t[n[0]] = r);
    }
    n = RE.exec(e);
  }
  t["%C2"] = "";
  for (var i = Object.keys(t), s = 0; s < i.length; s++) {
    var o = i[s];
    e = e.replace(new RegExp(o, "g"), t[o]);
  }
  return e;
}
var GN = function (e) {
    if (typeof e != "string")
      throw new TypeError(
        "Expected `encodedURI` to be of type `string`, got `" + typeof e + "`"
      );
    try {
      return (e = e.replace(/\+/g, " ")), decodeURIComponent(e);
    } catch {
      return zN(e);
    }
  },
  qN = (e, t) => {
    if (!(typeof e == "string" && typeof t == "string"))
      throw new TypeError("Expected the arguments to be of type `string`");
    if (t === "") return [e];
    const n = e.indexOf(t);
    return n === -1 ? [e] : [e.slice(0, n), e.slice(n + t.length)];
  },
  WN = function (e, t) {
    for (
      var n = {}, r = Object.keys(e), i = Array.isArray(t), s = 0;
      s < r.length;
      s++
    ) {
      var o = r[s],
        a = e[o];
      (i ? t.indexOf(o) !== -1 : t(o, a, e)) && (n[o] = a);
    }
    return n;
  };
(function (e) {
  const t = $N,
    n = GN,
    r = qN,
    i = WN,
    s = (y) => y == null,
    o = Symbol("encodeFragmentIdentifier");
  function a(y) {
    switch (y.arrayFormat) {
      case "index":
        return (b) => (_, A) => {
          const x = _.length;
          return A === void 0 ||
            (y.skipNull && A === null) ||
            (y.skipEmptyString && A === "")
            ? _
            : A === null
            ? [..._, [c(b, y), "[", x, "]"].join("")]
            : [..._, [c(b, y), "[", c(x, y), "]=", c(A, y)].join("")];
        };
      case "bracket":
        return (b) => (_, A) =>
          A === void 0 ||
          (y.skipNull && A === null) ||
          (y.skipEmptyString && A === "")
            ? _
            : A === null
            ? [..._, [c(b, y), "[]"].join("")]
            : [..._, [c(b, y), "[]=", c(A, y)].join("")];
      case "colon-list-separator":
        return (b) => (_, A) =>
          A === void 0 ||
          (y.skipNull && A === null) ||
          (y.skipEmptyString && A === "")
            ? _
            : A === null
            ? [..._, [c(b, y), ":list="].join("")]
            : [..._, [c(b, y), ":list=", c(A, y)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const b = y.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (_) => (A, x) =>
          x === void 0 ||
          (y.skipNull && x === null) ||
          (y.skipEmptyString && x === "")
            ? A
            : ((x = x === null ? "" : x),
              A.length === 0
                ? [[c(_, y), b, c(x, y)].join("")]
                : [[A, c(x, y)].join(y.arrayFormatSeparator)]);
      }
      default:
        return (b) => (_, A) =>
          A === void 0 ||
          (y.skipNull && A === null) ||
          (y.skipEmptyString && A === "")
            ? _
            : A === null
            ? [..._, c(b, y)]
            : [..._, [c(b, y), "=", c(A, y)].join("")];
    }
  }
  function u(y) {
    let b;
    switch (y.arrayFormat) {
      case "index":
        return (_, A, x) => {
          if (
            ((b = /\[(\d*)\]$/.exec(_)), (_ = _.replace(/\[\d*\]$/, "")), !b)
          ) {
            x[_] = A;
            return;
          }
          x[_] === void 0 && (x[_] = {}), (x[_][b[1]] = A);
        };
      case "bracket":
        return (_, A, x) => {
          if (((b = /(\[\])$/.exec(_)), (_ = _.replace(/\[\]$/, "")), !b)) {
            x[_] = A;
            return;
          }
          if (x[_] === void 0) {
            x[_] = [A];
            return;
          }
          x[_] = [].concat(x[_], A);
        };
      case "colon-list-separator":
        return (_, A, x) => {
          if (((b = /(:list)$/.exec(_)), (_ = _.replace(/:list$/, "")), !b)) {
            x[_] = A;
            return;
          }
          if (x[_] === void 0) {
            x[_] = [A];
            return;
          }
          x[_] = [].concat(x[_], A);
        };
      case "comma":
      case "separator":
        return (_, A, x) => {
          const h = typeof A == "string" && A.includes(y.arrayFormatSeparator),
            E =
              typeof A == "string" &&
              !h &&
              d(A, y).includes(y.arrayFormatSeparator);
          A = E ? d(A, y) : A;
          const I =
            h || E
              ? A.split(y.arrayFormatSeparator).map((C) => d(C, y))
              : A === null
              ? A
              : d(A, y);
          x[_] = I;
        };
      case "bracket-separator":
        return (_, A, x) => {
          const h = /(\[\])$/.test(_);
          if (((_ = _.replace(/\[\]$/, "")), !h)) {
            x[_] = A && d(A, y);
            return;
          }
          const E =
            A === null
              ? []
              : A.split(y.arrayFormatSeparator).map((I) => d(I, y));
          if (x[_] === void 0) {
            x[_] = E;
            return;
          }
          x[_] = [].concat(x[_], E);
        };
      default:
        return (_, A, x) => {
          if (x[_] === void 0) {
            x[_] = A;
            return;
          }
          x[_] = [].concat(x[_], A);
        };
    }
  }
  function l(y) {
    if (typeof y != "string" || y.length !== 1)
      throw new TypeError(
        "arrayFormatSeparator must be single character string"
      );
  }
  function c(y, b) {
    return b.encode ? (b.strict ? t(y) : encodeURIComponent(y)) : y;
  }
  function d(y, b) {
    return b.decode ? n(y) : y;
  }
  function f(y) {
    return Array.isArray(y)
      ? y.sort()
      : typeof y == "object"
      ? f(Object.keys(y))
          .sort((b, _) => Number(b) - Number(_))
          .map((b) => y[b])
      : y;
  }
  function p(y) {
    const b = y.indexOf("#");
    return b !== -1 && (y = y.slice(0, b)), y;
  }
  function m(y) {
    let b = "";
    const _ = y.indexOf("#");
    return _ !== -1 && (b = y.slice(_)), b;
  }
  function g(y) {
    y = p(y);
    const b = y.indexOf("?");
    return b === -1 ? "" : y.slice(b + 1);
  }
  function w(y, b) {
    return (
      b.parseNumbers &&
      !Number.isNaN(Number(y)) &&
      typeof y == "string" &&
      y.trim() !== ""
        ? (y = Number(y))
        : b.parseBooleans &&
          y !== null &&
          (y.toLowerCase() === "true" || y.toLowerCase() === "false") &&
          (y = y.toLowerCase() === "true"),
      y
    );
  }
  function v(y, b) {
    (b = Object.assign(
      {
        decode: !0,
        sort: !0,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: !1,
        parseBooleans: !1,
      },
      b
    )),
      l(b.arrayFormatSeparator);
    const _ = u(b),
      A = Object.create(null);
    if (typeof y != "string" || ((y = y.trim().replace(/^[?#&]/, "")), !y))
      return A;
    for (const x of y.split("&")) {
      if (x === "") continue;
      let [h, E] = r(b.decode ? x.replace(/\+/g, " ") : x, "=");
      (E =
        E === void 0
          ? null
          : ["comma", "separator", "bracket-separator"].includes(b.arrayFormat)
          ? E
          : d(E, b)),
        _(d(h, b), E, A);
    }
    for (const x of Object.keys(A)) {
      const h = A[x];
      if (typeof h == "object" && h !== null)
        for (const E of Object.keys(h)) h[E] = w(h[E], b);
      else A[x] = w(h, b);
    }
    return b.sort === !1
      ? A
      : (b.sort === !0
          ? Object.keys(A).sort()
          : Object.keys(A).sort(b.sort)
        ).reduce((x, h) => {
          const E = A[h];
          return (
            E && typeof E == "object" && !Array.isArray(E)
              ? (x[h] = f(E))
              : (x[h] = E),
            x
          );
        }, Object.create(null));
  }
  (e.extract = g),
    (e.parse = v),
    (e.stringify = (y, b) => {
      if (!y) return "";
      (b = Object.assign(
        {
          encode: !0,
          strict: !0,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
        },
        b
      )),
        l(b.arrayFormatSeparator);
      const _ = (E) =>
          (b.skipNull && s(y[E])) || (b.skipEmptyString && y[E] === ""),
        A = a(b),
        x = {};
      for (const E of Object.keys(y)) _(E) || (x[E] = y[E]);
      const h = Object.keys(x);
      return (
        b.sort !== !1 && h.sort(b.sort),
        h
          .map((E) => {
            const I = y[E];
            return I === void 0
              ? ""
              : I === null
              ? c(E, b)
              : Array.isArray(I)
              ? I.length === 0 && b.arrayFormat === "bracket-separator"
                ? c(E, b) + "[]"
                : I.reduce(A(E), []).join("&")
              : c(E, b) + "=" + c(I, b);
          })
          .filter((E) => E.length > 0)
          .join("&")
      );
    }),
    (e.parseUrl = (y, b) => {
      b = Object.assign({ decode: !0 }, b);
      const [_, A] = r(y, "#");
      return Object.assign(
        { url: _.split("?")[0] || "", query: v(g(y), b) },
        b && b.parseFragmentIdentifier && A
          ? { fragmentIdentifier: d(A, b) }
          : {}
      );
    }),
    (e.stringifyUrl = (y, b) => {
      b = Object.assign({ encode: !0, strict: !0, [o]: !0 }, b);
      const _ = p(y.url).split("?")[0] || "",
        A = e.extract(y.url),
        x = e.parse(A, { sort: !1 }),
        h = Object.assign(x, y.query);
      let E = e.stringify(h, b);
      E && (E = `?${E}`);
      let I = m(y.url);
      return (
        y.fragmentIdentifier &&
          (I = `#${b[o] ? c(y.fragmentIdentifier, b) : y.fragmentIdentifier}`),
        `${_}${E}${I}`
      );
    }),
    (e.pick = (y, b, _) => {
      _ = Object.assign({ parseFragmentIdentifier: !0, [o]: !1 }, _);
      const { url: A, query: x, fragmentIdentifier: h } = e.parseUrl(y, _);
      return e.stringifyUrl(
        { url: A, query: i(x, b), fragmentIdentifier: h },
        _
      );
    }),
    (e.exclude = (y, b, _) => {
      const A = Array.isArray(b) ? (x) => !b.includes(x) : (x, h) => !b(x, h);
      return e.pick(y, A, _);
    });
})(UN);
function Im(e = [], t = []) {
  return [...new Set([...e, ...t])];
}
var QN = Object.defineProperty,
  VN = Object.defineProperties,
  KN = Object.getOwnPropertyDescriptors,
  BE = Object.getOwnPropertySymbols,
  ZN = Object.prototype.hasOwnProperty,
  JN = Object.prototype.propertyIsEnumerable,
  NE = (e, t, n) =>
    t in e
      ? QN(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  YN = (e, t) => {
    for (var n in t || (t = {})) ZN.call(t, n) && NE(e, n, t[n]);
    if (BE) for (var n of BE(t)) JN.call(t, n) && NE(e, n, t[n]);
    return e;
  },
  XN = (e, t) => VN(e, KN(t));
function EC(e) {
  return e.includes(":");
}
function e4(e) {
  return EC(e) ? e.split(":")[0] : e;
}
function _C(e) {
  var t, n, r;
  const i = {};
  if (!t4(e)) return i;
  for (const [s, o] of Object.entries(e)) {
    const a = EC(s) ? [s] : o.chains,
      u = o.methods || [],
      l = o.events || [],
      c = e4(s);
    i[c] = XN(YN({}, i[c]), {
      chains: Im(a, (t = i[c]) == null ? void 0 : t.chains),
      methods: Im(u, (n = i[c]) == null ? void 0 : n.methods),
      events: Im(l, (r = i[c]) == null ? void 0 : r.events),
    });
  }
  return i;
}
function t4(e) {
  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
}
var AC = "eip155",
  n4 = "store",
  xC = "requestedChains",
  My = "wallet_addEthereumChain",
  Xe,
  Lu,
  Ed,
  Ly,
  vb,
  SC,
  _d,
  Fy,
  jy,
  CC,
  vf,
  bb,
  ko,
  wu,
  bf,
  wb,
  wf,
  Eb,
  Ef,
  _b,
  r4 = class extends ZS {
    constructor(e) {
      super({ ...e, options: { isNewChainsStale: !0, ...e.options } }),
        jn(this, Ed),
        jn(this, vb),
        jn(this, _d),
        jn(this, jy),
        jn(this, vf),
        jn(this, ko),
        jn(this, bf),
        jn(this, wf),
        jn(this, Ef),
        (this.id = "walletConnect"),
        (this.name = "WalletConnect"),
        (this.ready = !0),
        jn(this, Xe, void 0),
        jn(this, Lu, void 0),
        (this.onAccountsChanged = (t) => {
          t.length === 0
            ? this.emit("disconnect")
            : this.emit("change", { account: Yi(t[0]) });
        }),
        (this.onChainChanged = (t) => {
          const n = Number(t),
            r = this.isChainUnsupported(n);
          this.emit("change", { chain: { id: n, unsupported: r } });
        }),
        (this.onDisconnect = () => {
          yt(this, ko, wu).call(this, []), this.emit("disconnect");
        }),
        (this.onDisplayUri = (t) => {
          this.emit("message", { type: "display_uri", data: t });
        }),
        (this.onConnect = () => {
          this.emit("connect", {});
        }),
        yt(this, Ed, Ly).call(this);
    }
    async connect({ chainId: e, pairingTopic: t } = {}) {
      var n, r, i, s, o;
      try {
        let a = e;
        if (!a) {
          const m = (n = this.storage) == null ? void 0 : n.getItem(n4),
            g =
              (s =
                (i =
                  (r = m == null ? void 0 : m.state) == null
                    ? void 0
                    : r.data) == null
                  ? void 0
                  : i.chain) == null
                ? void 0
                : s.id;
          g && !this.isChainUnsupported(g)
            ? (a = g)
            : (a = (o = this.chains[0]) == null ? void 0 : o.id);
        }
        if (!a) throw new Error("No chains found on connector.");
        const u = await this.getProvider();
        yt(this, jy, CC).call(this);
        const l = yt(this, _d, Fy).call(this);
        if ((u.session && l && (await u.disconnect()), !u.session || l)) {
          const m = this.chains.filter((g) => g.id !== a).map((g) => g.id);
          this.emit("message", { type: "connecting" }),
            await u.connect({ pairingTopic: t, optionalChains: [a, ...m] }),
            yt(this, ko, wu).call(
              this,
              this.chains.map(({ id: g }) => g)
            );
        }
        const c = await u.enable(),
          d = Yi(c[0]),
          f = await this.getChainId(),
          p = this.isChainUnsupported(f);
        return { account: d, chain: { id: f, unsupported: p } };
      } catch (a) {
        throw /user rejected/i.test(a == null ? void 0 : a.message)
          ? new Vn(a)
          : a;
      }
    }
    async disconnect() {
      const e = await this.getProvider();
      try {
        await e.disconnect();
      } catch (t) {
        if (!/No matching key/i.test(t.message)) throw t;
      } finally {
        yt(this, vf, bb).call(this), yt(this, ko, wu).call(this, []);
      }
    }
    async getAccount() {
      const { accounts: e } = await this.getProvider();
      return Yi(e[0]);
    }
    async getChainId() {
      const { chainId: e } = await this.getProvider();
      return e;
    }
    async getProvider({ chainId: e } = {}) {
      return (
        Ye(this, Xe) || (await yt(this, Ed, Ly).call(this)),
        e && (await this.switchChain(e)),
        Ye(this, Xe)
      );
    }
    async getWalletClient({ chainId: e } = {}) {
      const [t, n] = await Promise.all([
          this.getProvider({ chainId: e }),
          this.getAccount(),
        ]),
        r = this.chains.find((i) => i.id === e);
      if (!t) throw new Error("provider is required.");
      return WS({ account: n, chain: r, transport: IS(t) });
    }
    async isAuthorized() {
      try {
        const [e, t] = await Promise.all([
            this.getAccount(),
            this.getProvider(),
          ]),
          n = yt(this, _d, Fy).call(this);
        if (!e) return !1;
        if (n && t.session) {
          try {
            await t.disconnect();
          } catch {}
          return !1;
        }
        return !0;
      } catch {
        return !1;
      }
    }
    async switchChain(e) {
      var n, r;
      const t = this.chains.find((i) => i.id === e);
      if (!t) throw new rs(new Error("chain not found on connector."));
      try {
        const i = await this.getProvider(),
          s = yt(this, wf, Eb).call(this),
          o = yt(this, Ef, _b).call(this);
        if (!s.includes(e) && o.includes(My)) {
          await i.request({
            method: My,
            params: [
              {
                chainId: he(t.id),
                blockExplorerUrls: [
                  (r = (n = t.blockExplorers) == null ? void 0 : n.default) ==
                  null
                    ? void 0
                    : r.url,
                ],
                chainName: t.name,
                nativeCurrency: t.nativeCurrency,
                rpcUrls: [...t.rpcUrls.default.http],
              },
            ],
          });
          const u = yt(this, bf, wb).call(this);
          u.push(e), yt(this, ko, wu).call(this, u);
        }
        return (
          await i.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: he(e) }],
          }),
          t
        );
      } catch (i) {
        const s = typeof i == "string" ? i : i == null ? void 0 : i.message;
        throw /user rejected request/i.test(s) ? new Vn(i) : new rs(i);
      }
    }
  };
Xe = new WeakMap();
Lu = new WeakMap();
Ed = new WeakSet();
Ly = async function () {
  return (
    !Ye(this, Lu) &&
      typeof window < "u" &&
      db(this, Lu, yt(this, vb, SC).call(this)),
    Ye(this, Lu)
  );
};
vb = new WeakSet();
SC = async function () {
  const { EthereumProvider: e } = await qh(
      () => import("./index.es-BxAYEJRk.js"),
      __vite__mapDeps([])
    ),
    t = this.chains.map(({ id: n }) => n);
  if (t.length) {
    const {
      projectId: n,
      showQrModal: r = !0,
      qrModalOptions: i,
      metadata: s,
      relayUrl: o,
    } = this.options;
    db(
      this,
      Xe,
      await e.init({
        showQrModal: r,
        qrModalOptions: i,
        projectId: n,
        optionalChains: t,
        rpcMap: Object.fromEntries(
          this.chains.map((a) => [a.id, a.rpcUrls.default.http[0]])
        ),
        metadata: s,
        relayUrl: o,
      })
    );
  }
};
_d = new WeakSet();
Fy = function () {
  if (
    yt(this, Ef, _b).call(this).includes(My) ||
    !this.options.isNewChainsStale
  )
    return !1;
  const t = yt(this, bf, wb).call(this),
    n = this.chains.map(({ id: i }) => i),
    r = yt(this, wf, Eb).call(this);
  return r.length && !r.some((i) => n.includes(i))
    ? !1
    : !n.every((i) => t.includes(i));
};
jy = new WeakSet();
CC = function () {
  Ye(this, Xe) &&
    (yt(this, vf, bb).call(this),
    Ye(this, Xe).on("accountsChanged", this.onAccountsChanged),
    Ye(this, Xe).on("chainChanged", this.onChainChanged),
    Ye(this, Xe).on("disconnect", this.onDisconnect),
    Ye(this, Xe).on("session_delete", this.onDisconnect),
    Ye(this, Xe).on("display_uri", this.onDisplayUri),
    Ye(this, Xe).on("connect", this.onConnect));
};
vf = new WeakSet();
bb = function () {
  Ye(this, Xe) &&
    (Ye(this, Xe).removeListener("accountsChanged", this.onAccountsChanged),
    Ye(this, Xe).removeListener("chainChanged", this.onChainChanged),
    Ye(this, Xe).removeListener("disconnect", this.onDisconnect),
    Ye(this, Xe).removeListener("session_delete", this.onDisconnect),
    Ye(this, Xe).removeListener("display_uri", this.onDisplayUri),
    Ye(this, Xe).removeListener("connect", this.onConnect));
};
ko = new WeakSet();
wu = function (e) {
  var t;
  (t = this.storage) == null || t.setItem(xC, e);
};
bf = new WeakSet();
wb = function () {
  var e;
  return ((e = this.storage) == null ? void 0 : e.getItem(xC)) ?? [];
};
wf = new WeakSet();
Eb = function () {
  var r, i, s;
  if (!Ye(this, Xe)) return [];
  const e = (r = Ye(this, Xe).session) == null ? void 0 : r.namespaces;
  return e
    ? ((s = (i = _C(e)[AC]) == null ? void 0 : i.chains) == null
        ? void 0
        : s.map((o) => parseInt(o.split(":")[1] || ""))) ?? []
    : [];
};
Ef = new WeakSet();
_b = function () {
  var r, i;
  if (!Ye(this, Xe)) return [];
  const e = (r = Ye(this, Xe).session) == null ? void 0 : r.namespaces;
  return e ? ((i = _C(e)[AC]) == null ? void 0 : i.methods) ?? [] : [];
};
function i4({ rpc: e }) {
  return function (t) {
    const n = e(t);
    return !n || n.http === ""
      ? null
      : {
          chain: {
            ...t,
            rpcUrls: { ...t.rpcUrls, default: { http: [n.http] } },
          },
          rpcUrls: {
            http: [n.http],
            webSocket: n.webSocket ? [n.webSocket] : void 0,
          },
        };
  };
}
const s4 = "wallet_addEthereumChain";
let o4 = class {
  constructor(t, n) {
    (this.wagmi = {}),
      (this.chains = []),
      (this.namespace = "eip155"),
      (this.disconnect = o8),
      (this.getAccount = pb),
      (this.watchAccount = nC),
      (this.fetchBalance = p8),
      (this.getNetwork = mb),
      (this.watchNetwork = rC),
      (this.switchNetwork = m8),
      (this.fetchEnsName = g8),
      (this.fetchEnsAvatar = y8),
      (this.wagmi = t),
      (this.chains = n);
  }
  getWalletConnectConnector() {
    const t = this.wagmi.connectors.find((n) => n.id === "walletConnect");
    if (!t) throw new Error("WalletConnectConnector is required");
    return t;
  }
  async connectWalletConnectProvider(t, n) {
    return (
      await t.getProvider(),
      new Promise((r) => {
        t.once("message", (i) => {
          i.type === "display_uri" && (n(i.data), r());
        });
      })
    );
  }
  getConnectorById(t) {
    const n = this.wagmi.connectors.find((r) => r.id === t);
    if (!n) throw new Error(`Connector for id ${t} was not found`);
    return n;
  }
  getConnectors() {
    return this.wagmi.connectors.filter((t) => !t.id.includes("walletConnect"));
  }
  async connectWalletConnect(t, n) {
    const r = this.getWalletConnectConnector(),
      i = { connector: r };
    return (
      n && (i.chainId = n),
      Promise.all([gE(i), this.connectWalletConnectProvider(r, t)])
    );
  }
  async connectConnector(t, n) {
    const r = { connector: this.getConnectorById(t) };
    return n && (r.chainId = n), await gE(r);
  }
  isInjectedProviderInstalled() {
    return typeof window.ethereum < "u";
  }
  safeCheckInjectedProvider(t) {
    var n;
    try {
      const r = String(t);
      return !!((n = window.ethereum) != null && n[r]);
    } catch (r) {
      return console.error(r), !1;
    }
  }
  async getConnectedChainIds() {
    var t, n, r;
    const i =
        (n =
          (t = (await this.getWalletConnectConnector().getProvider()).signer) ==
          null
            ? void 0
            : t.session) == null
          ? void 0
          : n.namespaces,
      s =
        (r = i == null ? void 0 : i[this.namespace]) == null
          ? void 0
          : r.methods;
    if (s != null && s.includes(s4)) return "ALL";
    if (i) {
      const o = [];
      return (
        Object.keys(i).forEach((a) => {
          a.includes(this.namespace) && o.push(...i[a].accounts);
        }),
        o == null ? void 0 : o.map((a) => a.split(":")[1])
      );
    }
    return "ALL";
  }
};
const a4 = "eip155",
  u4 = "https://rpc.walletconnect.com";
function c4({ projectId: e }) {
  return i4({
    rpc: (t) => {
      var n;
      return [
        1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 280, 324, 420, 42161, 42220,
        43114, 80001, 421611, 421613, 1313161554, 1313161555,
      ].includes(t.id)
        ? { http: `${u4}/v1/?chainId=${a4}:${t.id}&projectId=${e}` }
        : {
            http: t.rpcUrls.default.http[0],
            webSocket:
              (n = t.rpcUrls.default.webSocket) == null ? void 0 : n[0],
          };
    },
  });
}
function l4({ chains: e, projectId: t }) {
  return [
    new r4({ chains: e, options: { projectId: t, showQrModal: !1 } }),
    new JS({ chains: e, options: { shimDisconnect: !0 } }),
  ];
}
const d4 = Symbol(),
  ME = Object.getPrototypeOf,
  Uy = new WeakMap(),
  f4 = (e) =>
    e &&
    (Uy.has(e)
      ? Uy.get(e)
      : ME(e) === Object.prototype || ME(e) === Array.prototype),
  h4 = (e) => (f4(e) && e[d4]) || null,
  LE = (e, t = !0) => {
    Uy.set(e, t);
  };
var _f = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const km = (e) => typeof e == "object" && e !== null,
  Ri = new WeakMap(),
  Vl = new WeakSet(),
  p4 = (
    e = Object.is,
    t = (c, d) => new Proxy(c, d),
    n = (c) =>
      km(c) &&
      !Vl.has(c) &&
      (Array.isArray(c) || !(Symbol.iterator in c)) &&
      !(c instanceof WeakMap) &&
      !(c instanceof WeakSet) &&
      !(c instanceof Error) &&
      !(c instanceof Number) &&
      !(c instanceof Date) &&
      !(c instanceof String) &&
      !(c instanceof RegExp) &&
      !(c instanceof ArrayBuffer),
    r = (c) => c.configurable && c.enumerable && c.writable,
    i = (c) => {
      switch (c.status) {
        case "fulfilled":
          return c.value;
        case "rejected":
          throw c.reason;
        default:
          throw c;
      }
    },
    s = new WeakMap(),
    o = (c, d, f = i) => {
      const p = s.get(c);
      if ((p == null ? void 0 : p[0]) === d) return p[1];
      const m = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c));
      return (
        LE(m, !0),
        s.set(c, [d, m]),
        Reflect.ownKeys(c).forEach((g) => {
          if (Object.getOwnPropertyDescriptor(m, g)) return;
          const w = Reflect.get(c, g),
            v = { value: w, enumerable: !0, configurable: !0 };
          if (Vl.has(w)) LE(w, !1);
          else if (w instanceof Promise) delete v.value, (v.get = () => f(w));
          else if (Ri.has(w)) {
            const [y, b] = Ri.get(w);
            v.value = o(y, b(), f);
          }
          Object.defineProperty(m, g, v);
        }),
        Object.preventExtensions(m)
      );
    },
    a = new WeakMap(),
    u = [1, 1],
    l = (c) => {
      if (!km(c)) throw new Error("object required");
      const d = a.get(c);
      if (d) return d;
      let f = u[0];
      const p = new Set(),
        m = (k, O = ++u[0]) => {
          f !== O && ((f = O), p.forEach((R) => R(k, O)));
        };
      let g = u[1];
      const w = (k = ++u[1]) => (
          g !== k &&
            !p.size &&
            ((g = k),
            y.forEach(([O]) => {
              const R = O[1](k);
              R > f && (f = R);
            })),
          f
        ),
        v = (k) => (O, R) => {
          const N = [...O];
          (N[1] = [k, ...N[1]]), m(N, R);
        },
        y = new Map(),
        b = (k, O) => {
          if ((_f ? "production" : void 0) !== "production" && y.has(k))
            throw new Error("prop listener already exists");
          if (p.size) {
            const R = O[3](v(k));
            y.set(k, [O, R]);
          } else y.set(k, [O]);
        },
        _ = (k) => {
          var O;
          const R = y.get(k);
          R && (y.delete(k), (O = R[1]) == null || O.call(R));
        },
        A = (k) => (
          p.add(k),
          p.size === 1 &&
            y.forEach(([R, N], S) => {
              if ((_f ? "production" : void 0) !== "production" && N)
                throw new Error("remove already exists");
              const T = R[3](v(S));
              y.set(S, [R, T]);
            }),
          () => {
            p.delete(k),
              p.size === 0 &&
                y.forEach(([R, N], S) => {
                  N && (N(), y.set(S, [R]));
                });
          }
        ),
        x = Array.isArray(c) ? [] : Object.create(Object.getPrototypeOf(c)),
        h = (k, O, R, N, S) => {
          if (k && (e(O, N) || (a.has(N) && e(O, a.get(N))))) return;
          _(R), km(N) && (N = h4(N) || N);
          let T = N;
          if (N instanceof Promise)
            N.then((D) => {
              (N.status = "fulfilled"), (N.value = D), m(["resolve", [R], D]);
            }).catch((D) => {
              (N.status = "rejected"), (N.reason = D), m(["reject", [R], D]);
            });
          else {
            !Ri.has(N) && n(N) && (T = l(N));
            const D = !Vl.has(T) && Ri.get(T);
            D && b(R, D);
          }
          S(T), m(["set", [R], N, O]);
        },
        I = t(x, {
          deleteProperty(k, O) {
            const R = Reflect.get(k, O);
            _(O);
            const N = Reflect.deleteProperty(k, O);
            return N && m(["delete", [O], R]), N;
          },
          set(k, O, R, N) {
            const S = Reflect.has(k, O),
              T = Reflect.get(k, O, N);
            return (
              h(S, T, O, R, (D) => {
                Reflect.set(k, O, D, N);
              }),
              !0
            );
          },
          defineProperty(k, O, R) {
            if (r(R)) {
              const N = Reflect.getOwnPropertyDescriptor(k, O);
              if (!N || r(N))
                return (
                  h(
                    !!N && "value" in N,
                    N == null ? void 0 : N.value,
                    O,
                    R.value,
                    (S) => {
                      Reflect.defineProperty(k, O, { ...R, value: S });
                    }
                  ),
                  !0
                );
            }
            return Reflect.defineProperty(k, O, R);
          },
        });
      a.set(c, I);
      const C = [x, w, o, A];
      return (
        Ri.set(I, C),
        Reflect.ownKeys(c).forEach((k) => {
          const O = Object.getOwnPropertyDescriptor(c, k);
          "value" in O && ((I[k] = c[k]), delete O.value, delete O.writable),
            Object.defineProperty(x, k, O);
        }),
        I
      );
    }
  ) => [l, Ri, Vl, e, t, n, r, i, s, o, a, u],
  [m4] = p4();
function Mr(e = {}) {
  return m4(e);
}
function vi(e, t, n) {
  const r = Ri.get(e);
  (_f ? "production" : void 0) !== "production" &&
    !r &&
    console.warn("Please use proxy object");
  let i;
  const s = [],
    o = r[3];
  let a = !1;
  const l = o((c) => {
    if ((s.push(c), n)) {
      t(s.splice(0));
      return;
    }
    i ||
      (i = Promise.resolve().then(() => {
        (i = void 0), a && t(s.splice(0));
      }));
  });
  return (
    (a = !0),
    () => {
      (a = !1), l();
    }
  );
}
function y4(e, t) {
  const n = Ri.get(e);
  (_f ? "production" : void 0) !== "production" &&
    !n &&
    console.warn("Please use proxy object");
  const [r, i, s] = n;
  return s(r, i(), t);
}
const mt = Mr({
    history: ["ConnectWallet"],
    view: "ConnectWallet",
    data: void 0,
  }),
  Qo = {
    state: mt,
    subscribe(e) {
      return vi(mt, () => e(mt));
    },
    push(e, t) {
      e !== mt.view && ((mt.view = e), t && (mt.data = t), mt.history.push(e));
    },
    reset(e) {
      (mt.view = e), (mt.history = [e]);
    },
    replace(e) {
      mt.history.length > 1 &&
        ((mt.history[mt.history.length - 1] = e), (mt.view = e));
    },
    goBack() {
      if (mt.history.length > 1) {
        mt.history.pop();
        const [e] = mt.history.slice(-1);
        mt.view = e;
      }
    },
    setData(e) {
      mt.data = e;
    },
  },
  vt = {
    WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE",
    W3M_VERSION: "W3M_VERSION",
    W3M_PREFER_INJECTED_URL_FLAG: "w3mPreferInjected",
    RECOMMENDED_WALLET_AMOUNT: 9,
    isMobile() {
      return typeof window < "u"
        ? !!(
            window.matchMedia("(pointer:coarse)").matches ||
            /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(
              navigator.userAgent
            )
          )
        : !1;
    },
    isAndroid() {
      return (
        vt.isMobile() && navigator.userAgent.toLowerCase().includes("android")
      );
    },
    isIos() {
      const e = navigator.userAgent.toLowerCase();
      return vt.isMobile() && (e.includes("iphone") || e.includes("ipad"));
    },
    isHttpUrl(e) {
      return e.startsWith("http://") || e.startsWith("https://");
    },
    isArray(e) {
      return Array.isArray(e) && e.length > 0;
    },
    formatNativeUrl(e, t, n) {
      if (vt.isHttpUrl(e)) return this.formatUniversalUrl(e, t, n);
      let r = e;
      r.includes("://") ||
        ((r = e.replaceAll("/", "").replaceAll(":", "")), (r = `${r}://`)),
        r.endsWith("/") || (r = `${r}/`),
        this.setWalletConnectDeepLink(r, n);
      const i = encodeURIComponent(t);
      return `${r}wc?uri=${i}`;
    },
    formatUniversalUrl(e, t, n) {
      if (!vt.isHttpUrl(e)) return this.formatNativeUrl(e, t, n);
      let r = e;
      r.endsWith("/") || (r = `${r}/`), this.setWalletConnectDeepLink(r, n);
      const i = encodeURIComponent(t);
      return `${r}wc?uri=${i}`;
    },
    async wait(e) {
      return new Promise((t) => {
        setTimeout(t, e);
      });
    },
    openHref(e, t) {
      window.open(e, t, "noreferrer noopener");
    },
    setWalletConnectDeepLink(e, t) {
      try {
        localStorage.setItem(
          vt.WALLETCONNECT_DEEPLINK_CHOICE,
          JSON.stringify({ href: e, name: t })
        );
      } catch {
        console.info("Unable to set WalletConnect deep link");
      }
    },
    setWalletConnectAndroidDeepLink(e) {
      try {
        const [t] = e.split("?");
        localStorage.setItem(
          vt.WALLETCONNECT_DEEPLINK_CHOICE,
          JSON.stringify({ href: t, name: "Android" })
        );
      } catch {
        console.info("Unable to set WalletConnect android deep link");
      }
    },
    removeWalletConnectDeepLink() {
      try {
        localStorage.removeItem(vt.WALLETCONNECT_DEEPLINK_CHOICE);
      } catch {
        console.info("Unable to remove WalletConnect deep link");
      }
    },
    setWeb3ModalVersionInStorage() {
      try {
        typeof localStorage < "u" &&
          localStorage.setItem(vt.W3M_VERSION, "2.7.1");
      } catch {
        console.info("Unable to set Web3Modal version in storage");
      }
    },
    getWalletRouterData() {
      var e;
      const t = (e = Qo.state.data) == null ? void 0 : e.Wallet;
      if (!t) throw new Error('Missing "Wallet" view data');
      return t;
    },
    getSwitchNetworkRouterData() {
      var e;
      const t = (e = Qo.state.data) == null ? void 0 : e.SwitchNetwork;
      if (!t) throw new Error('Missing "SwitchNetwork" view data');
      return t;
    },
    isPreferInjectedFlag() {
      return typeof location < "u"
        ? new URLSearchParams(location.search).has(
            vt.W3M_PREFER_INJECTED_URL_FLAG
          )
        : !1;
    },
  };
let Pm;
const Sr = {
    ethereumClient: void 0,
    setEthereumClient(e) {
      Pm = e;
    },
    client() {
      if (Pm) return Pm;
      throw new Error("ClientCtrl has no client set");
    },
  },
  g4 =
    typeof location < "u" &&
    (location.hostname.includes("localhost") ||
      location.protocol.includes("https")),
  Wt = Mr({
    enabled: g4,
    userSessionId: "",
    events: [],
    connectedWalletId: void 0,
  }),
  v4 = {
    state: Wt,
    subscribe(e) {
      return vi(Wt.events, () => e(y4(Wt.events[Wt.events.length - 1])));
    },
    initialize() {
      Wt.enabled &&
        typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" &&
        (Wt.userSessionId = crypto.randomUUID());
    },
    setConnectedWalletId(e) {
      Wt.connectedWalletId = e;
    },
    click(e) {
      if (Wt.enabled) {
        const t = {
          type: "CLICK",
          name: e.name,
          userSessionId: Wt.userSessionId,
          timestamp: Date.now(),
          data: e,
        };
        Wt.events.push(t);
      }
    },
    track(e) {
      if (Wt.enabled) {
        const t = {
          type: "TRACK",
          name: e.name,
          userSessionId: Wt.userSessionId,
          timestamp: Date.now(),
          data: e,
        };
        Wt.events.push(t);
      }
    },
    view(e) {
      if (Wt.enabled) {
        const t = {
          type: "VIEW",
          name: e.name,
          userSessionId: Wt.userSessionId,
          timestamp: Date.now(),
          data: e,
        };
        Wt.events.push(t);
      }
    },
  },
  Mn = Mr({
    selectedChain: void 0,
    chains: void 0,
    isCustomDesktop: !1,
    isCustomMobile: !1,
    isDataLoaded: !1,
    isUiLoaded: !1,
    isPreferInjected: !1,
  }),
  Vr = {
    state: Mn,
    subscribe(e) {
      return vi(Mn, () => e(Mn));
    },
    setChains(e) {
      Mn.chains = e;
    },
    getSelectedChain() {
      const e = Sr.client().getNetwork().chain;
      return e && (Mn.selectedChain = e), Mn.selectedChain;
    },
    setSelectedChain(e) {
      Mn.selectedChain = e;
    },
    setIsCustomDesktop(e) {
      Mn.isCustomDesktop = e;
    },
    setIsCustomMobile(e) {
      Mn.isCustomMobile = e;
    },
    setIsDataLoaded(e) {
      Mn.isDataLoaded = e;
    },
    setIsUiLoaded(e) {
      Mn.isUiLoaded = e;
    },
    setIsPreferInjected(e) {
      Mn.isPreferInjected = e;
    },
  },
  Kl = Mr({
    projectId: "",
    mobileWallets: void 0,
    desktopWallets: void 0,
    walletImages: void 0,
    chainImages: void 0,
    tokenImages: void 0,
    tokenContracts: void 0,
    enableNetworkView: !1,
    enableAccountView: !0,
    enableExplorer: !0,
    defaultChain: void 0,
    explorerExcludedWalletIds: void 0,
    explorerRecommendedWalletIds: void 0,
    termsOfServiceUrl: void 0,
    privacyPolicyUrl: void 0,
  }),
  hi = {
    state: Kl,
    subscribe(e) {
      return vi(Kl, () => e(Kl));
    },
    setConfig(e) {
      var t, n;
      v4.initialize(),
        Vr.setIsCustomMobile(!!((t = e.mobileWallets) != null && t.length)),
        Vr.setIsCustomDesktop(!!((n = e.desktopWallets) != null && n.length)),
        Vr.setChains(Sr.client().chains),
        Vr.setIsPreferInjected(
          Sr.client().isInjectedProviderInstalled() && vt.isPreferInjectedFlag()
        ),
        e.defaultChain && Vr.setSelectedChain(e.defaultChain),
        vt.setWeb3ModalVersionInStorage(),
        Object.assign(Kl, e);
    },
  },
  b4 = "eip155",
  w4 = "https://rpc.walletconnect.com",
  E4 = {
    async getIdentity(e, t) {
      const { projectId: n } = hi.state,
        r = `${b4}:${t}`,
        i = `${w4}/v1/identity/${e}?chainId=${r}&projectId=${n}`;
      return (await fetch(i)).json();
    },
  },
  Ne = Mr({
    address: void 0,
    profileName: void 0,
    profileAvatar: void 0,
    profileLoading: !1,
    balanceLoading: !1,
    balance: void 0,
    isConnected: !1,
  }),
  _4 = {
    state: Ne,
    subscribe(e) {
      return vi(Ne, () => e(Ne));
    },
    getAccount() {
      const e = Sr.client().getAccount();
      (Ne.address = e.address), (Ne.isConnected = e.isConnected);
    },
    async fetchProfile(e, t) {
      var n;
      try {
        (Ne.profileLoading = !0),
          (Ne.profileName = null),
          (Ne.profileAvatar = null);
        const r = t ?? Ne.address,
          i = 1,
          s =
            (n = Vr.state.chains) == null ? void 0 : n.find((o) => o.id === i);
        if (r && s) {
          try {
            const o = await E4.getIdentity(r, i);
            (Ne.profileName = o.name), (Ne.profileAvatar = o.avatar);
          } catch {
            const o = await Sr.client().fetchEnsName({
              address: r,
              chainId: i,
            });
            if (((Ne.profileName = o), o)) {
              const a = await Sr.client().fetchEnsAvatar({
                name: o,
                chainId: i,
              });
              Ne.profileAvatar = a;
            }
          }
          Ne.profileAvatar && (await e(Ne.profileAvatar));
        }
      } finally {
        Ne.profileLoading = !1;
      }
    },
    async fetchBalance(e) {
      try {
        const { chain: t } = Sr.client().getNetwork(),
          { tokenContracts: n } = hi.state;
        let r;
        t && n && (r = n[t.id]), (Ne.balanceLoading = !0);
        const i = e ?? Ne.address;
        if (i) {
          const s = await Sr.client().fetchBalance({ address: i, token: r });
          Ne.balance = { amount: s.formatted, symbol: s.symbol };
        }
      } finally {
        Ne.balanceLoading = !1;
      }
    },
    setAddress(e) {
      Ne.address = e;
    },
    setIsConnected(e) {
      Ne.isConnected = e;
    },
    resetBalance() {
      Ne.balance = void 0;
    },
    resetAccount() {
      (Ne.address = void 0),
        (Ne.isConnected = !1),
        (Ne.profileName = void 0),
        (Ne.profileAvatar = void 0),
        (Ne.balance = void 0);
    },
  };
var A4 = Object.defineProperty,
  FE = Object.getOwnPropertySymbols,
  x4 = Object.prototype.hasOwnProperty,
  S4 = Object.prototype.propertyIsEnumerable,
  jE = (e, t, n) =>
    t in e
      ? A4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  C4 = (e, t) => {
    for (var n in t || (t = {})) x4.call(t, n) && jE(e, n, t[n]);
    if (FE) for (var n of FE(t)) S4.call(t, n) && jE(e, n, t[n]);
    return e;
  };
const $y = "https://explorer-api.walletconnect.com",
  Hy = "w3m",
  zy = "js-2.7.1";
async function Zl(e, t) {
  const n = C4({ sdkType: Hy, sdkVersion: zy }, t),
    r = new URL(e, $y);
  return (
    r.searchParams.append("projectId", hi.state.projectId),
    Object.entries(n).forEach(([i, s]) => {
      s && r.searchParams.append(i, String(s));
    }),
    (await fetch(r)).json()
  );
}
const xi = {
  async getDesktopListings(e) {
    return Zl("/w3m/v1/getDesktopListings", e);
  },
  async getMobileListings(e) {
    return Zl("/w3m/v1/getMobileListings", e);
  },
  async getInjectedListings(e) {
    return Zl("/w3m/v1/getInjectedListings", e);
  },
  async getAllListings(e) {
    return Zl("/w3m/v1/getAllListings", e);
  },
  getWalletImageUrl(e) {
    return `${$y}/w3m/v1/getWalletImage/${e}?projectId=${hi.state.projectId}&sdkType=${Hy}&sdkVersion=${zy}`;
  },
  getAssetImageUrl(e) {
    return `${$y}/w3m/v1/getAssetImage/${e}?projectId=${hi.state.projectId}&sdkType=${Hy}&sdkVersion=${zy}`;
  },
};
var T4 = Object.defineProperty,
  UE = Object.getOwnPropertySymbols,
  I4 = Object.prototype.hasOwnProperty,
  k4 = Object.prototype.propertyIsEnumerable,
  $E = (e, t, n) =>
    t in e
      ? T4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  P4 = (e, t) => {
    for (var n in t || (t = {})) I4.call(t, n) && $E(e, n, t[n]);
    if (UE) for (var n of UE(t)) k4.call(t, n) && $E(e, n, t[n]);
    return e;
  };
const HE = vt.isMobile(),
  Ln = Mr({
    wallets: { listings: [], total: 0, page: 1 },
    injectedWallets: [],
    search: { listings: [], total: 0, page: 1 },
    recomendedWallets: [],
  }),
  aK = {
    state: Ln,
    async getRecomendedWallets() {
      const { explorerRecommendedWalletIds: e, explorerExcludedWalletIds: t } =
        hi.state;
      if (e === "NONE" || (t === "ALL" && !e)) return Ln.recomendedWallets;
      if (vt.isArray(e)) {
        const n = { recommendedIds: e.join(",") },
          { listings: r } = await xi.getAllListings(n),
          i = Object.values(r);
        i.sort((s, o) => {
          const a = e.indexOf(s.id),
            u = e.indexOf(o.id);
          return a - u;
        }),
          (Ln.recomendedWallets = i);
      } else {
        const n = vt.isArray(t),
          r = {
            page: 1,
            entries: vt.RECOMMENDED_WALLET_AMOUNT,
            version: 2,
            excludedIds: n ? t.join(",") : void 0,
          },
          { listings: i } = HE
            ? await xi.getMobileListings(r)
            : await xi.getDesktopListings(r);
        Ln.recomendedWallets = Object.values(i);
      }
      return Ln.recomendedWallets;
    },
    async getWallets(e) {
      const t = P4({}, e),
        { explorerRecommendedWalletIds: n, explorerExcludedWalletIds: r } =
          hi.state,
        { recomendedWallets: i } = Ln;
      if (r === "ALL") return Ln.wallets;
      i.length
        ? (t.excludedIds = i.map((d) => d.id).join(","))
        : vt.isArray(n) && (t.excludedIds = n.join(",")),
        vt.isArray(r) &&
          (t.excludedIds = [t.excludedIds, r].filter(Boolean).join(","));
      const { page: s, search: o } = e,
        { listings: a, total: u } = HE
          ? await xi.getMobileListings(t)
          : await xi.getDesktopListings(t),
        l = Object.values(a),
        c = o ? "search" : "wallets";
      return (
        (Ln[c] = {
          listings: [...Ln[c].listings, ...l],
          total: u,
          page: s ?? 1,
        }),
        { listings: l, total: u }
      );
    },
    async getInjectedWallets() {
      const { listings: e } = await xi.getInjectedListings({}),
        t = Object.values(e);
      return (Ln.injectedWallets = t), Ln.injectedWallets;
    },
    getWalletImageUrl(e) {
      return xi.getWalletImageUrl(e);
    },
    getAssetImageUrl(e) {
      return xi.getAssetImageUrl(e);
    },
    resetSearch() {
      Ln.search = { listings: [], total: 0, page: 1 };
    },
  },
  Eo = Mr({ pairingEnabled: !1, pairingUri: "", pairingError: !1 }),
  Dm = {
    state: Eo,
    subscribe(e) {
      return vi(Eo, () => e(Eo));
    },
    setPairingUri(e) {
      Eo.pairingUri = e;
    },
    setPairingError(e) {
      Eo.pairingError = e;
    },
    setPairingEnabled(e) {
      Eo.pairingEnabled = e;
    },
  },
  _o = Mr({ open: !1 }),
  uK = {
    state: _o,
    subscribe(e) {
      return vi(_o, () => e(_o));
    },
    async open(e) {
      return new Promise((t) => {
        const {
            isUiLoaded: n,
            isDataLoaded: r,
            isPreferInjected: i,
            selectedChain: s,
          } = Vr.state,
          { isConnected: o } = _4.state,
          { enableNetworkView: a } = hi.state;
        if (
          (Dm.setPairingEnabled(!0),
          o || vt.removeWalletConnectDeepLink(),
          e != null && e.route)
        )
          Qo.reset(e.route);
        else if (o) Qo.reset("Account");
        else if (a) Qo.reset("SelectNetwork");
        else if (i) {
          Sr.client()
            .connectConnector("injected", s == null ? void 0 : s.id)
            .catch((l) => console.error(l)),
            t();
          return;
        } else Qo.reset("ConnectWallet");
        const { pairingUri: u } = Dm.state;
        if (n && r && (u || o)) (_o.open = !0), t();
        else {
          const l = setInterval(() => {
            const c = Vr.state,
              d = Dm.state;
            c.isUiLoaded &&
              c.isDataLoaded &&
              (d.pairingUri || o) &&
              (clearInterval(l), (_o.open = !0), t());
          }, 200);
        }
      });
    },
    close() {
      _o.open = !1;
    },
  };
var D4 = Object.defineProperty,
  zE = Object.getOwnPropertySymbols,
  O4 = Object.prototype.hasOwnProperty,
  R4 = Object.prototype.propertyIsEnumerable,
  GE = (e, t, n) =>
    t in e
      ? D4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  B4 = (e, t) => {
    for (var n in t || (t = {})) O4.call(t, n) && GE(e, n, t[n]);
    if (zE) for (var n of zE(t)) R4.call(t, n) && GE(e, n, t[n]);
    return e;
  };
function N4() {
  return (
    typeof matchMedia < "u" &&
    matchMedia("(prefers-color-scheme: dark)").matches
  );
}
const uu = Mr({ themeMode: N4() ? "dark" : "light" }),
  M4 = {
    state: uu,
    subscribe(e) {
      return vi(uu, () => e(uu));
    },
    setThemeConfig(e) {
      const { themeMode: t, themeVariables: n } = e;
      t && (uu.themeMode = t), n && (uu.themeVariables = B4({}, n));
    },
  },
  As = Mr({ open: !1, message: "", variant: "success" }),
  cK = {
    state: As,
    subscribe(e) {
      return vi(As, () => e(As));
    },
    openToast(e, t) {
      (As.open = !0), (As.message = e), (As.variant = t);
    },
    closeToast() {
      As.open = !1;
    },
  };
var L4 = Object.defineProperty,
  qE = Object.getOwnPropertySymbols,
  F4 = Object.prototype.hasOwnProperty,
  j4 = Object.prototype.propertyIsEnumerable,
  WE = (e, t, n) =>
    t in e
      ? L4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  U4 = (e, t) => {
    for (var n in t || (t = {})) F4.call(t, n) && WE(e, n, t[n]);
    if (qE) for (var n of qE(t)) j4.call(t, n) && WE(e, n, t[n]);
    return e;
  };
function $4(e) {
  return Me.createElement("w3m-core-button", U4({}, e));
}
var H4 = Object.defineProperty,
  QE = Object.getOwnPropertySymbols,
  z4 = Object.prototype.hasOwnProperty,
  G4 = Object.prototype.propertyIsEnumerable,
  VE = (e, t, n) =>
    t in e
      ? H4(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  q4 = (e, t) => {
    for (var n in t || (t = {})) z4.call(t, n) && VE(e, n, t[n]);
    if (QE) for (var n of QE(t)) G4.call(t, n) && VE(e, n, t[n]);
    return e;
  };
function W4(e) {
  return Me.createElement("w3m-modal", q4({}, e));
}
var KE = Object.getOwnPropertySymbols,
  Q4 = Object.prototype.hasOwnProperty,
  V4 = Object.prototype.propertyIsEnumerable,
  K4 = (e, t) => {
    var n = {};
    for (var r in e) Q4.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && KE)
      for (var r of KE(e)) t.indexOf(r) < 0 && V4.call(e, r) && (n[r] = e[r]);
    return n;
  };
function Z4(e) {
  var t = e,
    { ethereumClient: n } = t,
    r = K4(t, ["ethereumClient"]);
  const i = G.useCallback(async () => {
    M4.setThemeConfig(r),
      n && Sr.setEthereumClient(n),
      hi.setConfig(r),
      await qh(() => import("./index-0Vs2b2Km.js"), __vite__mapDeps([0, 1])),
      Vr.setIsUiLoaded(!0);
  }, [n, r]);
  return (
    G.useEffect(() => {
      i();
    }, [i]),
    Me.createElement(W4, null)
  );
}
const J4 = G.memo(Z4);
function Y4({
  storage: e,
  key: t = "REACT_QUERY_OFFLINE_CACHE",
  throttleTime: n = 1e3,
  serialize: r = JSON.stringify,
  deserialize: i = JSON.parse,
  retry: s,
}) {
  if (e) {
    const o = (a) => {
      try {
        e.setItem(t, r(a));
        return;
      } catch (u) {
        return u;
      }
    };
    return {
      persistClient: X4((a) => {
        let u = a,
          l = o(u),
          c = 0;
        for (; l && u; )
          c++,
            (u =
              s == null
                ? void 0
                : s({ persistedClient: u, error: l, errorCount: c })),
            u && (l = o(u));
      }, n),
      restoreClient: () => {
        const a = e.getItem(t);
        if (a) return i(a);
      },
      removeClient: () => {
        e.removeItem(t);
      },
    };
  }
  return { persistClient: ZE, restoreClient: () => {}, removeClient: ZE };
}
function X4(e, t = 100) {
  let n = null,
    r;
  return function (...i) {
    (r = i),
      n === null &&
        (n = setTimeout(() => {
          e(...r), (n = null);
        }, t));
  };
}
function ZE() {}
class ml {
  constructor() {
    (this.listeners = new Set()), (this.subscribe = this.subscribe.bind(this));
  }
  subscribe(t) {
    const n = { listener: t };
    return (
      this.listeners.add(n),
      this.onSubscribe(),
      () => {
        this.listeners.delete(n), this.onUnsubscribe();
      }
    );
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {}
  onUnsubscribe() {}
}
const Tc = typeof window > "u" || "Deno" in window;
function Un() {}
function eM(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Gy(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function TC(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function Jl(e, t, n) {
  return rp(e)
    ? typeof t == "function"
      ? { ...n, queryKey: e, queryFn: t }
      : { ...t, queryKey: e }
    : e;
}
function Bi(e, t, n) {
  return rp(e) ? [{ ...t, queryKey: e }, n] : [e || {}, t];
}
function JE(e, t) {
  const {
    type: n = "all",
    exact: r,
    fetchStatus: i,
    predicate: s,
    queryKey: o,
    stale: a,
  } = e;
  if (rp(o)) {
    if (r) {
      if (t.queryHash !== Ab(o, t.options)) return !1;
    } else if (!Af(t.queryKey, o)) return !1;
  }
  if (n !== "all") {
    const u = t.isActive();
    if ((n === "active" && !u) || (n === "inactive" && u)) return !1;
  }
  return !(
    (typeof a == "boolean" && t.isStale() !== a) ||
    (typeof i < "u" && i !== t.state.fetchStatus) ||
    (s && !s(t))
  );
}
function YE(e, t) {
  const { exact: n, fetching: r, predicate: i, mutationKey: s } = e;
  if (rp(s)) {
    if (!t.options.mutationKey) return !1;
    if (n) {
      if (Rs(t.options.mutationKey) !== Rs(s)) return !1;
    } else if (!Af(t.options.mutationKey, s)) return !1;
  }
  return !(
    (typeof r == "boolean" && (t.state.status === "loading") !== r) ||
    (i && !i(t))
  );
}
function Ab(e, t) {
  return ((t == null ? void 0 : t.queryKeyHashFn) || Rs)(e);
}
function Rs(e) {
  return JSON.stringify(e, (t, n) =>
    Wy(n)
      ? Object.keys(n)
          .sort()
          .reduce((r, i) => ((r[i] = n[i]), r), {})
      : n
  );
}
function Af(e, t) {
  return IC(e, t);
}
function IC(e, t) {
  return e === t
    ? !0
    : typeof e != typeof t
    ? !1
    : e && t && typeof e == "object" && typeof t == "object"
    ? !Object.keys(t).some((n) => !IC(e[n], t[n]))
    : !1;
}
function kC(e, t) {
  if (e === t) return e;
  const n = XE(e) && XE(t);
  if (n || (Wy(e) && Wy(t))) {
    const r = n ? e.length : Object.keys(e).length,
      i = n ? t : Object.keys(t),
      s = i.length,
      o = n ? [] : {};
    let a = 0;
    for (let u = 0; u < s; u++) {
      const l = n ? u : i[u];
      (o[l] = kC(e[l], t[l])), o[l] === e[l] && a++;
    }
    return r === s && a === r ? e : o;
  }
  return t;
}
function qy(e, t) {
  if ((e && !t) || (t && !e)) return !1;
  for (const n in e) if (e[n] !== t[n]) return !1;
  return !0;
}
function XE(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Wy(e) {
  if (!e_(e)) return !1;
  const t = e.constructor;
  if (typeof t > "u") return !0;
  const n = t.prototype;
  return !(!e_(n) || !n.hasOwnProperty("isPrototypeOf"));
}
function e_(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function rp(e) {
  return Array.isArray(e);
}
function PC(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function t_(e) {
  PC(0).then(e);
}
function tM() {
  if (typeof AbortController == "function") return new AbortController();
}
function Qy(e, t, n) {
  return n.isDataEqual != null && n.isDataEqual(e, t)
    ? e
    : typeof n.structuralSharing == "function"
    ? n.structuralSharing(e, t)
    : n.structuralSharing !== !1
    ? kC(e, t)
    : t;
}
class nM extends ml {
  constructor() {
    super(),
      (this.setup = (t) => {
        if (!Tc && window.addEventListener) {
          const n = () => t();
          return (
            window.addEventListener("visibilitychange", n, !1),
            window.addEventListener("focus", n, !1),
            () => {
              window.removeEventListener("visibilitychange", n),
                window.removeEventListener("focus", n);
            }
          );
        }
      });
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), (this.cleanup = void 0);
    }
  }
  setEventListener(t) {
    var n;
    (this.setup = t),
      (n = this.cleanup) == null || n.call(this),
      (this.cleanup = t((r) => {
        typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
      }));
  }
  setFocused(t) {
    this.focused !== t && ((this.focused = t), this.onFocus());
  }
  onFocus() {
    this.listeners.forEach(({ listener: t }) => {
      t();
    });
  }
  isFocused() {
    return typeof this.focused == "boolean"
      ? this.focused
      : typeof document > "u"
      ? !0
      : [void 0, "visible", "prerender"].includes(document.visibilityState);
  }
}
const xf = new nM(),
  n_ = ["online", "offline"];
class rM extends ml {
  constructor() {
    super(),
      (this.setup = (t) => {
        if (!Tc && window.addEventListener) {
          const n = () => t();
          return (
            n_.forEach((r) => {
              window.addEventListener(r, n, !1);
            }),
            () => {
              n_.forEach((r) => {
                window.removeEventListener(r, n);
              });
            }
          );
        }
      });
  }
  onSubscribe() {
    this.cleanup || this.setEventListener(this.setup);
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      var t;
      (t = this.cleanup) == null || t.call(this), (this.cleanup = void 0);
    }
  }
  setEventListener(t) {
    var n;
    (this.setup = t),
      (n = this.cleanup) == null || n.call(this),
      (this.cleanup = t((r) => {
        typeof r == "boolean" ? this.setOnline(r) : this.onOnline();
      }));
  }
  setOnline(t) {
    this.online !== t && ((this.online = t), this.onOnline());
  }
  onOnline() {
    this.listeners.forEach(({ listener: t }) => {
      t();
    });
  }
  isOnline() {
    return typeof this.online == "boolean"
      ? this.online
      : typeof navigator > "u" || typeof navigator.onLine > "u"
      ? !0
      : navigator.onLine;
  }
}
const Sf = new rM();
function iM(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function ip(e) {
  return (e ?? "online") === "online" ? Sf.isOnline() : !0;
}
class DC {
  constructor(t) {
    (this.revert = t == null ? void 0 : t.revert),
      (this.silent = t == null ? void 0 : t.silent);
  }
}
function Ad(e) {
  return e instanceof DC;
}
function OC(e) {
  let t = !1,
    n = 0,
    r = !1,
    i,
    s,
    o;
  const a = new Promise((w, v) => {
      (s = w), (o = v);
    }),
    u = (w) => {
      r || (p(new DC(w)), e.abort == null || e.abort());
    },
    l = () => {
      t = !0;
    },
    c = () => {
      t = !1;
    },
    d = () => !xf.isFocused() || (e.networkMode !== "always" && !Sf.isOnline()),
    f = (w) => {
      r ||
        ((r = !0),
        e.onSuccess == null || e.onSuccess(w),
        i == null || i(),
        s(w));
    },
    p = (w) => {
      r ||
        ((r = !0), e.onError == null || e.onError(w), i == null || i(), o(w));
    },
    m = () =>
      new Promise((w) => {
        (i = (v) => {
          const y = r || !d();
          return y && w(v), y;
        }),
          e.onPause == null || e.onPause();
      }).then(() => {
        (i = void 0), r || e.onContinue == null || e.onContinue();
      }),
    g = () => {
      if (r) return;
      let w;
      try {
        w = e.fn();
      } catch (v) {
        w = Promise.reject(v);
      }
      Promise.resolve(w)
        .then(f)
        .catch((v) => {
          var y, b;
          if (r) return;
          const _ = (y = e.retry) != null ? y : 3,
            A = (b = e.retryDelay) != null ? b : iM,
            x = typeof A == "function" ? A(n, v) : A,
            h =
              _ === !0 ||
              (typeof _ == "number" && n < _) ||
              (typeof _ == "function" && _(n, v));
          if (t || !h) {
            p(v);
            return;
          }
          n++,
            e.onFail == null || e.onFail(n, v),
            PC(x)
              .then(() => {
                if (d()) return m();
              })
              .then(() => {
                t ? p(v) : g();
              });
        });
    };
  return (
    ip(e.networkMode) ? g() : m().then(g),
    {
      promise: a,
      cancel: u,
      continue: () => ((i == null ? void 0 : i()) ? a : Promise.resolve()),
      cancelRetry: l,
      continueRetry: c,
    }
  );
}
const xb = console;
function sM() {
  let e = [],
    t = 0,
    n = (c) => {
      c();
    },
    r = (c) => {
      c();
    };
  const i = (c) => {
      let d;
      t++;
      try {
        d = c();
      } finally {
        t--, t || a();
      }
      return d;
    },
    s = (c) => {
      t
        ? e.push(c)
        : t_(() => {
            n(c);
          });
    },
    o =
      (c) =>
      (...d) => {
        s(() => {
          c(...d);
        });
      },
    a = () => {
      const c = e;
      (e = []),
        c.length &&
          t_(() => {
            r(() => {
              c.forEach((d) => {
                n(d);
              });
            });
          });
    };
  return {
    batch: i,
    batchCalls: o,
    schedule: s,
    setNotifyFunction: (c) => {
      n = c;
    },
    setBatchNotifyFunction: (c) => {
      r = c;
    },
  };
}
const ut = sM();
class RC {
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(),
      Gy(this.cacheTime) &&
        (this.gcTimeout = setTimeout(() => {
          this.optionalRemove();
        }, this.cacheTime));
  }
  updateCacheTime(t) {
    this.cacheTime = Math.max(
      this.cacheTime || 0,
      t ?? (Tc ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    this.gcTimeout && (clearTimeout(this.gcTimeout), (this.gcTimeout = void 0));
  }
}
class oM extends RC {
  constructor(t) {
    super(),
      (this.abortSignalConsumed = !1),
      (this.defaultOptions = t.defaultOptions),
      this.setOptions(t.options),
      (this.observers = []),
      (this.cache = t.cache),
      (this.logger = t.logger || xb),
      (this.queryKey = t.queryKey),
      (this.queryHash = t.queryHash),
      (this.initialState = t.state || aM(this.options)),
      (this.state = this.initialState),
      this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  setOptions(t) {
    (this.options = { ...this.defaultOptions, ...t }),
      this.updateCacheTime(this.options.cacheTime);
  }
  optionalRemove() {
    !this.observers.length &&
      this.state.fetchStatus === "idle" &&
      this.cache.remove(this);
  }
  setData(t, n) {
    const r = Qy(this.state.data, t, this.options);
    return (
      this.dispatch({
        data: r,
        type: "success",
        dataUpdatedAt: n == null ? void 0 : n.updatedAt,
        manual: n == null ? void 0 : n.manual,
      }),
      r
    );
  }
  setState(t, n) {
    this.dispatch({ type: "setState", state: t, setStateOptions: n });
  }
  cancel(t) {
    var n;
    const r = this.promise;
    return (
      (n = this.retryer) == null || n.cancel(t),
      r ? r.then(Un).catch(Un) : Promise.resolve()
    );
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.initialState);
  }
  isActive() {
    return this.observers.some((t) => t.options.enabled !== !1);
  }
  isDisabled() {
    return this.getObserversCount() > 0 && !this.isActive();
  }
  isStale() {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      this.observers.some((t) => t.getCurrentResult().isStale)
    );
  }
  isStaleByTime(t = 0) {
    return (
      this.state.isInvalidated ||
      !this.state.dataUpdatedAt ||
      !TC(this.state.dataUpdatedAt, t)
    );
  }
  onFocus() {
    var t;
    const n = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    n && n.refetch({ cancelRefetch: !1 }),
      (t = this.retryer) == null || t.continue();
  }
  onOnline() {
    var t;
    const n = this.observers.find((r) => r.shouldFetchOnReconnect());
    n && n.refetch({ cancelRefetch: !1 }),
      (t = this.retryer) == null || t.continue();
  }
  addObserver(t) {
    this.observers.includes(t) ||
      (this.observers.push(t),
      this.clearGcTimeout(),
      this.cache.notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) &&
      ((this.observers = this.observers.filter((n) => n !== t)),
      this.observers.length ||
        (this.retryer &&
          (this.abortSignalConsumed
            ? this.retryer.cancel({ revert: !0 })
            : this.retryer.cancelRetry()),
        this.scheduleGc()),
      this.cache.notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.dispatch({ type: "invalidate" });
  }
  fetch(t, n) {
    var r, i;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.dataUpdatedAt && n != null && n.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.promise) {
        var s;
        return (s = this.retryer) == null || s.continueRetry(), this.promise;
      }
    }
    if ((t && this.setOptions(t), !this.options.queryFn)) {
      const p = this.observers.find((m) => m.options.queryFn);
      p && this.setOptions(p.options);
    }
    const o = tM(),
      a = { queryKey: this.queryKey, pageParam: void 0, meta: this.meta },
      u = (p) => {
        Object.defineProperty(p, "signal", {
          enumerable: !0,
          get: () => {
            if (o) return (this.abortSignalConsumed = !0), o.signal;
          },
        });
      };
    u(a);
    const l = () =>
        this.options.queryFn
          ? ((this.abortSignalConsumed = !1), this.options.queryFn(a))
          : Promise.reject(
              "Missing queryFn for queryKey '" + this.options.queryHash + "'"
            ),
      c = {
        fetchOptions: n,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn: l,
      };
    if (
      (u(c),
      (r = this.options.behavior) == null || r.onFetch(c),
      (this.revertState = this.state),
      this.state.fetchStatus === "idle" ||
        this.state.fetchMeta !==
          ((i = c.fetchOptions) == null ? void 0 : i.meta))
    ) {
      var d;
      this.dispatch({
        type: "fetch",
        meta: (d = c.fetchOptions) == null ? void 0 : d.meta,
      });
    }
    const f = (p) => {
      if (
        ((Ad(p) && p.silent) || this.dispatch({ type: "error", error: p }),
        !Ad(p))
      ) {
        var m, g, w, v;
        (m = (g = this.cache.config).onError) == null || m.call(g, p, this),
          (w = (v = this.cache.config).onSettled) == null ||
            w.call(v, this.state.data, p, this);
      }
      this.isFetchingOptimistic || this.scheduleGc(),
        (this.isFetchingOptimistic = !1);
    };
    return (
      (this.retryer = OC({
        fn: c.fetchFn,
        abort: o == null ? void 0 : o.abort.bind(o),
        onSuccess: (p) => {
          var m, g, w, v;
          if (typeof p > "u") {
            f(new Error(this.queryHash + " data is undefined"));
            return;
          }
          this.setData(p),
            (m = (g = this.cache.config).onSuccess) == null ||
              m.call(g, p, this),
            (w = (v = this.cache.config).onSettled) == null ||
              w.call(v, p, this.state.error, this),
            this.isFetchingOptimistic || this.scheduleGc(),
            (this.isFetchingOptimistic = !1);
        },
        onError: f,
        onFail: (p, m) => {
          this.dispatch({ type: "failed", failureCount: p, error: m });
        },
        onPause: () => {
          this.dispatch({ type: "pause" });
        },
        onContinue: () => {
          this.dispatch({ type: "continue" });
        },
        retry: c.options.retry,
        retryDelay: c.options.retryDelay,
        networkMode: c.options.networkMode,
      })),
      (this.promise = this.retryer.promise),
      this.promise
    );
  }
  dispatch(t) {
    const n = (r) => {
      var i, s;
      switch (t.type) {
        case "failed":
          return {
            ...r,
            fetchFailureCount: t.failureCount,
            fetchFailureReason: t.error,
          };
        case "pause":
          return { ...r, fetchStatus: "paused" };
        case "continue":
          return { ...r, fetchStatus: "fetching" };
        case "fetch":
          return {
            ...r,
            fetchFailureCount: 0,
            fetchFailureReason: null,
            fetchMeta: (i = t.meta) != null ? i : null,
            fetchStatus: ip(this.options.networkMode) ? "fetching" : "paused",
            ...(!r.dataUpdatedAt && { error: null, status: "loading" }),
          };
        case "success":
          return {
            ...r,
            data: t.data,
            dataUpdateCount: r.dataUpdateCount + 1,
            dataUpdatedAt: (s = t.dataUpdatedAt) != null ? s : Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...(!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null,
            }),
          };
        case "error":
          const o = t.error;
          return Ad(o) && o.revert && this.revertState
            ? { ...this.revertState, fetchStatus: "idle" }
            : {
                ...r,
                error: o,
                errorUpdateCount: r.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: r.fetchFailureCount + 1,
                fetchFailureReason: o,
                fetchStatus: "idle",
                status: "error",
              };
        case "invalidate":
          return { ...r, isInvalidated: !0 };
        case "setState":
          return { ...r, ...t.state };
      }
    };
    (this.state = n(this.state)),
      ut.batch(() => {
        this.observers.forEach((r) => {
          r.onQueryUpdate(t);
        }),
          this.cache.notify({ query: this, type: "updated", action: t });
      });
  }
}
function aM(e) {
  const t =
      typeof e.initialData == "function" ? e.initialData() : e.initialData,
    n = typeof t < "u",
    r = n
      ? typeof e.initialDataUpdatedAt == "function"
        ? e.initialDataUpdatedAt()
        : e.initialDataUpdatedAt
      : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: n ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: n ? "success" : "loading",
    fetchStatus: "idle",
  };
}
class uM extends ml {
  constructor(t) {
    super(),
      (this.config = t || {}),
      (this.queries = []),
      (this.queriesMap = {});
  }
  build(t, n, r) {
    var i;
    const s = n.queryKey,
      o = (i = n.queryHash) != null ? i : Ab(s, n);
    let a = this.get(o);
    return (
      a ||
        ((a = new oM({
          cache: this,
          logger: t.getLogger(),
          queryKey: s,
          queryHash: o,
          options: t.defaultQueryOptions(n),
          state: r,
          defaultOptions: t.getQueryDefaults(s),
        })),
        this.add(a)),
      a
    );
  }
  add(t) {
    this.queriesMap[t.queryHash] ||
      ((this.queriesMap[t.queryHash] = t),
      this.queries.push(t),
      this.notify({ type: "added", query: t }));
  }
  remove(t) {
    const n = this.queriesMap[t.queryHash];
    n &&
      (t.destroy(),
      (this.queries = this.queries.filter((r) => r !== t)),
      n === t && delete this.queriesMap[t.queryHash],
      this.notify({ type: "removed", query: t }));
  }
  clear() {
    ut.batch(() => {
      this.queries.forEach((t) => {
        this.remove(t);
      });
    });
  }
  get(t) {
    return this.queriesMap[t];
  }
  getAll() {
    return this.queries;
  }
  find(t, n) {
    const [r] = Bi(t, n);
    return (
      typeof r.exact > "u" && (r.exact = !0), this.queries.find((i) => JE(r, i))
    );
  }
  findAll(t, n) {
    const [r] = Bi(t, n);
    return Object.keys(r).length > 0
      ? this.queries.filter((i) => JE(r, i))
      : this.queries;
  }
  notify(t) {
    ut.batch(() => {
      this.listeners.forEach(({ listener: n }) => {
        n(t);
      });
    });
  }
  onFocus() {
    ut.batch(() => {
      this.queries.forEach((t) => {
        t.onFocus();
      });
    });
  }
  onOnline() {
    ut.batch(() => {
      this.queries.forEach((t) => {
        t.onOnline();
      });
    });
  }
}
class cM extends RC {
  constructor(t) {
    super(),
      (this.defaultOptions = t.defaultOptions),
      (this.mutationId = t.mutationId),
      (this.mutationCache = t.mutationCache),
      (this.logger = t.logger || xb),
      (this.observers = []),
      (this.state = t.state || lM()),
      this.setOptions(t.options),
      this.scheduleGc();
  }
  setOptions(t) {
    (this.options = { ...this.defaultOptions, ...t }),
      this.updateCacheTime(this.options.cacheTime);
  }
  get meta() {
    return this.options.meta;
  }
  setState(t) {
    this.dispatch({ type: "setState", state: t });
  }
  addObserver(t) {
    this.observers.includes(t) ||
      (this.observers.push(t),
      this.clearGcTimeout(),
      this.mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer: t,
      }));
  }
  removeObserver(t) {
    (this.observers = this.observers.filter((n) => n !== t)),
      this.scheduleGc(),
      this.mutationCache.notify({
        type: "observerRemoved",
        mutation: this,
        observer: t,
      });
  }
  optionalRemove() {
    this.observers.length ||
      (this.state.status === "loading"
        ? this.scheduleGc()
        : this.mutationCache.remove(this));
  }
  continue() {
    var t, n;
    return (t = (n = this.retryer) == null ? void 0 : n.continue()) != null
      ? t
      : this.execute();
  }
  async execute() {
    const t = () => {
        var h;
        return (
          (this.retryer = OC({
            fn: () =>
              this.options.mutationFn
                ? this.options.mutationFn(this.state.variables)
                : Promise.reject("No mutationFn found"),
            onFail: (E, I) => {
              this.dispatch({ type: "failed", failureCount: E, error: I });
            },
            onPause: () => {
              this.dispatch({ type: "pause" });
            },
            onContinue: () => {
              this.dispatch({ type: "continue" });
            },
            retry: (h = this.options.retry) != null ? h : 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
          })),
          this.retryer.promise
        );
      },
      n = this.state.status === "loading";
    try {
      var r, i, s, o, a, u, l, c;
      if (!n) {
        var d, f, p, m;
        this.dispatch({ type: "loading", variables: this.options.variables }),
          await ((d = (f = this.mutationCache.config).onMutate) == null
            ? void 0
            : d.call(f, this.state.variables, this));
        const E = await ((p = (m = this.options).onMutate) == null
          ? void 0
          : p.call(m, this.state.variables));
        E !== this.state.context &&
          this.dispatch({
            type: "loading",
            context: E,
            variables: this.state.variables,
          });
      }
      const h = await t();
      return (
        await ((r = (i = this.mutationCache.config).onSuccess) == null
          ? void 0
          : r.call(i, h, this.state.variables, this.state.context, this)),
        await ((s = (o = this.options).onSuccess) == null
          ? void 0
          : s.call(o, h, this.state.variables, this.state.context)),
        await ((a = (u = this.mutationCache.config).onSettled) == null
          ? void 0
          : a.call(u, h, null, this.state.variables, this.state.context, this)),
        await ((l = (c = this.options).onSettled) == null
          ? void 0
          : l.call(c, h, null, this.state.variables, this.state.context)),
        this.dispatch({ type: "success", data: h }),
        h
      );
    } catch (h) {
      try {
        var g, w, v, y, b, _, A, x;
        throw (
          (await ((g = (w = this.mutationCache.config).onError) == null
            ? void 0
            : g.call(w, h, this.state.variables, this.state.context, this)),
          await ((v = (y = this.options).onError) == null
            ? void 0
            : v.call(y, h, this.state.variables, this.state.context)),
          await ((b = (_ = this.mutationCache.config).onSettled) == null
            ? void 0
            : b.call(
                _,
                void 0,
                h,
                this.state.variables,
                this.state.context,
                this
              )),
          await ((A = (x = this.options).onSettled) == null
            ? void 0
            : A.call(x, void 0, h, this.state.variables, this.state.context)),
          h)
        );
      } finally {
        this.dispatch({ type: "error", error: h });
      }
    }
  }
  dispatch(t) {
    const n = (r) => {
      switch (t.type) {
        case "failed":
          return { ...r, failureCount: t.failureCount, failureReason: t.error };
        case "pause":
          return { ...r, isPaused: !0 };
        case "continue":
          return { ...r, isPaused: !1 };
        case "loading":
          return {
            ...r,
            context: t.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: !ip(this.options.networkMode),
            status: "loading",
            variables: t.variables,
          };
        case "success":
          return {
            ...r,
            data: t.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1,
          };
        case "error":
          return {
            ...r,
            data: void 0,
            error: t.error,
            failureCount: r.failureCount + 1,
            failureReason: t.error,
            isPaused: !1,
            status: "error",
          };
        case "setState":
          return { ...r, ...t.state };
      }
    };
    (this.state = n(this.state)),
      ut.batch(() => {
        this.observers.forEach((r) => {
          r.onMutationUpdate(t);
        }),
          this.mutationCache.notify({
            mutation: this,
            type: "updated",
            action: t,
          });
      });
  }
}
function lM() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
  };
}
class dM extends ml {
  constructor(t) {
    super(),
      (this.config = t || {}),
      (this.mutations = []),
      (this.mutationId = 0);
  }
  build(t, n, r) {
    const i = new cM({
      mutationCache: this,
      logger: t.getLogger(),
      mutationId: ++this.mutationId,
      options: t.defaultMutationOptions(n),
      state: r,
      defaultOptions: n.mutationKey
        ? t.getMutationDefaults(n.mutationKey)
        : void 0,
    });
    return this.add(i), i;
  }
  add(t) {
    this.mutations.push(t), this.notify({ type: "added", mutation: t });
  }
  remove(t) {
    (this.mutations = this.mutations.filter((n) => n !== t)),
      this.notify({ type: "removed", mutation: t });
  }
  clear() {
    ut.batch(() => {
      this.mutations.forEach((t) => {
        this.remove(t);
      });
    });
  }
  getAll() {
    return this.mutations;
  }
  find(t) {
    return (
      typeof t.exact > "u" && (t.exact = !0),
      this.mutations.find((n) => YE(t, n))
    );
  }
  findAll(t) {
    return this.mutations.filter((n) => YE(t, n));
  }
  notify(t) {
    ut.batch(() => {
      this.listeners.forEach(({ listener: n }) => {
        n(t);
      });
    });
  }
  resumePausedMutations() {
    var t;
    return (
      (this.resuming = ((t = this.resuming) != null ? t : Promise.resolve())
        .then(() => {
          const n = this.mutations.filter((r) => r.state.isPaused);
          return ut.batch(() =>
            n.reduce(
              (r, i) => r.then(() => i.continue().catch(Un)),
              Promise.resolve()
            )
          );
        })
        .then(() => {
          this.resuming = void 0;
        })),
      this.resuming
    );
  }
}
function fM() {
  return {
    onFetch: (e) => {
      e.fetchFn = () => {
        var t, n, r, i, s, o;
        const a =
            (t = e.fetchOptions) == null || (n = t.meta) == null
              ? void 0
              : n.refetchPage,
          u =
            (r = e.fetchOptions) == null || (i = r.meta) == null
              ? void 0
              : i.fetchMore,
          l = u == null ? void 0 : u.pageParam,
          c = (u == null ? void 0 : u.direction) === "forward",
          d = (u == null ? void 0 : u.direction) === "backward",
          f = ((s = e.state.data) == null ? void 0 : s.pages) || [],
          p = ((o = e.state.data) == null ? void 0 : o.pageParams) || [];
        let m = p,
          g = !1;
        const w = (x) => {
            Object.defineProperty(x, "signal", {
              enumerable: !0,
              get: () => {
                var h;
                if ((h = e.signal) != null && h.aborted) g = !0;
                else {
                  var E;
                  (E = e.signal) == null ||
                    E.addEventListener("abort", () => {
                      g = !0;
                    });
                }
                return e.signal;
              },
            });
          },
          v =
            e.options.queryFn ||
            (() =>
              Promise.reject(
                "Missing queryFn for queryKey '" + e.options.queryHash + "'"
              )),
          y = (x, h, E, I) => (
            (m = I ? [h, ...m] : [...m, h]), I ? [E, ...x] : [...x, E]
          ),
          b = (x, h, E, I) => {
            if (g) return Promise.reject("Cancelled");
            if (typeof E > "u" && !h && x.length) return Promise.resolve(x);
            const C = {
              queryKey: e.queryKey,
              pageParam: E,
              meta: e.options.meta,
            };
            w(C);
            const k = v(C);
            return Promise.resolve(k).then((R) => y(x, E, R, I));
          };
        let _;
        if (!f.length) _ = b([]);
        else if (c) {
          const x = typeof l < "u",
            h = x ? l : r_(e.options, f);
          _ = b(f, x, h);
        } else if (d) {
          const x = typeof l < "u",
            h = x ? l : hM(e.options, f);
          _ = b(f, x, h, !0);
        } else {
          m = [];
          const x = typeof e.options.getNextPageParam > "u";
          _ = (a && f[0] ? a(f[0], 0, f) : !0)
            ? b([], x, p[0])
            : Promise.resolve(y([], p[0], f[0]));
          for (let E = 1; E < f.length; E++)
            _ = _.then((I) => {
              if (a && f[E] ? a(f[E], E, f) : !0) {
                const k = x ? p[E] : r_(e.options, I);
                return b(I, x, k);
              }
              return Promise.resolve(y(I, p[E], f[E]));
            });
        }
        return _.then((x) => ({ pages: x, pageParams: m }));
      };
    },
  };
}
function r_(e, t) {
  return e.getNextPageParam == null
    ? void 0
    : e.getNextPageParam(t[t.length - 1], t);
}
function hM(e, t) {
  return e.getPreviousPageParam == null
    ? void 0
    : e.getPreviousPageParam(t[0], t);
}
class pM {
  constructor(t = {}) {
    (this.queryCache = t.queryCache || new uM()),
      (this.mutationCache = t.mutationCache || new dM()),
      (this.logger = t.logger || xb),
      (this.defaultOptions = t.defaultOptions || {}),
      (this.queryDefaults = []),
      (this.mutationDefaults = []),
      (this.mountCount = 0);
  }
  mount() {
    this.mountCount++,
      this.mountCount === 1 &&
        ((this.unsubscribeFocus = xf.subscribe(() => {
          xf.isFocused() &&
            (this.resumePausedMutations(), this.queryCache.onFocus());
        })),
        (this.unsubscribeOnline = Sf.subscribe(() => {
          Sf.isOnline() &&
            (this.resumePausedMutations(), this.queryCache.onOnline());
        })));
  }
  unmount() {
    var t, n;
    this.mountCount--,
      this.mountCount === 0 &&
        ((t = this.unsubscribeFocus) == null || t.call(this),
        (this.unsubscribeFocus = void 0),
        (n = this.unsubscribeOnline) == null || n.call(this),
        (this.unsubscribeOnline = void 0));
  }
  isFetching(t, n) {
    const [r] = Bi(t, n);
    return (r.fetchStatus = "fetching"), this.queryCache.findAll(r).length;
  }
  isMutating(t) {
    return this.mutationCache.findAll({ ...t, fetching: !0 }).length;
  }
  getQueryData(t, n) {
    var r;
    return (r = this.queryCache.find(t, n)) == null ? void 0 : r.state.data;
  }
  ensureQueryData(t, n, r) {
    const i = Jl(t, n, r),
      s = this.getQueryData(i.queryKey);
    return s ? Promise.resolve(s) : this.fetchQuery(i);
  }
  getQueriesData(t) {
    return this.getQueryCache()
      .findAll(t)
      .map(({ queryKey: n, state: r }) => {
        const i = r.data;
        return [n, i];
      });
  }
  setQueryData(t, n, r) {
    const i = this.queryCache.find(t),
      s = i == null ? void 0 : i.state.data,
      o = eM(n, s);
    if (typeof o > "u") return;
    const a = Jl(t),
      u = this.defaultQueryOptions(a);
    return this.queryCache.build(this, u).setData(o, { ...r, manual: !0 });
  }
  setQueriesData(t, n, r) {
    return ut.batch(() =>
      this.getQueryCache()
        .findAll(t)
        .map(({ queryKey: i }) => [i, this.setQueryData(i, n, r)])
    );
  }
  getQueryState(t, n) {
    var r;
    return (r = this.queryCache.find(t, n)) == null ? void 0 : r.state;
  }
  removeQueries(t, n) {
    const [r] = Bi(t, n),
      i = this.queryCache;
    ut.batch(() => {
      i.findAll(r).forEach((s) => {
        i.remove(s);
      });
    });
  }
  resetQueries(t, n, r) {
    const [i, s] = Bi(t, n, r),
      o = this.queryCache,
      a = { type: "active", ...i };
    return ut.batch(
      () => (
        o.findAll(i).forEach((u) => {
          u.reset();
        }),
        this.refetchQueries(a, s)
      )
    );
  }
  cancelQueries(t, n, r) {
    const [i, s = {}] = Bi(t, n, r);
    typeof s.revert > "u" && (s.revert = !0);
    const o = ut.batch(() =>
      this.queryCache.findAll(i).map((a) => a.cancel(s))
    );
    return Promise.all(o).then(Un).catch(Un);
  }
  invalidateQueries(t, n, r) {
    const [i, s] = Bi(t, n, r);
    return ut.batch(() => {
      var o, a;
      if (
        (this.queryCache.findAll(i).forEach((l) => {
          l.invalidate();
        }),
        i.refetchType === "none")
      )
        return Promise.resolve();
      const u = {
        ...i,
        type:
          (o = (a = i.refetchType) != null ? a : i.type) != null ? o : "active",
      };
      return this.refetchQueries(u, s);
    });
  }
  refetchQueries(t, n, r) {
    const [i, s] = Bi(t, n, r),
      o = ut.batch(() =>
        this.queryCache
          .findAll(i)
          .filter((u) => !u.isDisabled())
          .map((u) => {
            var l;
            return u.fetch(void 0, {
              ...s,
              cancelRefetch:
                (l = s == null ? void 0 : s.cancelRefetch) != null ? l : !0,
              meta: { refetchPage: i.refetchPage },
            });
          })
      );
    let a = Promise.all(o).then(Un);
    return (s != null && s.throwOnError) || (a = a.catch(Un)), a;
  }
  fetchQuery(t, n, r) {
    const i = Jl(t, n, r),
      s = this.defaultQueryOptions(i);
    typeof s.retry > "u" && (s.retry = !1);
    const o = this.queryCache.build(this, s);
    return o.isStaleByTime(s.staleTime)
      ? o.fetch(s)
      : Promise.resolve(o.state.data);
  }
  prefetchQuery(t, n, r) {
    return this.fetchQuery(t, n, r).then(Un).catch(Un);
  }
  fetchInfiniteQuery(t, n, r) {
    const i = Jl(t, n, r);
    return (i.behavior = fM()), this.fetchQuery(i);
  }
  prefetchInfiniteQuery(t, n, r) {
    return this.fetchInfiniteQuery(t, n, r).then(Un).catch(Un);
  }
  resumePausedMutations() {
    return this.mutationCache.resumePausedMutations();
  }
  getQueryCache() {
    return this.queryCache;
  }
  getMutationCache() {
    return this.mutationCache;
  }
  getLogger() {
    return this.logger;
  }
  getDefaultOptions() {
    return this.defaultOptions;
  }
  setDefaultOptions(t) {
    this.defaultOptions = t;
  }
  setQueryDefaults(t, n) {
    const r = this.queryDefaults.find((i) => Rs(t) === Rs(i.queryKey));
    r
      ? (r.defaultOptions = n)
      : this.queryDefaults.push({ queryKey: t, defaultOptions: n });
  }
  getQueryDefaults(t) {
    if (!t) return;
    const n = this.queryDefaults.find((r) => Af(t, r.queryKey));
    return n == null ? void 0 : n.defaultOptions;
  }
  setMutationDefaults(t, n) {
    const r = this.mutationDefaults.find((i) => Rs(t) === Rs(i.mutationKey));
    r
      ? (r.defaultOptions = n)
      : this.mutationDefaults.push({ mutationKey: t, defaultOptions: n });
  }
  getMutationDefaults(t) {
    if (!t) return;
    const n = this.mutationDefaults.find((r) => Af(t, r.mutationKey));
    return n == null ? void 0 : n.defaultOptions;
  }
  defaultQueryOptions(t) {
    if (t != null && t._defaulted) return t;
    const n = {
      ...this.defaultOptions.queries,
      ...this.getQueryDefaults(t == null ? void 0 : t.queryKey),
      ...t,
      _defaulted: !0,
    };
    return (
      !n.queryHash && n.queryKey && (n.queryHash = Ab(n.queryKey, n)),
      typeof n.refetchOnReconnect > "u" &&
        (n.refetchOnReconnect = n.networkMode !== "always"),
      typeof n.useErrorBoundary > "u" && (n.useErrorBoundary = !!n.suspense),
      n
    );
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted
      ? t
      : {
          ...this.defaultOptions.mutations,
          ...this.getMutationDefaults(t == null ? void 0 : t.mutationKey),
          ...t,
          _defaulted: !0,
        };
  }
  clear() {
    this.queryCache.clear(), this.mutationCache.clear();
  }
}
class mM extends ml {
  constructor(t, n) {
    super(),
      (this.client = t),
      (this.options = n),
      (this.trackedProps = new Set()),
      (this.selectError = null),
      this.bindMethods(),
      this.setOptions(n);
  }
  bindMethods() {
    (this.remove = this.remove.bind(this)),
      (this.refetch = this.refetch.bind(this));
  }
  onSubscribe() {
    this.listeners.size === 1 &&
      (this.currentQuery.addObserver(this),
      i_(this.currentQuery, this.options) && this.executeFetch(),
      this.updateTimers());
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Vy(this.currentQuery, this.options, this.options.refetchOnReconnect);
  }
  shouldFetchOnWindowFocus() {
    return Vy(
      this.currentQuery,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    (this.listeners = new Set()),
      this.clearStaleTimeout(),
      this.clearRefetchInterval(),
      this.currentQuery.removeObserver(this);
  }
  setOptions(t, n) {
    const r = this.options,
      i = this.currentQuery;
    if (
      ((this.options = this.client.defaultQueryOptions(t)),
      qy(r, this.options) ||
        this.client
          .getQueryCache()
          .notify({
            type: "observerOptionsUpdated",
            query: this.currentQuery,
            observer: this,
          }),
      typeof this.options.enabled < "u" &&
        typeof this.options.enabled != "boolean")
    )
      throw new Error("Expected enabled to be a boolean");
    this.options.queryKey || (this.options.queryKey = r.queryKey),
      this.updateQuery();
    const s = this.hasListeners();
    s && s_(this.currentQuery, i, this.options, r) && this.executeFetch(),
      this.updateResult(n),
      s &&
        (this.currentQuery !== i ||
          this.options.enabled !== r.enabled ||
          this.options.staleTime !== r.staleTime) &&
        this.updateStaleTimeout();
    const o = this.computeRefetchInterval();
    s &&
      (this.currentQuery !== i ||
        this.options.enabled !== r.enabled ||
        o !== this.currentRefetchInterval) &&
      this.updateRefetchInterval(o);
  }
  getOptimisticResult(t) {
    const n = this.client.getQueryCache().build(this.client, t),
      r = this.createResult(n, t);
    return (
      gM(this, r, t) &&
        ((this.currentResult = r),
        (this.currentResultOptions = this.options),
        (this.currentResultState = this.currentQuery.state)),
      r
    );
  }
  getCurrentResult() {
    return this.currentResult;
  }
  trackResult(t) {
    const n = {};
    return (
      Object.keys(t).forEach((r) => {
        Object.defineProperty(n, r, {
          configurable: !1,
          enumerable: !0,
          get: () => (this.trackedProps.add(r), t[r]),
        });
      }),
      n
    );
  }
  getCurrentQuery() {
    return this.currentQuery;
  }
  remove() {
    this.client.getQueryCache().remove(this.currentQuery);
  }
  refetch({ refetchPage: t, ...n } = {}) {
    return this.fetch({ ...n, meta: { refetchPage: t } });
  }
  fetchOptimistic(t) {
    const n = this.client.defaultQueryOptions(t),
      r = this.client.getQueryCache().build(this.client, n);
    return (
      (r.isFetchingOptimistic = !0),
      r.fetch().then(() => this.createResult(r, n))
    );
  }
  fetch(t) {
    var n;
    return this.executeFetch({
      ...t,
      cancelRefetch: (n = t.cancelRefetch) != null ? n : !0,
    }).then(() => (this.updateResult(), this.currentResult));
  }
  executeFetch(t) {
    this.updateQuery();
    let n = this.currentQuery.fetch(this.options, t);
    return (t != null && t.throwOnError) || (n = n.catch(Un)), n;
  }
  updateStaleTimeout() {
    if (
      (this.clearStaleTimeout(),
      Tc || this.currentResult.isStale || !Gy(this.options.staleTime))
    )
      return;
    const n = TC(this.currentResult.dataUpdatedAt, this.options.staleTime) + 1;
    this.staleTimeoutId = setTimeout(() => {
      this.currentResult.isStale || this.updateResult();
    }, n);
  }
  computeRefetchInterval() {
    var t;
    return typeof this.options.refetchInterval == "function"
      ? this.options.refetchInterval(this.currentResult.data, this.currentQuery)
      : (t = this.options.refetchInterval) != null
      ? t
      : !1;
  }
  updateRefetchInterval(t) {
    this.clearRefetchInterval(),
      (this.currentRefetchInterval = t),
      !(
        Tc ||
        this.options.enabled === !1 ||
        !Gy(this.currentRefetchInterval) ||
        this.currentRefetchInterval === 0
      ) &&
        (this.refetchIntervalId = setInterval(() => {
          (this.options.refetchIntervalInBackground || xf.isFocused()) &&
            this.executeFetch();
        }, this.currentRefetchInterval));
  }
  updateTimers() {
    this.updateStaleTimeout(),
      this.updateRefetchInterval(this.computeRefetchInterval());
  }
  clearStaleTimeout() {
    this.staleTimeoutId &&
      (clearTimeout(this.staleTimeoutId), (this.staleTimeoutId = void 0));
  }
  clearRefetchInterval() {
    this.refetchIntervalId &&
      (clearInterval(this.refetchIntervalId),
      (this.refetchIntervalId = void 0));
  }
  createResult(t, n) {
    const r = this.currentQuery,
      i = this.options,
      s = this.currentResult,
      o = this.currentResultState,
      a = this.currentResultOptions,
      u = t !== r,
      l = u ? t.state : this.currentQueryInitialState,
      c = u ? this.currentResult : this.previousQueryResult,
      { state: d } = t;
    let {
        dataUpdatedAt: f,
        error: p,
        errorUpdatedAt: m,
        fetchStatus: g,
        status: w,
      } = d,
      v = !1,
      y = !1,
      b;
    if (n._optimisticResults) {
      const E = this.hasListeners(),
        I = !E && i_(t, n),
        C = E && s_(t, r, n, i);
      (I || C) &&
        ((g = ip(t.options.networkMode) ? "fetching" : "paused"),
        f || (w = "loading")),
        n._optimisticResults === "isRestoring" && (g = "idle");
    }
    if (
      n.keepPreviousData &&
      !d.dataUpdatedAt &&
      c != null &&
      c.isSuccess &&
      w !== "error"
    )
      (b = c.data), (f = c.dataUpdatedAt), (w = c.status), (v = !0);
    else if (n.select && typeof d.data < "u")
      if (
        s &&
        d.data === (o == null ? void 0 : o.data) &&
        n.select === this.selectFn
      )
        b = this.selectResult;
      else
        try {
          (this.selectFn = n.select),
            (b = n.select(d.data)),
            (b = Qy(s == null ? void 0 : s.data, b, n)),
            (this.selectResult = b),
            (this.selectError = null);
        } catch (E) {
          this.selectError = E;
        }
    else b = d.data;
    if (typeof n.placeholderData < "u" && typeof b > "u" && w === "loading") {
      let E;
      if (
        s != null &&
        s.isPlaceholderData &&
        n.placeholderData === (a == null ? void 0 : a.placeholderData)
      )
        E = s.data;
      else if (
        ((E =
          typeof n.placeholderData == "function"
            ? n.placeholderData()
            : n.placeholderData),
        n.select && typeof E < "u")
      )
        try {
          (E = n.select(E)), (this.selectError = null);
        } catch (I) {
          this.selectError = I;
        }
      typeof E < "u" &&
        ((w = "success"),
        (b = Qy(s == null ? void 0 : s.data, E, n)),
        (y = !0));
    }
    this.selectError &&
      ((p = this.selectError),
      (b = this.selectResult),
      (m = Date.now()),
      (w = "error"));
    const _ = g === "fetching",
      A = w === "loading",
      x = w === "error";
    return {
      status: w,
      fetchStatus: g,
      isLoading: A,
      isSuccess: w === "success",
      isError: x,
      isInitialLoading: A && _,
      data: b,
      dataUpdatedAt: f,
      error: p,
      errorUpdatedAt: m,
      failureCount: d.fetchFailureCount,
      failureReason: d.fetchFailureReason,
      errorUpdateCount: d.errorUpdateCount,
      isFetched: d.dataUpdateCount > 0 || d.errorUpdateCount > 0,
      isFetchedAfterMount:
        d.dataUpdateCount > l.dataUpdateCount ||
        d.errorUpdateCount > l.errorUpdateCount,
      isFetching: _,
      isRefetching: _ && !A,
      isLoadingError: x && d.dataUpdatedAt === 0,
      isPaused: g === "paused",
      isPlaceholderData: y,
      isPreviousData: v,
      isRefetchError: x && d.dataUpdatedAt !== 0,
      isStale: Sb(t, n),
      refetch: this.refetch,
      remove: this.remove,
    };
  }
  updateResult(t) {
    const n = this.currentResult,
      r = this.createResult(this.currentQuery, this.options);
    if (
      ((this.currentResultState = this.currentQuery.state),
      (this.currentResultOptions = this.options),
      qy(r, n))
    )
      return;
    this.currentResult = r;
    const i = { cache: !0 },
      s = () => {
        if (!n) return !0;
        const { notifyOnChangeProps: o } = this.options,
          a = typeof o == "function" ? o() : o;
        if (a === "all" || (!a && !this.trackedProps.size)) return !0;
        const u = new Set(a ?? this.trackedProps);
        return (
          this.options.useErrorBoundary && u.add("error"),
          Object.keys(this.currentResult).some((l) => {
            const c = l;
            return this.currentResult[c] !== n[c] && u.has(c);
          })
        );
      };
    (t == null ? void 0 : t.listeners) !== !1 && s() && (i.listeners = !0),
      this.notify({ ...i, ...t });
  }
  updateQuery() {
    const t = this.client.getQueryCache().build(this.client, this.options);
    if (t === this.currentQuery) return;
    const n = this.currentQuery;
    (this.currentQuery = t),
      (this.currentQueryInitialState = t.state),
      (this.previousQueryResult = this.currentResult),
      this.hasListeners() &&
        (n == null || n.removeObserver(this), t.addObserver(this));
  }
  onQueryUpdate(t) {
    const n = {};
    t.type === "success"
      ? (n.onSuccess = !t.manual)
      : t.type === "error" && !Ad(t.error) && (n.onError = !0),
      this.updateResult(n),
      this.hasListeners() && this.updateTimers();
  }
  notify(t) {
    ut.batch(() => {
      if (t.onSuccess) {
        var n, r, i, s;
        (n = (r = this.options).onSuccess) == null ||
          n.call(r, this.currentResult.data),
          (i = (s = this.options).onSettled) == null ||
            i.call(s, this.currentResult.data, null);
      } else if (t.onError) {
        var o, a, u, l;
        (o = (a = this.options).onError) == null ||
          o.call(a, this.currentResult.error),
          (u = (l = this.options).onSettled) == null ||
            u.call(l, void 0, this.currentResult.error);
      }
      t.listeners &&
        this.listeners.forEach(({ listener: c }) => {
          c(this.currentResult);
        }),
        t.cache &&
          this.client
            .getQueryCache()
            .notify({
              query: this.currentQuery,
              type: "observerResultsUpdated",
            });
    });
  }
}
function yM(e, t) {
  return (
    t.enabled !== !1 &&
    !e.state.dataUpdatedAt &&
    !(e.state.status === "error" && t.retryOnMount === !1)
  );
}
function i_(e, t) {
  return yM(e, t) || (e.state.dataUpdatedAt > 0 && Vy(e, t, t.refetchOnMount));
}
function Vy(e, t, n) {
  if (t.enabled !== !1) {
    const r = typeof n == "function" ? n(e) : n;
    return r === "always" || (r !== !1 && Sb(e, t));
  }
  return !1;
}
function s_(e, t, n, r) {
  return (
    n.enabled !== !1 &&
    (e !== t || r.enabled === !1) &&
    (!n.suspense || e.state.status !== "error") &&
    Sb(e, n)
  );
}
function Sb(e, t) {
  return e.isStaleByTime(t.staleTime);
}
function gM(e, t, n) {
  return n.keepPreviousData
    ? !1
    : n.placeholderData !== void 0
    ? t.isPlaceholderData
    : !qy(e.getCurrentResult(), t);
}
function vM(e) {
  return { mutationKey: e.options.mutationKey, state: e.state };
}
function bM(e) {
  return { state: e.state, queryKey: e.queryKey, queryHash: e.queryHash };
}
function wM(e) {
  return e.state.isPaused;
}
function EM(e) {
  return e.state.status === "success";
}
function _M(e, t = {}) {
  const n = [],
    r = [];
  if (t.dehydrateMutations !== !1) {
    const i = t.shouldDehydrateMutation || wM;
    e.getMutationCache()
      .getAll()
      .forEach((s) => {
        i(s) && n.push(vM(s));
      });
  }
  if (t.dehydrateQueries !== !1) {
    const i = t.shouldDehydrateQuery || EM;
    e.getQueryCache()
      .getAll()
      .forEach((s) => {
        i(s) && r.push(bM(s));
      });
  }
  return { mutations: n, queries: r };
}
function AM(e, t, n) {
  if (typeof t != "object" || t === null) return;
  const r = e.getMutationCache(),
    i = e.getQueryCache(),
    s = t.mutations || [],
    o = t.queries || [];
  s.forEach((a) => {
    var u;
    r.build(
      e,
      {
        ...(n == null || (u = n.defaultOptions) == null ? void 0 : u.mutations),
        mutationKey: a.mutationKey,
      },
      a.state
    );
  }),
    o.forEach(({ queryKey: a, state: u, queryHash: l }) => {
      var c;
      const d = i.get(l);
      if (d) {
        if (d.state.dataUpdatedAt < u.dataUpdatedAt) {
          const { fetchStatus: f, ...p } = u;
          d.setState(p);
        }
        return;
      }
      i.build(
        e,
        {
          ...(n == null || (c = n.defaultOptions) == null ? void 0 : c.queries),
          queryKey: a,
          queryHash: l,
        },
        { ...u, fetchStatus: "idle" }
      );
    });
}
var BC = { exports: {} },
  NC = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ba = G;
function xM(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t);
}
var SM = typeof Object.is == "function" ? Object.is : xM,
  CM = ba.useState,
  TM = ba.useEffect,
  IM = ba.useLayoutEffect,
  kM = ba.useDebugValue;
function PM(e, t) {
  var n = t(),
    r = CM({ inst: { value: n, getSnapshot: t } }),
    i = r[0].inst,
    s = r[1];
  return (
    IM(
      function () {
        (i.value = n), (i.getSnapshot = t), Om(i) && s({ inst: i });
      },
      [e, n, t]
    ),
    TM(
      function () {
        return (
          Om(i) && s({ inst: i }),
          e(function () {
            Om(i) && s({ inst: i });
          })
        );
      },
      [e]
    ),
    kM(n),
    n
  );
}
function Om(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !SM(e, n);
  } catch {
    return !0;
  }
}
function DM(e, t) {
  return t();
}
var OM =
  typeof window > "u" ||
  typeof window.document > "u" ||
  typeof window.document.createElement > "u"
    ? DM
    : PM;
NC.useSyncExternalStore =
  ba.useSyncExternalStore !== void 0 ? ba.useSyncExternalStore : OM;
BC.exports = NC;
var MC = BC.exports;
const o_ = G.createContext(void 0),
  LC = G.createContext(!1);
function FC(e, t) {
  return (
    e ||
    (t && typeof window < "u"
      ? (window.ReactQueryClientContext ||
          (window.ReactQueryClientContext = o_),
        window.ReactQueryClientContext)
      : o_)
  );
}
const jC = ({ context: e } = {}) => {
    const t = G.useContext(FC(e, G.useContext(LC)));
    if (!t)
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return t;
  },
  RM = ({ client: e, children: t, context: n, contextSharing: r = !1 }) => {
    G.useEffect(
      () => (
        e.mount(),
        () => {
          e.unmount();
        }
      ),
      [e]
    );
    const i = FC(n, r);
    return G.createElement(
      LC.Provider,
      { value: !n && r },
      G.createElement(i.Provider, { value: e }, t)
    );
  },
  UC = G.createContext(!1),
  BM = () => G.useContext(UC);
UC.Provider;
function NM() {
  let e = !1;
  return {
    clearReset: () => {
      e = !1;
    },
    reset: () => {
      e = !0;
    },
    isReset: () => e,
  };
}
const MM = G.createContext(NM()),
  LM = () => G.useContext(MM),
  FM = ["added", "removed", "updated"];
function a_(e) {
  return FM.includes(e);
}
async function jM({
  queryClient: e,
  persister: t,
  maxAge: n = 1e3 * 60 * 60 * 24,
  buster: r = "",
  hydrateOptions: i,
}) {
  try {
    const s = await t.restoreClient();
    if (s)
      if (s.timestamp) {
        const o = Date.now() - s.timestamp > n,
          a = s.buster !== r;
        o || a ? t.removeClient() : AM(e, s.clientState, i);
      } else t.removeClient();
  } catch {
    t.removeClient();
  }
}
async function u_({
  queryClient: e,
  persister: t,
  buster: n = "",
  dehydrateOptions: r,
}) {
  const i = { buster: n, timestamp: Date.now(), clientState: _M(e, r) };
  await t.persistClient(i);
}
function UM(e) {
  const t = e.queryClient.getQueryCache().subscribe((r) => {
      a_(r.type) && u_(e);
    }),
    n = e.queryClient.getMutationCache().subscribe((r) => {
      a_(r.type) && u_(e);
    });
  return () => {
    t(), n();
  };
}
function $M(e) {
  let t = !1,
    n;
  const r = () => {
      (t = !0), n == null || n();
    },
    i = jM(e).then(() => {
      t || (n = UM(e));
    });
  return [r, i];
}
var $C = { exports: {} },
  HC = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var sp = G,
  HM = MC;
function zM(e, t) {
  return (e === t && (e !== 0 || 1 / e === 1 / t)) || (e !== e && t !== t);
}
var GM = typeof Object.is == "function" ? Object.is : zM,
  qM = HM.useSyncExternalStore,
  WM = sp.useRef,
  QM = sp.useEffect,
  VM = sp.useMemo,
  KM = sp.useDebugValue;
HC.useSyncExternalStoreWithSelector = function (e, t, n, r, i) {
  var s = WM(null);
  if (s.current === null) {
    var o = { hasValue: !1, value: null };
    s.current = o;
  } else o = s.current;
  s = VM(
    function () {
      function u(p) {
        if (!l) {
          if (((l = !0), (c = p), (p = r(p)), i !== void 0 && o.hasValue)) {
            var m = o.value;
            if (i(m, p)) return (d = m);
          }
          return (d = p);
        }
        if (((m = d), GM(c, p))) return m;
        var g = r(p);
        return i !== void 0 && i(m, g) ? m : ((c = p), (d = g));
      }
      var l = !1,
        c,
        d,
        f = n === void 0 ? null : n;
      return [
        function () {
          return u(t());
        },
        f === null
          ? void 0
          : function () {
              return u(f());
            },
      ];
    },
    [t, n, r, i]
  );
  var a = qM(e, s[0], s[1]);
  return (
    QM(
      function () {
        (o.hasValue = !0), (o.value = a);
      },
      [a]
    ),
    KM(a),
    a
  );
};
$C.exports = HC;
var zC = $C.exports;
function ZM({
  queryClient: e = new pM({
    defaultOptions: {
      queries: {
        cacheTime: 1e3 * 60 * 60 * 24,
        networkMode: "offlineFirst",
        refetchOnWindowFocus: !1,
        retry: 0,
      },
      mutations: { networkMode: "offlineFirst" },
    },
  }),
  storage: t = XS({
    storage:
      typeof window < "u" && window.localStorage ? window.localStorage : YS,
  }),
  persister: n = typeof window < "u"
    ? Y4({
        key: "cache",
        storage: t,
        serialize: (i) => i,
        deserialize: (i) => i,
      })
    : void 0,
  ...r
}) {
  const i = s8({ ...r, storage: t });
  return (
    n &&
      $M({
        queryClient: e,
        persister: n,
        dehydrateOptions: {
          shouldDehydrateQuery: (s) =>
            s.cacheTime !== 0 && s.queryKey[0].persist !== !1,
        },
      }),
    Object.assign(i, { queryClient: e })
  );
}
var GC = G.createContext(void 0),
  Cb = G.createContext(void 0);
function JM({ children: e, config: t }) {
  return G.createElement(GC.Provider, {
    children: G.createElement(RM, {
      children: e,
      client: t.queryClient,
      context: Cb,
    }),
    value: t,
  });
}
function qC() {
  const e = G.useContext(GC);
  if (!e)
    throw new Error(
      [
        "`useConfig` must be used within `WagmiConfig`.\n",
        "Read more: https://wagmi.sh/react/WagmiConfig",
      ].join(`
`)
    );
  return e;
}
var YM = MC.useSyncExternalStore;
function XM(e) {
  return Array.isArray(e);
}
function eL(e) {
  if (!c_(e)) return !1;
  const t = e.constructor;
  if (typeof t > "u") return !0;
  const n = t.prototype;
  return !(!c_(n) || !n.hasOwnProperty("isPrototypeOf"));
}
function c_(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function tL(e, t, n) {
  return XM(e)
    ? typeof t == "function"
      ? { ...n, queryKey: e, queryFn: t }
      : { ...t, queryKey: e }
    : e;
}
function nL(e) {
  return JSON.stringify(e, (t, n) =>
    eL(n)
      ? Object.keys(n)
          .sort()
          .reduce((r, i) => ((r[i] = n[i]), r), {})
      : typeof n == "bigint"
      ? n.toString()
      : n
  );
}
function rL(e, t) {
  return typeof e == "function" ? e(...t) : !!e;
}
function iL(e, t) {
  const n = {};
  return (
    Object.keys(e).forEach((r) => {
      Object.defineProperty(n, r, {
        configurable: !1,
        enumerable: !0,
        get: () => (t.trackedProps.add(r), e[r]),
      });
    }),
    n
  );
}
function sL(e, t) {
  const n = jC({ context: e.context }),
    r = BM(),
    i = LM(),
    s = n.defaultQueryOptions({ ...e, queryKeyHashFn: nL });
  (s._optimisticResults = r ? "isRestoring" : "optimistic"),
    s.onError && (s.onError = ut.batchCalls(s.onError)),
    s.onSuccess && (s.onSuccess = ut.batchCalls(s.onSuccess)),
    s.onSettled && (s.onSettled = ut.batchCalls(s.onSettled)),
    s.suspense && typeof s.staleTime != "number" && (s.staleTime = 1e3),
    (s.suspense || s.useErrorBoundary) &&
      (i.isReset() || (s.retryOnMount = !1));
  const [o] = G.useState(() => new t(n, s)),
    a = o.getOptimisticResult(s);
  if (
    (YM(
      G.useCallback(
        (d) => (r ? () => {} : o.subscribe(ut.batchCalls(d))),
        [o, r]
      ),
      () => o.getCurrentResult(),
      () => o.getCurrentResult()
    ),
    G.useEffect(() => {
      i.clearReset();
    }, [i]),
    G.useEffect(() => {
      o.setOptions(s, { listeners: !1 });
    }, [s, o]),
    s.suspense && a.isLoading && a.isFetching && !r)
  )
    throw o
      .fetchOptimistic(s)
      .then(({ data: d }) => {
        var f, p;
        (f = s.onSuccess) == null || f.call(s, d),
          (p = s.onSettled) == null || p.call(s, d, null);
      })
      .catch((d) => {
        var f, p;
        i.clearReset(),
          (f = s.onError) == null || f.call(s, d),
          (p = s.onSettled) == null || p.call(s, void 0, d);
      });
  if (
    a.isError &&
    !i.isReset() &&
    !a.isFetching &&
    rL(s.useErrorBoundary, [a.error, o.getCurrentQuery()])
  )
    throw a.error;
  const u =
      a.status === "loading" && a.fetchStatus === "idle" ? "idle" : a.status,
    l = u === "idle",
    c = u === "loading" && a.fetchStatus === "fetching";
  return {
    ...a,
    defaultedOptions: s,
    isIdle: l,
    isLoading: c,
    observer: o,
    status: u,
  };
}
function oL(e, t, n) {
  const r = tL(e, t, n),
    i = sL({ context: Cb, ...r }, mM),
    s = {
      data: i.data,
      error: i.error,
      fetchStatus: i.fetchStatus,
      isError: i.isError,
      isFetched: i.isFetched,
      isFetchedAfterMount: i.isFetchedAfterMount,
      isFetching: i.isFetching,
      isIdle: i.isIdle,
      isLoading: i.isLoading,
      isRefetching: i.isRefetching,
      isSuccess: i.isSuccess,
      refetch: i.refetch,
      status: i.status,
      internal: {
        dataUpdatedAt: i.dataUpdatedAt,
        errorUpdatedAt: i.errorUpdatedAt,
        failureCount: i.failureCount,
        isFetchedAfterMount: i.isFetchedAfterMount,
        isLoadingError: i.isLoadingError,
        isPaused: i.isPaused,
        isPlaceholderData: i.isPlaceholderData,
        isPreviousData: i.isPreviousData,
        isRefetchError: i.isRefetchError,
        isStale: i.isStale,
        remove: i.remove,
      },
    };
  return i.defaultedOptions.notifyOnChangeProps ? s : iL(s, i.observer);
}
var aL = () => jC({ context: Cb });
function uL({ chainId: e } = {}) {
  return zC.useSyncExternalStoreWithSelector(
    (t) => c8({ chainId: e }, t),
    () => Or({ chainId: e }),
    () => Or({ chainId: e }),
    (t) => t,
    (t, n) => t.uid === n.uid
  );
}
function Rm({ chainId: e }) {
  return [{ entity: "walletClient", chainId: e, persist: !1 }];
}
function cL({ queryKey: [{ chainId: e }] }) {
  return tC({ chainId: e });
}
function lL({
  chainId: e,
  suspense: t,
  onError: n,
  onSettled: r,
  onSuccess: i,
} = {}) {
  const { connector: s } = QC(),
    o = dL({ chainId: e }),
    a = oL(Rm({ chainId: o }), cL, {
      cacheTime: 0,
      enabled: !!s,
      staleTime: 1 / 0,
      suspense: t,
      onError: n,
      onSettled: r,
      onSuccess: i,
    }),
    u = aL();
  return (
    G.useEffect(
      () =>
        l8({ chainId: o }, (c) => {
          c
            ? u.invalidateQueries(Rm({ chainId: o }))
            : u.removeQueries(Rm({ chainId: o }));
        }),
      [u, o]
    ),
    a
  );
}
function dL({ chainId: e } = {}) {
  return uL({ chainId: e }).chain.id;
}
var Bm = (e) => typeof e == "object" && !Array.isArray(e);
function WC(e, t, n = t, r = Ay) {
  const i = G.useRef([]),
    s = zC.useSyncExternalStoreWithSelector(
      e,
      t,
      n,
      (o) => o,
      (o, a) => {
        if (Bm(o) && Bm(a) && i.current.length) {
          for (const u of i.current) if (!r(o[u], a[u])) return !1;
          return !0;
        }
        return r(o, a);
      }
    );
  if (Bm(s)) {
    const o = { ...s };
    return (
      Object.defineProperties(
        o,
        Object.entries(o).reduce(
          (a, [u, l]) => ({
            ...a,
            [u]: {
              configurable: !1,
              enumerable: !0,
              get: () => (i.current.includes(u) || i.current.push(u), l),
            },
          }),
          {}
        )
      ),
      o
    );
  }
  return s;
}
function QC({ onConnect: e, onDisconnect: t } = {}) {
  const n = qC(),
    r = G.useCallback((a) => nC(a), [n]),
    i = WC(r, pb),
    s = G.useRef(),
    o = s.current;
  return (
    G.useEffect(() => {
      (o == null ? void 0 : o.status) !== "connected" &&
        i.status === "connected" &&
        (e == null ||
          e({
            address: i.address,
            connector: i.connector,
            isReconnected:
              (o == null ? void 0 : o.status) === "reconnecting" ||
              (o == null ? void 0 : o.status) === void 0,
          })),
        (o == null ? void 0 : o.status) === "connected" &&
          i.status === "disconnected" &&
          (t == null || t()),
        (s.current = i);
    }, [e, t, o, i]),
    i
  );
}
function fL() {
  const e = qC(),
    t = G.useCallback((n) => rC(n), [e]);
  return WC(t, mb);
}
function VC(e) {
  var t,
    n,
    r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object")
    if (Array.isArray(e))
      for (t = 0; t < e.length; t++)
        e[t] && (n = VC(e[t])) && (r && (r += " "), (r += n));
    else for (t in e) e[t] && (r && (r += " "), (r += t));
  return r;
}
function Ui() {
  for (var e, t, n = 0, r = ""; n < arguments.length; )
    (e = arguments[n++]) && (t = VC(e)) && (r && (r += " "), (r += t));
  return r;
}
const Fu = (e) => typeof e == "number" && !isNaN(e),
  to = (e) => typeof e == "string",
  mn = (e) => typeof e == "function",
  xd = (e) => (to(e) || mn(e) ? e : null),
  Nm = (e) => G.isValidElement(e) || to(e) || mn(e) || Fu(e);
function hL(e, t, n) {
  n === void 0 && (n = 300);
  const { scrollHeight: r, style: i } = e;
  requestAnimationFrame(() => {
    (i.minHeight = "initial"),
      (i.height = r + "px"),
      (i.transition = `all ${n}ms`),
      requestAnimationFrame(() => {
        (i.height = "0"), (i.padding = "0"), (i.margin = "0"), setTimeout(t, n);
      });
  });
}
function op(e) {
  let {
    enter: t,
    exit: n,
    appendPosition: r = !1,
    collapse: i = !0,
    collapseDuration: s = 300,
  } = e;
  return function (o) {
    let {
      children: a,
      position: u,
      preventExitTransition: l,
      done: c,
      nodeRef: d,
      isIn: f,
    } = o;
    const p = r ? `${t}--${u}` : t,
      m = r ? `${n}--${u}` : n,
      g = G.useRef(0);
    return (
      G.useLayoutEffect(() => {
        const w = d.current,
          v = p.split(" "),
          y = (b) => {
            b.target === d.current &&
              (w.dispatchEvent(new Event("d")),
              w.removeEventListener("animationend", y),
              w.removeEventListener("animationcancel", y),
              g.current === 0 &&
                b.type !== "animationcancel" &&
                w.classList.remove(...v));
          };
        w.classList.add(...v),
          w.addEventListener("animationend", y),
          w.addEventListener("animationcancel", y);
      }, []),
      G.useEffect(() => {
        const w = d.current,
          v = () => {
            w.removeEventListener("animationend", v), i ? hL(w, c, s) : c();
          };
        f ||
          (l
            ? v()
            : ((g.current = 1),
              (w.className += ` ${m}`),
              w.addEventListener("animationend", v)));
      }, [f]),
      Me.createElement(Me.Fragment, null, a)
    );
  };
}
function l_(e, t) {
  return e != null
    ? {
        content: e.content,
        containerId: e.props.containerId,
        id: e.props.toastId,
        theme: e.props.theme,
        type: e.props.type,
        data: e.props.data || {},
        isLoading: e.props.isLoading,
        icon: e.props.icon,
        status: t,
      }
    : {};
}
const zn = {
    list: new Map(),
    emitQueue: new Map(),
    on(e, t) {
      return (
        this.list.has(e) || this.list.set(e, []), this.list.get(e).push(t), this
      );
    },
    off(e, t) {
      if (t) {
        const n = this.list.get(e).filter((r) => r !== t);
        return this.list.set(e, n), this;
      }
      return this.list.delete(e), this;
    },
    cancelEmit(e) {
      const t = this.emitQueue.get(e);
      return t && (t.forEach(clearTimeout), this.emitQueue.delete(e)), this;
    },
    emit(e) {
      this.list.has(e) &&
        this.list.get(e).forEach((t) => {
          const n = setTimeout(() => {
            t(...[].slice.call(arguments, 1));
          }, 0);
          this.emitQueue.has(e) || this.emitQueue.set(e, []),
            this.emitQueue.get(e).push(n);
        });
    },
  },
  Yl = (e) => {
    let { theme: t, type: n, ...r } = e;
    return Me.createElement("svg", {
      viewBox: "0 0 24 24",
      width: "100%",
      height: "100%",
      fill:
        t === "colored" ? "currentColor" : `var(--toastify-icon-color-${n})`,
      ...r,
    });
  },
  Mm = {
    info: function (e) {
      return Me.createElement(
        Yl,
        { ...e },
        Me.createElement("path", {
          d: "M12 0a12 12 0 1012 12A12.013 12.013 0 0012 0zm.25 5a1.5 1.5 0 11-1.5 1.5 1.5 1.5 0 011.5-1.5zm2.25 13.5h-4a1 1 0 010-2h.75a.25.25 0 00.25-.25v-4.5a.25.25 0 00-.25-.25h-.75a1 1 0 010-2h1a2 2 0 012 2v4.75a.25.25 0 00.25.25h.75a1 1 0 110 2z",
        })
      );
    },
    warning: function (e) {
      return Me.createElement(
        Yl,
        { ...e },
        Me.createElement("path", {
          d: "M23.32 17.191L15.438 2.184C14.728.833 13.416 0 11.996 0c-1.42 0-2.733.833-3.443 2.184L.533 17.448a4.744 4.744 0 000 4.368C1.243 23.167 2.555 24 3.975 24h16.05C22.22 24 24 22.044 24 19.632c0-.904-.251-1.746-.68-2.44zm-9.622 1.46c0 1.033-.724 1.823-1.698 1.823s-1.698-.79-1.698-1.822v-.043c0-1.028.724-1.822 1.698-1.822s1.698.79 1.698 1.822v.043zm.039-12.285l-.84 8.06c-.057.581-.408.943-.897.943-.49 0-.84-.367-.896-.942l-.84-8.065c-.057-.624.25-1.095.779-1.095h1.91c.528.005.84.476.784 1.1z",
        })
      );
    },
    success: function (e) {
      return Me.createElement(
        Yl,
        { ...e },
        Me.createElement("path", {
          d: "M12 0a12 12 0 1012 12A12.014 12.014 0 0012 0zm6.927 8.2l-6.845 9.289a1.011 1.011 0 01-1.43.188l-4.888-3.908a1 1 0 111.25-1.562l4.076 3.261 6.227-8.451a1 1 0 111.61 1.183z",
        })
      );
    },
    error: function (e) {
      return Me.createElement(
        Yl,
        { ...e },
        Me.createElement("path", {
          d: "M11.983 0a12.206 12.206 0 00-8.51 3.653A11.8 11.8 0 000 12.207 11.779 11.779 0 0011.8 24h.214A12.111 12.111 0 0024 11.791 11.766 11.766 0 0011.983 0zM10.5 16.542a1.476 1.476 0 011.449-1.53h.027a1.527 1.527 0 011.523 1.47 1.475 1.475 0 01-1.449 1.53h-.027a1.529 1.529 0 01-1.523-1.47zM11 12.5v-6a1 1 0 012 0v6a1 1 0 11-2 0z",
        })
      );
    },
    spinner: function () {
      return Me.createElement("div", { className: "Toastify__spinner" });
    },
  };
function pL(e) {
  const [, t] = G.useReducer((p) => p + 1, 0),
    [n, r] = G.useState([]),
    i = G.useRef(null),
    s = G.useRef(new Map()).current,
    o = (p) => n.indexOf(p) !== -1,
    a = G.useRef({
      toastKey: 1,
      displayedToast: 0,
      count: 0,
      queue: [],
      props: e,
      containerId: null,
      isToastActive: o,
      getToast: (p) => s.get(p),
    }).current;
  function u(p) {
    let { containerId: m } = p;
    const { limit: g } = a.props;
    !g ||
      (m && a.containerId !== m) ||
      ((a.count -= a.queue.length), (a.queue = []));
  }
  function l(p) {
    r((m) => (p == null ? [] : m.filter((g) => g !== p)));
  }
  function c() {
    const { toastContent: p, toastProps: m, staleId: g } = a.queue.shift();
    f(p, m, g);
  }
  function d(p, m) {
    let { delay: g, staleId: w, ...v } = m;
    if (
      !Nm(p) ||
      (function (O) {
        return (
          !i.current ||
          (a.props.enableMultiContainer &&
            O.containerId !== a.props.containerId) ||
          (s.has(O.toastId) && O.updateId == null)
        );
      })(v)
    )
      return;
    const { toastId: y, updateId: b, data: _ } = v,
      { props: A } = a,
      x = () => l(y),
      h = b == null;
    h && a.count++;
    const E = {
      ...A,
      style: A.toastStyle,
      key: a.toastKey++,
      ...Object.fromEntries(
        Object.entries(v).filter((O) => {
          let [R, N] = O;
          return N != null;
        })
      ),
      toastId: y,
      updateId: b,
      data: _,
      closeToast: x,
      isIn: !1,
      className: xd(v.className || A.toastClassName),
      bodyClassName: xd(v.bodyClassName || A.bodyClassName),
      progressClassName: xd(v.progressClassName || A.progressClassName),
      autoClose:
        !v.isLoading &&
        ((I = v.autoClose),
        (C = A.autoClose),
        I === !1 || (Fu(I) && I > 0) ? I : C),
      deleteToast() {
        const O = l_(s.get(y), "removed");
        s.delete(y), zn.emit(4, O);
        const R = a.queue.length;
        if (
          ((a.count = y == null ? a.count - a.displayedToast : a.count - 1),
          a.count < 0 && (a.count = 0),
          R > 0)
        ) {
          const N = y == null ? a.props.limit : 1;
          if (R === 1 || N === 1) a.displayedToast++, c();
          else {
            const S = N > R ? R : N;
            a.displayedToast = S;
            for (let T = 0; T < S; T++) c();
          }
        } else t();
      },
    };
    var I, C;
    (E.iconOut = (function (O) {
      let { theme: R, type: N, isLoading: S, icon: T } = O,
        D = null;
      const P = { theme: R, type: N };
      return (
        T === !1 ||
          (mn(T)
            ? (D = T(P))
            : G.isValidElement(T)
            ? (D = G.cloneElement(T, P))
            : to(T) || Fu(T)
            ? (D = T)
            : S
            ? (D = Mm.spinner())
            : ((B) => B in Mm)(N) && (D = Mm[N](P))),
        D
      );
    })(E)),
      mn(v.onOpen) && (E.onOpen = v.onOpen),
      mn(v.onClose) && (E.onClose = v.onClose),
      (E.closeButton = A.closeButton),
      v.closeButton === !1 || Nm(v.closeButton)
        ? (E.closeButton = v.closeButton)
        : v.closeButton === !0 &&
          (E.closeButton = !Nm(A.closeButton) || A.closeButton);
    let k = p;
    G.isValidElement(p) && !to(p.type)
      ? (k = G.cloneElement(p, { closeToast: x, toastProps: E, data: _ }))
      : mn(p) && (k = p({ closeToast: x, toastProps: E, data: _ })),
      A.limit && A.limit > 0 && a.count > A.limit && h
        ? a.queue.push({ toastContent: k, toastProps: E, staleId: w })
        : Fu(g)
        ? setTimeout(() => {
            f(k, E, w);
          }, g)
        : f(k, E, w);
  }
  function f(p, m, g) {
    const { toastId: w } = m;
    g && s.delete(g);
    const v = { content: p, props: m };
    s.set(w, v),
      r((y) => [...y, w].filter((b) => b !== g)),
      zn.emit(4, l_(v, v.props.updateId == null ? "added" : "updated"));
  }
  return (
    G.useEffect(
      () => (
        (a.containerId = e.containerId),
        zn
          .cancelEmit(3)
          .on(0, d)
          .on(1, (p) => i.current && l(p))
          .on(5, u)
          .emit(2, a),
        () => {
          s.clear(), zn.emit(3, a);
        }
      ),
      []
    ),
    G.useEffect(() => {
      (a.props = e), (a.isToastActive = o), (a.displayedToast = n.length);
    }),
    {
      getToastToRender: function (p) {
        const m = new Map(),
          g = Array.from(s.values());
        return (
          e.newestOnTop && g.reverse(),
          g.forEach((w) => {
            const { position: v } = w.props;
            m.has(v) || m.set(v, []), m.get(v).push(w);
          }),
          Array.from(m, (w) => p(w[0], w[1]))
        );
      },
      containerRef: i,
      isToastActive: o,
    }
  );
}
function d_(e) {
  return e.targetTouches && e.targetTouches.length >= 1
    ? e.targetTouches[0].clientX
    : e.clientX;
}
function f_(e) {
  return e.targetTouches && e.targetTouches.length >= 1
    ? e.targetTouches[0].clientY
    : e.clientY;
}
function mL(e) {
  const [t, n] = G.useState(!1),
    [r, i] = G.useState(!1),
    s = G.useRef(null),
    o = G.useRef({
      start: 0,
      x: 0,
      y: 0,
      delta: 0,
      removalDistance: 0,
      canCloseOnClick: !0,
      canDrag: !1,
      boundingRect: null,
      didMove: !1,
    }).current,
    a = G.useRef(e),
    {
      autoClose: u,
      pauseOnHover: l,
      closeToast: c,
      onClick: d,
      closeOnClick: f,
    } = e;
  function p(_) {
    if (e.draggable) {
      _.nativeEvent.type === "touchstart" && _.nativeEvent.preventDefault(),
        (o.didMove = !1),
        document.addEventListener("mousemove", v),
        document.addEventListener("mouseup", y),
        document.addEventListener("touchmove", v),
        document.addEventListener("touchend", y);
      const A = s.current;
      (o.canCloseOnClick = !0),
        (o.canDrag = !0),
        (o.boundingRect = A.getBoundingClientRect()),
        (A.style.transition = ""),
        (o.x = d_(_.nativeEvent)),
        (o.y = f_(_.nativeEvent)),
        e.draggableDirection === "x"
          ? ((o.start = o.x),
            (o.removalDistance = A.offsetWidth * (e.draggablePercent / 100)))
          : ((o.start = o.y),
            (o.removalDistance =
              A.offsetHeight *
              (e.draggablePercent === 80
                ? 1.5 * e.draggablePercent
                : e.draggablePercent / 100)));
    }
  }
  function m(_) {
    if (o.boundingRect) {
      const { top: A, bottom: x, left: h, right: E } = o.boundingRect;
      _.nativeEvent.type !== "touchend" &&
      e.pauseOnHover &&
      o.x >= h &&
      o.x <= E &&
      o.y >= A &&
      o.y <= x
        ? w()
        : g();
    }
  }
  function g() {
    n(!0);
  }
  function w() {
    n(!1);
  }
  function v(_) {
    const A = s.current;
    o.canDrag &&
      A &&
      ((o.didMove = !0),
      t && w(),
      (o.x = d_(_)),
      (o.y = f_(_)),
      (o.delta = e.draggableDirection === "x" ? o.x - o.start : o.y - o.start),
      o.start !== o.x && (o.canCloseOnClick = !1),
      (A.style.transform = `translate${e.draggableDirection}(${o.delta}px)`),
      (A.style.opacity = "" + (1 - Math.abs(o.delta / o.removalDistance))));
  }
  function y() {
    document.removeEventListener("mousemove", v),
      document.removeEventListener("mouseup", y),
      document.removeEventListener("touchmove", v),
      document.removeEventListener("touchend", y);
    const _ = s.current;
    if (o.canDrag && o.didMove && _) {
      if (((o.canDrag = !1), Math.abs(o.delta) > o.removalDistance))
        return i(!0), void e.closeToast();
      (_.style.transition = "transform 0.2s, opacity 0.2s"),
        (_.style.transform = `translate${e.draggableDirection}(0)`),
        (_.style.opacity = "1");
    }
  }
  G.useEffect(() => {
    a.current = e;
  }),
    G.useEffect(
      () => (
        s.current && s.current.addEventListener("d", g, { once: !0 }),
        mn(e.onOpen) &&
          e.onOpen(G.isValidElement(e.children) && e.children.props),
        () => {
          const _ = a.current;
          mn(_.onClose) &&
            _.onClose(G.isValidElement(_.children) && _.children.props);
        }
      ),
      []
    ),
    G.useEffect(
      () => (
        e.pauseOnFocusLoss &&
          (document.hasFocus() || w(),
          window.addEventListener("focus", g),
          window.addEventListener("blur", w)),
        () => {
          e.pauseOnFocusLoss &&
            (window.removeEventListener("focus", g),
            window.removeEventListener("blur", w));
        }
      ),
      [e.pauseOnFocusLoss]
    );
  const b = { onMouseDown: p, onTouchStart: p, onMouseUp: m, onTouchEnd: m };
  return (
    u && l && ((b.onMouseEnter = w), (b.onMouseLeave = g)),
    f &&
      (b.onClick = (_) => {
        d && d(_), o.canCloseOnClick && c();
      }),
    {
      playToast: g,
      pauseToast: w,
      isRunning: t,
      preventExitTransition: r,
      toastRef: s,
      eventHandlers: b,
    }
  );
}
function KC(e) {
  let { closeToast: t, theme: n, ariaLabel: r = "close" } = e;
  return Me.createElement(
    "button",
    {
      className: `Toastify__close-button Toastify__close-button--${n}`,
      type: "button",
      onClick: (i) => {
        i.stopPropagation(), t(i);
      },
      "aria-label": r,
    },
    Me.createElement(
      "svg",
      { "aria-hidden": "true", viewBox: "0 0 14 16" },
      Me.createElement("path", {
        fillRule: "evenodd",
        d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z",
      })
    )
  );
}
function yL(e) {
  let {
    delay: t,
    isRunning: n,
    closeToast: r,
    type: i = "default",
    hide: s,
    className: o,
    style: a,
    controlledProgress: u,
    progress: l,
    rtl: c,
    isIn: d,
    theme: f,
  } = e;
  const p = s || (u && l === 0),
    m = {
      ...a,
      animationDuration: `${t}ms`,
      animationPlayState: n ? "running" : "paused",
      opacity: p ? 0 : 1,
    };
  u && (m.transform = `scaleX(${l})`);
  const g = Ui(
      "Toastify__progress-bar",
      u
        ? "Toastify__progress-bar--controlled"
        : "Toastify__progress-bar--animated",
      `Toastify__progress-bar-theme--${f}`,
      `Toastify__progress-bar--${i}`,
      { "Toastify__progress-bar--rtl": c }
    ),
    w = mn(o) ? o({ rtl: c, type: i, defaultClassName: g }) : Ui(g, o);
  return Me.createElement("div", {
    role: "progressbar",
    "aria-hidden": p ? "true" : "false",
    "aria-label": "notification timer",
    className: w,
    style: m,
    [u && l >= 1 ? "onTransitionEnd" : "onAnimationEnd"]:
      u && l < 1
        ? null
        : () => {
            d && r();
          },
  });
}
const gL = (e) => {
    const {
        isRunning: t,
        preventExitTransition: n,
        toastRef: r,
        eventHandlers: i,
      } = mL(e),
      {
        closeButton: s,
        children: o,
        autoClose: a,
        onClick: u,
        type: l,
        hideProgressBar: c,
        closeToast: d,
        transition: f,
        position: p,
        className: m,
        style: g,
        bodyClassName: w,
        bodyStyle: v,
        progressClassName: y,
        progressStyle: b,
        updateId: _,
        role: A,
        progress: x,
        rtl: h,
        toastId: E,
        deleteToast: I,
        isIn: C,
        isLoading: k,
        iconOut: O,
        closeOnClick: R,
        theme: N,
      } = e,
      S = Ui(
        "Toastify__toast",
        `Toastify__toast-theme--${N}`,
        `Toastify__toast--${l}`,
        { "Toastify__toast--rtl": h },
        { "Toastify__toast--close-on-click": R }
      ),
      T = mn(m)
        ? m({ rtl: h, position: p, type: l, defaultClassName: S })
        : Ui(S, m),
      D = !!x || !a,
      P = { closeToast: d, type: l, theme: N };
    let B = null;
    return (
      s === !1 ||
        (B = mn(s) ? s(P) : G.isValidElement(s) ? G.cloneElement(s, P) : KC(P)),
      Me.createElement(
        f,
        { isIn: C, done: I, position: p, preventExitTransition: n, nodeRef: r },
        Me.createElement(
          "div",
          { id: E, onClick: u, className: T, ...i, style: g, ref: r },
          Me.createElement(
            "div",
            {
              ...(C && { role: A }),
              className: mn(w) ? w({ type: l }) : Ui("Toastify__toast-body", w),
              style: v,
            },
            O != null &&
              Me.createElement(
                "div",
                {
                  className: Ui("Toastify__toast-icon", {
                    "Toastify--animate-icon Toastify__zoom-enter": !k,
                  }),
                },
                O
              ),
            Me.createElement("div", null, o)
          ),
          B,
          Me.createElement(yL, {
            ...(_ && !D ? { key: `pb-${_}` } : {}),
            rtl: h,
            theme: N,
            delay: a,
            isRunning: t,
            isIn: C,
            closeToast: d,
            hide: c,
            type: l,
            style: b,
            className: y,
            controlledProgress: D,
            progress: x || 0,
          })
        )
      )
    );
  },
  ap = function (e, t) {
    return (
      t === void 0 && (t = !1),
      {
        enter: `Toastify--animate Toastify__${e}-enter`,
        exit: `Toastify--animate Toastify__${e}-exit`,
        appendPosition: t,
      }
    );
  },
  vL = op(ap("bounce", !0));
op(ap("slide", !0));
op(ap("zoom"));
op(ap("flip"));
const Ky = G.forwardRef((e, t) => {
  const { getToastToRender: n, containerRef: r, isToastActive: i } = pL(e),
    { className: s, style: o, rtl: a, containerId: u } = e;
  function l(c) {
    const d = Ui(
      "Toastify__toast-container",
      `Toastify__toast-container--${c}`,
      { "Toastify__toast-container--rtl": a }
    );
    return mn(s)
      ? s({ position: c, rtl: a, defaultClassName: d })
      : Ui(d, xd(s));
  }
  return (
    G.useEffect(() => {
      t && (t.current = r.current);
    }, []),
    Me.createElement(
      "div",
      { ref: r, className: "Toastify", id: u },
      n((c, d) => {
        const f = d.length ? { ...o } : { ...o, pointerEvents: "none" };
        return Me.createElement(
          "div",
          { className: l(c), style: f, key: `container-${c}` },
          d.map((p, m) => {
            let { content: g, props: w } = p;
            return Me.createElement(
              gL,
              {
                ...w,
                isIn: i(w.toastId),
                style: { ...w.style, "--nth": m + 1, "--len": d.length },
                key: `toast-${w.key}`,
              },
              g
            );
          })
        );
      })
    )
  );
});
(Ky.displayName = "ToastContainer"),
  (Ky.defaultProps = {
    position: "top-right",
    transition: vL,
    autoClose: 5e3,
    closeButton: KC,
    pauseOnHover: !0,
    pauseOnFocusLoss: !0,
    closeOnClick: !0,
    draggable: !0,
    draggablePercent: 80,
    draggableDirection: "x",
    role: "alert",
    theme: "light",
  });
let Lm,
  Is = new Map(),
  Eu = [],
  bL = 1;
function ZC() {
  return "" + bL++;
}
function wL(e) {
  return e && (to(e.toastId) || Fu(e.toastId)) ? e.toastId : ZC();
}
function ju(e, t) {
  return (
    Is.size > 0 ? zn.emit(0, e, t) : Eu.push({ content: e, options: t }),
    t.toastId
  );
}
function Cf(e, t) {
  return { ...t, type: (t && t.type) || e, toastId: wL(t) };
}
function Xl(e) {
  return (t, n) => ju(t, Cf(e, n));
}
function Fe(e, t) {
  return ju(e, Cf("default", t));
}
(Fe.loading = (e, t) =>
  ju(
    e,
    Cf("default", {
      isLoading: !0,
      autoClose: !1,
      closeOnClick: !1,
      closeButton: !1,
      draggable: !1,
      ...t,
    })
  )),
  (Fe.promise = function (e, t, n) {
    let r,
      { pending: i, error: s, success: o } = t;
    i && (r = to(i) ? Fe.loading(i, n) : Fe.loading(i.render, { ...n, ...i }));
    const a = {
        isLoading: null,
        autoClose: null,
        closeOnClick: null,
        closeButton: null,
        draggable: null,
      },
      u = (c, d, f) => {
        if (d == null) return void Fe.dismiss(r);
        const p = { type: c, ...a, ...n, data: f },
          m = to(d) ? { render: d } : d;
        return (
          r ? Fe.update(r, { ...p, ...m }) : Fe(m.render, { ...p, ...m }), f
        );
      },
      l = mn(e) ? e() : e;
    return l.then((c) => u("success", o, c)).catch((c) => u("error", s, c)), l;
  }),
  (Fe.success = Xl("success")),
  (Fe.info = Xl("info")),
  (Fe.error = Xl("error")),
  (Fe.warning = Xl("warning")),
  (Fe.warn = Fe.warning),
  (Fe.dark = (e, t) => ju(e, Cf("default", { theme: "dark", ...t }))),
  (Fe.dismiss = (e) => {
    Is.size > 0
      ? zn.emit(1, e)
      : (Eu = Eu.filter((t) => e != null && t.options.toastId !== e));
  }),
  (Fe.clearWaitingQueue = function (e) {
    return e === void 0 && (e = {}), zn.emit(5, e);
  }),
  (Fe.isActive = (e) => {
    let t = !1;
    return (
      Is.forEach((n) => {
        n.isToastActive && n.isToastActive(e) && (t = !0);
      }),
      t
    );
  }),
  (Fe.update = function (e, t) {
    t === void 0 && (t = {}),
      setTimeout(() => {
        const n = (function (r, i) {
          let { containerId: s } = i;
          const o = Is.get(s || Lm);
          return o && o.getToast(r);
        })(e, t);
        if (n) {
          const { props: r, content: i } = n,
            s = {
              delay: 100,
              ...r,
              ...t,
              toastId: t.toastId || e,
              updateId: ZC(),
            };
          s.toastId !== e && (s.staleId = e);
          const o = s.render || i;
          delete s.render, ju(o, s);
        }
      }, 0);
  }),
  (Fe.done = (e) => {
    Fe.update(e, { progress: 1 });
  }),
  (Fe.onChange = (e) => (
    zn.on(4, e),
    () => {
      zn.off(4, e);
    }
  )),
  (Fe.POSITION = {
    TOP_LEFT: "top-left",
    TOP_RIGHT: "top-right",
    TOP_CENTER: "top-center",
    BOTTOM_LEFT: "bottom-left",
    BOTTOM_RIGHT: "bottom-right",
    BOTTOM_CENTER: "bottom-center",
  }),
  (Fe.TYPE = {
    INFO: "info",
    SUCCESS: "success",
    WARNING: "warning",
    ERROR: "error",
    DEFAULT: "default",
  }),
  zn
    .on(2, (e) => {
      (Lm = e.containerId || e),
        Is.set(Lm, e),
        Eu.forEach((t) => {
          zn.emit(0, t.content, t.options);
        }),
        (Eu = []);
    })
    .on(3, (e) => {
      Is.delete(e.containerId || e), Is.size === 0 && zn.off(0).off(1).off(5);
    });
var JC = {},
  YC = { exports: {} },
  EL = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  _L = EL,
  AL = _L;
function XC() {}
function e3() {}
e3.resetWarningCache = XC;
var xL = function () {
  function e(r, i, s, o, a, u) {
    if (u !== AL) {
      var l = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((l.name = "Invariant Violation"), l);
    }
  }
  e.isRequired = e;
  function t() {
    return e;
  }
  var n = {
    array: e,
    bigint: e,
    bool: e,
    func: e,
    number: e,
    object: e,
    string: e,
    symbol: e,
    any: e,
    arrayOf: t,
    element: e,
    elementType: e,
    instanceOf: t,
    node: e,
    objectOf: t,
    oneOf: t,
    oneOfType: t,
    shape: t,
    exact: t,
    checkPropTypes: e3,
    resetWarningCache: XC,
  };
  return (n.PropTypes = n), n;
};
YC.exports = xL();
var SL = YC.exports;
Object.defineProperty(JC, "__esModule", { value: !0 });
var CL = (function () {
    function e(t, n) {
      var r = [],
        i = !0,
        s = !1,
        o = void 0;
      try {
        for (
          var a = t[Symbol.iterator](), u;
          !(i = (u = a.next()).done) &&
          (r.push(u.value), !(n && r.length === n));
          i = !0
        );
      } catch (l) {
        (s = !0), (o = l);
      } finally {
        try {
          !i && a.return && a.return();
        } finally {
          if (s) throw o;
        }
      }
      return r;
    }
    return function (t, n) {
      if (Array.isArray(t)) return t;
      if (Symbol.iterator in Object(t)) return e(t, n);
      throw new TypeError(
        "Invalid attempt to destructure non-iterable instance"
      );
    };
  })(),
  Fm = G,
  TL = SL,
  wr = IL(TL);
function IL(e) {
  return e && e.__esModule ? e : { default: e };
}
function kL(e) {
  if (Array.isArray(e)) {
    for (var t = 0, n = Array(e.length); t < e.length; t++) n[t] = e[t];
    return n;
  } else return Array.from(e);
}
var h_ = function (t, n, r) {
    var i = t
        .reduce(function (o, a) {
          var u = a.font.replace(/ +/g, "+"),
            l = (a.weights || []).join(",");
          return [].concat(kL(o), [u + (l && ":" + l)]);
        }, [])
        .join("|"),
      s = document.createElement("link");
    return (
      (s.rel = "stylesheet"),
      (s.href = "https://fonts.googleapis.com/css?family=" + i),
      n &&
        Array.isArray(n) &&
        n.length > 0 &&
        (s.href += "&subset=" + n.join(",")),
      r && (s.href += "&display=" + r),
      s
    );
  },
  t3 = function (t) {
    var n = t.fonts,
      r = t.subsets,
      i = t.display,
      s = i === void 0 ? null : i,
      o = (0, Fm.useState)(h_(n, r, s)),
      a = CL(o, 2),
      u = a[0],
      l = a[1];
    return (
      (0, Fm.useEffect)(
        function () {
          return (
            document.head.appendChild(u),
            function () {
              return document.head.removeChild(u);
            }
          );
        },
        [u]
      ),
      (0, Fm.useEffect)(
        function () {
          l(h_(n, r, s));
        },
        [n, r, s]
      ),
      null
    );
  };
t3.propTypes = {
  fonts: wr.default.arrayOf(
    wr.default.shape({
      font: wr.default.string.isRequired,
      weights: wr.default.arrayOf(
        wr.default.oneOfType([wr.default.string, wr.default.number])
      ),
    })
  ).isRequired,
  subsets: wr.default.arrayOf(wr.default.string),
  display: wr.default.string,
};
var PL = (JC.default = t3);
const DL = "/assets/logo-mES7-zaY.png",
  OL = "/assets/stake-tKrcLwfT.png",
  p_ = "/assets/unstake-xp3miVG3.png";
function RL({ className: e, label: t = "Click me" }) {
  return (
    G.useRef(null),
    X.jsx($4, {
      className: "web3button",
      id: "web3_button",
      icon: "hide",
      label: "Connect Wallet",
      balance: "hide",
    })
  );
}
const Sd = [
    {
      network: 5,
      Token: "0x89aa619928B6880398572Ec4D4E4BbfEbce3Ad95",
      name: "TestToken",
      symbol: "TTK",
      decimals: "ether",
      Staking: "0xe5c159b494faf96e173e6458377b24ad4cbc801f",
    },
    {
      network: 1,
      Token: "0xF4AaA9428A881a5c054D0ED041F5749a336C9Ab5",
      name: "MysticAI",
      symbol: "MAI",
      decimals: "gwei",
      Staking: "0x856e0A5369a0ad77aa383BB7e434Bf89DDAFCBb3",
    },
  ],
  BL = "https://mainnet.infura.io/v3/7535811d19b1410e98c261fbb638651a",
  NL = 1,
  nt = Sd == null ? void 0 : Sd.find((e) => e.network === NL),
  Zy = [
    { inputs: [], stateMutability: "nonpayable", type: "constructor" },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "spender",
          type: "address",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Approval",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "address", name: "from", type: "address" },
        { indexed: !0, internalType: "address", name: "to", type: "address" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "value",
          type: "uint256",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "spender", type: "address" },
      ],
      name: "allowance",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "approve",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "account", type: "address" }],
      name: "balanceOf",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "decimals",
      outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "subtractedValue", type: "uint256" },
      ],
      name: "decreaseAllowance",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "spender", type: "address" },
        { internalType: "uint256", name: "addedValue", type: "uint256" },
      ],
      name: "increaseAllowance",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transfer",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "from", type: "address" },
        { internalType: "address", name: "to", type: "address" },
        { internalType: "uint256", name: "amount", type: "uint256" },
      ],
      name: "transferFrom",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  Jy = [
    {
      inputs: [
        { internalType: "address", name: "_stakingToken", type: "address" },
        { internalType: "uint256", name: "_stakingPeriod", type: "uint256" },
      ],
      stateMutability: "nonpayable",
      type: "constructor",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "previousOwner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "newOwner",
          type: "address",
        },
      ],
      name: "OwnershipTransferred",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "staker",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "timestamp",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "Staked",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "unstaker",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "uint256",
          name: "timestamp",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "uint256",
          name: "amount",
          type: "uint256",
        },
      ],
      name: "Unstaked",
      type: "event",
    },
    {
      inputs: [],
      name: "getAllStakers",
      outputs: [
        { internalType: "address[]", name: "_stakers", type: "address[]" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "_user", type: "address" }],
      name: "getStakeInfo",
      outputs: [
        { internalType: "uint256", name: "_stake", type: "uint256" },
        { internalType: "uint256", name: "_lastStakedTime", type: "uint256" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "renounceOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [
        { internalType: "uint256", name: "_stakingPeriod", type: "uint256" },
      ],
      name: "setStakingPeriod",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
      name: "stake",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "stakingPeriod",
      outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [],
      name: "stakingToken",
      outputs: [{ internalType: "contract IERC20", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
      name: "transferOwnership",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
      name: "unstake",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
    {
      inputs: [],
      name: "unstakeAll",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function",
    },
  ],
  ML = 100,
  LL = 101,
  FL = 201,
  jL = 202,
  UL = 203,
  $L = 204,
  HL = 205,
  zL = 206,
  GL = 207,
  qL = 300,
  WL = 301,
  QL = 310,
  VL = 311,
  KL = 400,
  ZL = 402,
  JL = 405,
  YL = 407,
  XL = 408,
  eF = 410,
  tF = 411,
  nF = 412,
  rF = 413,
  iF = 414,
  sF = 415,
  oF = 416,
  aF = 417,
  uF = 418,
  cF = 419,
  lF = 420,
  dF = 421,
  fF = 422,
  hF = 423,
  pF = 424,
  mF = 425,
  yF = 426,
  gF = 427,
  vF = 428,
  bF = 429,
  wF = 430,
  EF = 431,
  _F = 432,
  AF = 433,
  xF = 434,
  SF = 435,
  CF = 436,
  TF = 437,
  IF = 438,
  kF = 439,
  PF = 440,
  DF = 441,
  OF = 500,
  RF = 503,
  BF = 505,
  NF = 506,
  MF = 507,
  LF = 600,
  FF = 602,
  jF = 603,
  UF = 604,
  $F = 701,
  HF = 702,
  zF = 703,
  GF = 704,
  qF = 705,
  WF = 706,
  QF = 707,
  VF = 709,
  KF = 801,
  ZF = 802,
  JF = 4001,
  YF = 4100,
  XF = 4200,
  ej = 4900,
  tj = 4901,
  nj = 902,
  rj = 903,
  ij = 1001,
  sj = 1002,
  oj = 1003,
  aj = 1004,
  uj = 1005,
  cj = 1006,
  lj = 1008,
  dj = 1009,
  fj = 1010,
  hj = 1011,
  pj = 1012,
  mj = 1014,
  yj = 1100,
  n3 = 1101,
  gj = 1200,
  Tf = -32700,
  If = -32600,
  kf = -32601,
  Pf = -32602,
  Df = -32603,
  Of = -32e3,
  Rf = -32001,
  Bf = -32002,
  Nf = -32003,
  Mf = -32004,
  Lf = -32005,
  Ff = -32006;
class ue extends Error {
  constructor(t, n) {
    super(t),
      (this.innerError = n),
      (this.name = this.constructor.name),
      typeof Error.captureStackTrace == "function"
        ? Error.captureStackTrace(new.target.constructor)
        : (this.stack = new Error().stack);
  }
  static convertToString(t, n = !1) {
    if (t == null) return "undefined";
    const r = JSON.stringify(t, (i, s) =>
      typeof s == "bigint" ? s.toString() : s
    );
    return n && ["bigint", "string"].includes(typeof t)
      ? r.replace(/['\\"]+/g, "")
      : r;
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      innerError: this.innerError,
    };
  }
}
class be extends ue {
  constructor(t, n) {
    super(`Invalid value given "${ue.convertToString(t, !0)}". Error: ${n}.`),
      (this.name = this.constructor.name);
  }
}
class m_ extends ue {
  constructor() {
    super("Private key must be 32 bytes."), (this.code = $F);
  }
}
class vj extends ue {
  constructor() {
    super("Invalid Private Key, Not a valid string or uint8Array"),
      (this.code = HF);
  }
}
class bj extends ue {
  constructor(t) {
    super(`"${t}"`), (this.code = ZF);
  }
}
class r3 extends ue {
  constructor() {
    super("Invalid key derivation function"), (this.code = zF);
  }
}
class wj extends ue {
  constructor() {
    super("Key derivation failed - possibly wrong password"), (this.code = GF);
  }
}
class Ej extends ue {
  constructor() {
    super("Unsupported key store version"), (this.code = qF);
  }
}
class _j extends ue {
  constructor() {
    super("Password cannot be empty"), (this.code = WF);
  }
}
class Aj extends ue {
  constructor() {
    super("Initialization vector must be 16 bytes"), (this.code = QF);
  }
}
class xj extends ue {
  constructor() {
    super("c > 1000, pbkdf2 is less secure with less iterations"),
      (this.code = VF);
  }
}
class yl extends ue {
  constructor(t, n) {
    super(t),
      (this.code = OF),
      n && ((this.errorCode = n.code), (this.errorReason = n.reason));
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      errorCode: this.errorCode,
      errorReason: this.errorReason,
    });
  }
}
class Yy extends yl {
  constructor(t) {
    super("Connection not open", t), (this.code = RF);
  }
}
class Sj extends yl {
  constructor(t) {
    super(`Maximum number of reconnect attempts reached! (${t})`),
      (this.code = BF);
  }
}
class Cj extends yl {
  constructor() {
    super(
      "CONNECTION ERROR: Provider started to reconnect before the response got received!"
    ),
      (this.code = NF);
  }
}
class Tj extends yl {
  constructor(t) {
    super(`Request already sent with following id: ${t}`), (this.code = MF);
  }
}
class Tn extends ue {
  constructor(t, n) {
    super(t), (this.code = qL), (this.receipt = n);
  }
}
class y_ extends ue {
  constructor(t, n) {
    super(`The resolver at ${t} does not implement requested method: "${n}".`),
      (this.address = t),
      (this.name = n),
      (this.code = WL);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      address: this.address,
      name: this.name,
    });
  }
}
class up extends Tn {
  constructor(t) {
    if (
      (super(t.message || "Error"),
      (this.name = ("name" in t && t.name) || this.constructor.name),
      (this.stack = ("stack" in t && t.stack) || void 0),
      (this.code = t.code),
      typeof t.data == "object")
    ) {
      let n;
      "originalError" in t.data ? (n = t.data.originalError) : (n = t.data),
        (this.data = n.data),
        (this.innerError = new up(n));
    } else this.data = t.data;
  }
  setDecodedProperties(t, n, r) {
    (this.errorName = t), (this.errorSignature = n), (this.errorArgs = r);
  }
  toJSON() {
    let t = Object.assign(Object.assign({}, super.toJSON()), {
      data: this.data,
    });
    return (
      this.errorName &&
        (t = Object.assign(Object.assign({}, t), {
          errorName: this.errorName,
          errorSignature: this.errorSignature,
          errorArgs: this.errorArgs,
        })),
      t
    );
  }
}
class zs extends Tn {
  constructor(t) {
    super(
      "Error happened while trying to execute a function inside a smart contract"
    ),
      (this.code = QL),
      (this.innerError = new up(t));
  }
}
class Ij extends be {
  constructor(t) {
    var n, r;
    super(
      `data: ${
        (n = t.data) !== null && n !== void 0 ? n : "undefined"
      }, input: ${(r = t.input) !== null && r !== void 0 ? r : "undefined"}`,
      `You can't have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.`
    ),
      (this.code = VL);
  }
}
class kj extends ue {
  constructor(t) {
    super(`ENS is not supported on network ${t}`), (this.code = nj);
  }
}
class Pj extends ue {
  constructor() {
    super("Network not synced"), (this.code = rj);
  }
}
class g_ extends ue {
  constructor(t) {
    super(`Invalid parameters passed. "${typeof t < "u" ? t : ""}"`),
      (this.hint = t),
      (this.code = GL);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      hint: this.hint,
    });
  }
}
class Xy extends ue {
  constructor() {
    super(...arguments), (this.code = FL);
  }
}
class $r extends ue {
  constructor() {
    super("The method you're trying to call is not implemented."),
      (this.code = jL);
  }
}
class i3 extends ue {
  constructor() {
    super(...arguments), (this.code = UL);
  }
}
class Dj extends ue {
  constructor() {
    super(...arguments), (this.code = $L);
  }
}
class Te extends ue {
  constructor(t, n) {
    super(t), (this.code = HL), (this.props = n ?? {});
  }
}
class Oj extends ue {
  constructor(t) {
    super(`A plugin with the namespace: ${t} has already been registered.`),
      (this.code = zL);
  }
}
class Cd extends ue {
  constructor() {
    super(...arguments), (this.code = LF);
  }
}
class eg extends ue {
  constructor(t) {
    super(`Client URL "${t}" is invalid.`), (this.code = FF);
  }
}
class or extends ue {
  constructor() {
    super(...arguments), (this.code = jF);
  }
}
class Rj extends ue {
  constructor() {
    super(...arguments), (this.code = UF);
  }
}
class Bj extends be {
  constructor() {
    super(...arguments), (this.code = KF);
  }
}
class Tb extends ue {
  constructor(t, n) {
    super(t), (this.receipt = n), (this.code = KL);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      receipt: this.receipt,
    });
  }
}
class jf extends ue {
  constructor(t, n, r, i) {
    super(
      `Transaction has been reverted by the EVM${
        r === void 0
          ? ""
          : `:
 ${ue.convertToString(r)}`
      }`
    ),
      (this.reason = t),
      (this.signature = n),
      (this.receipt = r),
      (this.data = i),
      (this.code = ZL);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      reason: this.reason,
      signature: this.signature,
      receipt: this.receipt,
      data: this.data,
    });
  }
}
class s3 extends jf {
  constructor(t, n, r, i, s, o, a) {
    super(t),
      (this.reason = t),
      (this.customErrorName = n),
      (this.customErrorDecodedSignature = r),
      (this.customErrorArguments = i),
      (this.signature = s),
      (this.receipt = o),
      (this.data = a),
      (this.code = IF);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      reason: this.reason,
      customErrorName: this.customErrorName,
      customErrorDecodedSignature: this.customErrorDecodedSignature,
      customErrorArguments: this.customErrorArguments,
      signature: this.signature,
      receipt: this.receipt,
      data: this.data,
    });
  }
}
class o3 extends Tb {
  constructor(t) {
    super(
      `Transaction has been reverted by the EVM${
        t === void 0
          ? ""
          : `:
 ${ue.convertToString(t)}`
      }`,
      t
    ),
      (this.code = JL);
  }
}
class Nj extends Tb {
  constructor() {
    super("Raw transaction undefined"), (this.code = YL);
  }
}
class v_ extends Tb {
  constructor() {
    super("Transaction not found"), (this.code = wF);
  }
}
class Mj extends be {
  constructor(t) {
    super(t, "invalid transaction with invalid sender"), (this.code = XL);
  }
}
class Lj extends be {
  constructor(t) {
    super(t, "invalid transaction with invalid receiver"), (this.code = TF);
  }
}
class Fj extends be {
  constructor() {
    super(
      "MissingCustomChainError",
      "If tx.common is provided it must have tx.common.customChain"
    ),
      (this.code = eF);
  }
}
class jj extends be {
  constructor() {
    super(
      "MissingCustomChainIdError",
      "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId"
    ),
      (this.code = tF);
  }
}
class Uj extends be {
  constructor(t) {
    super(
      JSON.stringify(t),
      "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId"
    ),
      (this.code = nF);
  }
}
class $j extends be {
  constructor(t) {
    super(
      JSON.stringify(t),
      "Chain doesnt match in tx.chain tx.common.basechain"
    ),
      (this.code = SF);
  }
}
class Hj extends be {
  constructor(t) {
    super(
      JSON.stringify(t),
      "hardfork doesnt match in tx.hardfork tx.common.hardfork"
    ),
      (this.code = CF);
  }
}
class zj extends be {
  constructor() {
    super(
      "CommonOrChainAndHardforkError",
      "Please provide the common object or the chain and hardfork property but not all together."
    ),
      (this.code = rF);
  }
}
class Gj extends be {
  constructor(t) {
    var n, r;
    super(
      "MissingChainOrHardforkError",
      `When specifying chain and hardfork, both values must be defined. Received "chain": ${
        (n = t.chain) !== null && n !== void 0 ? n : "undefined"
      }, "hardfork": ${
        (r = t.hardfork) !== null && r !== void 0 ? r : "undefined"
      }`
    ),
      (this.code = iF);
  }
}
class qj extends ue {
  constructor() {
    super(
      'Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions'
    ),
      (this.code = PF);
  }
}
class Wj extends be {
  constructor(t) {
    var n, r, i, s;
    super(
      `gas: ${
        (n = t.gas) !== null && n !== void 0 ? n : "undefined"
      }, gasPrice: ${
        (r = t.gasPrice) !== null && r !== void 0 ? r : "undefined"
      }, maxPriorityFeePerGas: ${
        (i = t.maxPriorityFeePerGas) !== null && i !== void 0 ? i : "undefined"
      }, maxFeePerGas: ${
        (s = t.maxFeePerGas) !== null && s !== void 0 ? s : "undefined"
      }`,
      '"gas" is missing'
    ),
      (this.code = sF),
      (this.innerError = new qj());
  }
}
class Qj extends ue {
  constructor() {
    super(
      'Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both'
    ),
      (this.code = DF);
  }
}
class Vj extends be {
  constructor(t) {
    var n, r, i, s;
    super(
      `gas: ${
        (n = t.gas) !== null && n !== void 0 ? n : "undefined"
      }, gasPrice: ${
        (r = t.gasPrice) !== null && r !== void 0 ? r : "undefined"
      }, maxPriorityFeePerGas: ${
        (i = t.maxPriorityFeePerGas) !== null && i !== void 0 ? i : "undefined"
      }, maxFeePerGas: ${
        (s = t.maxFeePerGas) !== null && s !== void 0 ? s : "undefined"
      }`,
      "transaction must specify legacy or fee market gas properties, not both"
    ),
      (this.code = xF),
      (this.innerError = new Qj());
  }
}
class Kj extends be {
  constructor(t) {
    var n, r;
    super(
      `gas: ${
        (n = t.gas) !== null && n !== void 0 ? n : "undefined"
      }, gasPrice: ${
        (r = t.gasPrice) !== null && r !== void 0 ? r : "undefined"
      }`,
      "Gas or gasPrice is lower than 0"
    ),
      (this.code = oF);
  }
}
class Zj extends be {
  constructor(t) {
    var n, r;
    super(
      `maxPriorityFeePerGas: ${
        (n = t.maxPriorityFeePerGas) !== null && n !== void 0 ? n : "undefined"
      }, maxFeePerGas: ${
        (r = t.maxFeePerGas) !== null && r !== void 0 ? r : "undefined"
      }`,
      "maxPriorityFeePerGas or maxFeePerGas is lower than 0"
    ),
      (this.code = aF);
  }
}
class Jj extends be {
  constructor(t) {
    super(t, "eip-1559 transactions don't support gasPrice"), (this.code = uF);
  }
}
class a3 extends be {
  constructor(t) {
    var n, r;
    super(
      `maxPriorityFeePerGas: ${
        (n = t.maxPriorityFeePerGas) !== null && n !== void 0 ? n : "undefined"
      }, maxFeePerGas: ${
        (r = t.maxFeePerGas) !== null && r !== void 0 ? r : "undefined"
      }`,
      "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas"
    ),
      (this.code = cF);
  }
}
class Yj extends be {
  constructor(t) {
    super(t, "invalid transaction object"), (this.code = lF);
  }
}
class Xj extends be {
  constructor(t) {
    var n, r;
    super(
      `nonce: ${
        (n = t.nonce) !== null && n !== void 0 ? n : "undefined"
      }, chainId: ${
        (r = t.chainId) !== null && r !== void 0 ? r : "undefined"
      }`,
      "Nonce or chainId is lower than 0"
    ),
      (this.code = dF);
  }
}
class eU extends be {
  constructor() {
    super(
      "UnableToPopulateNonceError",
      "unable to populate nonce, no from address available"
    ),
      (this.code = fF);
  }
}
class tU extends be {
  constructor() {
    super("Eip1559NotSupportedError", "Network doesn't support eip-1559"),
      (this.code = hF);
  }
}
class b_ extends be {
  constructor(t) {
    super(t, "unsupported transaction type"), (this.code = pF);
  }
}
class u3 extends be {
  constructor(t) {
    var n, r;
    super(
      `data: ${
        (n = t.data) !== null && n !== void 0 ? n : "undefined"
      }, input: ${(r = t.input) !== null && r !== void 0 ? r : "undefined"}`,
      `You can't have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.`
    ),
      (this.code = mF);
  }
}
class nU extends ue {
  constructor(t) {
    super(`The connected Ethereum Node did not respond within ${
      t.numberOfSeconds
    } seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!
	Transaction Hash: ${
    t.transactionHash ? t.transactionHash.toString() : "not available"
  }`),
      (this.code = EF);
  }
}
function c3(e) {
  return `Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!
	Transaction Hash: ${e ? e.toString() : "not available"}`;
}
class rU extends ue {
  constructor(t) {
    super(
      `Transaction was not mined within ${t.numberOfSeconds} seconds. ${c3(
        t.transactionHash
      )}`
    ),
      (this.code = yF);
  }
}
class l3 extends ue {
  constructor(t) {
    super(
      `Transaction started at ${
        t.starterBlockNumber
      } but was not mined within ${t.numberOfBlocks} blocks. ${c3(
        t.transactionHash
      )}`
    ),
      (this.code = _F);
  }
}
class iU extends be {
  constructor(t) {
    var n, r;
    super(
      `receipt: ${JSON.stringify(t.receipt)}, blockHash: ${
        (n = t.blockHash) === null || n === void 0 ? void 0 : n.toString()
      }, transactionHash: ${
        (r = t.transactionHash) === null || r === void 0 ? void 0 : r.toString()
      }`,
      "Receipt missing or blockHash null"
    ),
      (this.code = gF);
  }
}
class sU extends be {
  constructor(t) {
    super(
      `receipt: ${JSON.stringify(t.receipt)}`,
      "Receipt missing block number"
    ),
      (this.code = vF);
  }
}
class tg extends ue {
  constructor(t) {
    super(`Invalid signature. "${t}"`), (this.code = AF);
  }
}
class w_ extends be {
  constructor() {
    super(
      "LocalWalletNotAvailableError",
      "Attempted to index account in local wallet, but no wallet is available"
    ),
      (this.code = bF);
  }
}
class oU extends ue {
  constructor(t, n) {
    const r = [];
    t.forEach((i) => r.push(i.keyword)),
      super(
        `The following properties are invalid for the transaction type ${n}: ${r.join(
          ", "
        )}`
      ),
      (this.code = kF);
  }
}
class Uu extends be {
  constructor(t) {
    super(t, "can not parse as byte data"), (this.code = sj);
  }
}
class Ib extends be {
  constructor(t) {
    super(t, "can not parse as number data"), (this.code = oj);
  }
}
class kb extends be {
  constructor(t) {
    super(t, "invalid ethereum address"), (this.code = uj);
  }
}
class aU extends be {
  constructor(t) {
    super(t, "not a valid string"), (this.code = ij);
  }
}
class d3 extends be {
  constructor(t) {
    super(t, "invalid unit"), (this.code = aj);
  }
}
class uU extends be {
  constructor(t) {
    super(t, "can not be converted to hex"), (this.code = cj);
  }
}
class f3 extends be {
  constructor(t) {
    super(t, "value greater than the nibble width"), (this.code = mj);
  }
}
class Pb extends be {
  constructor(t) {
    super(t, "not a valid boolean."), (this.code = lj);
  }
}
class cU extends be {
  constructor(t) {
    super(t, "not a valid unsigned integer."), (this.code = dj);
  }
}
class E_ extends be {
  constructor(t) {
    super(t, "invalid size given."), (this.code = fj);
  }
}
class __ extends be {
  constructor(t) {
    super(t, "value is larger than size."), (this.code = hj);
  }
}
class lU extends be {
  constructor(t) {
    super(t, "invalid string given"), (this.code = pj);
  }
}
const dU = (e) =>
    !Array.isArray(e) &&
    e.jsonrpc === "2.0" &&
    !!e &&
    (e.result === void 0 || e.result === null) &&
    "error" in e &&
    (typeof e.id == "number" || typeof e.id == "string"),
  A_ = (e) => (dU(e) ? e.error.message : "");
class Kr extends ue {
  constructor(t, n, r) {
    var i;
    super(
      n ??
        `Returned error: ${
          Array.isArray(t) ? t.map((o) => A_(o)).join(",") : A_(t)
        }`
    ),
      (this.code = ML),
      n ||
        (this.data = Array.isArray(t)
          ? t.map((o) => {
              var a;
              return (a = o.error) === null || a === void 0 ? void 0 : a.data;
            })
          : (i = t == null ? void 0 : t.error) === null || i === void 0
          ? void 0
          : i.data),
      (this.request = r);
    let s;
    "error" in t
      ? (s = t.error)
      : t instanceof Array && (s = t.map((o) => o.error)),
      (this.innerError = s);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      data: this.data,
      request: this.request,
    });
  }
}
class Ic extends Kr {
  constructor(t, n) {
    super(t, void 0, n), (this.code = LL);
    let r;
    "error" in t
      ? (r = t.error)
      : t instanceof Array && (r = t.map((i) => i.error)),
      (this.innerError = r);
  }
}
class x_ extends ue {
  constructor(t, n) {
    super(
      `Web3Config hardfork doesnt match in defaultHardfork ${t} and common.hardfork ${n}`
    ),
      (this.code = n3);
  }
}
class S_ extends ue {
  constructor(t, n) {
    super(
      `Web3Config chain doesnt match in defaultHardfork ${t} and common.hardfork ${n}`
    ),
      (this.code = n3);
  }
}
const h3 = "An Rpc error has occured with a code of *code*",
  Kt = {
    [Tf]: { message: "Parse error", description: "Invalid JSON" },
    [If]: {
      message: "Invalid request",
      description: "JSON is not a valid request object	",
    },
    [kf]: { message: "Method not found", description: "Method does not exist	" },
    [Pf]: {
      message: "Invalid params",
      description: "Invalid method parameters",
    },
    [Df]: { message: "Internal error", description: "Internal JSON-RPC error" },
    [Of]: {
      message: "Invalid input",
      description: "Missing or invalid parameters",
    },
    [Rf]: {
      message: "Resource not found",
      description: "Requested resource not found",
    },
    [Bf]: {
      message: "Resource unavailable",
      description: "Requested resource not available",
    },
    [Nf]: {
      message: "Transaction rejected",
      description: "Transaction creation failed",
    },
    [Mf]: {
      message: "Method not supported",
      description: "Method is not implemented",
    },
    [Lf]: {
      message: "Limit exceeded",
      description: "Request exceeds defined limit",
    },
    [Ff]: {
      message: "JSON-RPC version not supported",
      description: "Version of JSON-RPC protocol is not supported",
    },
    [JF]: {
      name: "User Rejected Request",
      message: "The user rejected the request.",
    },
    [YF]: {
      name: "Unauthorized",
      message:
        "The requested method and/or account has not been authorized by the user.",
    },
    [XF]: {
      name: "Unsupported Method",
      message: "The Provider does not support the requested method.",
    },
    [ej]: {
      name: "Disconnected",
      message: "The Provider is disconnected from all chains.",
    },
    [tj]: {
      name: "Chain Disconnected",
      message: "The Provider is not connected to the requested chain.",
    },
    "0-999": { name: "", message: "Not used." },
    1e3: {
      name: "Normal Closure",
      message:
        "The connection successfully completed the purpose for which it was created.",
    },
    1001: {
      name: "Going Away",
      message:
        "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.",
    },
    1002: {
      name: "Protocol error",
      message:
        "The endpoint is terminating the connection due to a protocol error.",
    },
    1003: {
      name: "Unsupported Data",
      message:
        "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)",
    },
    1004: {
      name: "Reserved",
      message: "Reserved. A meaning might be defined in the future.",
    },
    1005: {
      name: "No Status Rcvd",
      message:
        "Reserved. Indicates that no status code was provided even though one was expected.",
    },
    1006: {
      name: "Abnormal Closure",
      message:
        "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected.",
    },
    1007: {
      name: "Invalid frame payload data",
      message:
        "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).",
    },
    1008: {
      name: "Policy Violation",
      message:
        "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable.",
    },
    1009: {
      name: "Message Too Big",
      message:
        "The endpoint is terminating the connection because a data frame was received that is too large.",
    },
    1010: {
      name: "Mandatory Ext.",
      message:
        "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't.",
    },
    1011: {
      name: "Internal Error",
      message:
        "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request.",
    },
    1012: {
      name: "Service Restart",
      message:
        "The server is terminating the connection because it is restarting.",
    },
    1013: {
      name: "Try Again Later",
      message:
        "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.",
    },
    1014: {
      name: "Bad Gateway",
      message:
        "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code.",
    },
    1015: {
      name: "TLS handshake",
      message:
        "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified).",
    },
    "1016-2999": {
      name: "",
      message:
        "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications.",
    },
    "3000-3999": {
      name: "",
      message:
        "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol.",
    },
    "4000-4999": {
      name: "",
      message:
        "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol.",
    },
  };
class Nn extends ue {
  constructor(t, n) {
    super(n ?? h3.replace("*code*", t.error.code.toString())),
      (this.code = t.error.code),
      (this.id = t.id),
      (this.jsonrpc = t.jsonrpc),
      (this.jsonRpcError = t.error);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      error: this.jsonRpcError,
      id: this.id,
      jsonRpc: this.jsonrpc,
    });
  }
}
class fU extends ue {
  constructor(t, n) {
    var r, i, s, o;
    if (!t) super();
    else if (!((r = Kt[t]) === null || r === void 0) && r.message)
      super(Kt[t].message);
    else {
      const a = Object.keys(Kt).find(
        (u) =>
          typeof u == "string" &&
          t >= parseInt(u.split("-")[0], 10) &&
          t <= parseInt(u.split("-")[1], 10)
      );
      super(
        (s =
          (i = Kt[a ?? ""]) === null || i === void 0 ? void 0 : i.message) !==
          null && s !== void 0
          ? s
          : h3.replace(
              "*code*",
              (o = t == null ? void 0 : t.toString()) !== null && o !== void 0
                ? o
                : '""'
            )
      );
    }
    (this.code = t), (this.data = n);
  }
}
class hU extends Nn {
  constructor(t) {
    super(t, Kt[Tf].message), (this.code = Tf);
  }
}
class pU extends Nn {
  constructor(t) {
    super(t, Kt[If].message), (this.code = If);
  }
}
class mU extends Nn {
  constructor(t) {
    super(t, Kt[kf].message), (this.code = kf);
  }
}
class yU extends Nn {
  constructor(t) {
    super(t, Kt[Pf].message), (this.code = Pf);
  }
}
class gU extends Nn {
  constructor(t) {
    super(t, Kt[Df].message), (this.code = Df);
  }
}
class vU extends Nn {
  constructor(t) {
    super(t, Kt[Of].message), (this.code = Of);
  }
}
class bU extends Nn {
  constructor(t) {
    super(t, Kt[Mf].message), (this.code = Mf);
  }
}
class wU extends Nn {
  constructor(t) {
    super(t, Kt[Bf].message), (this.code = Bf);
  }
}
class EU extends Nn {
  constructor(t) {
    super(t, Kt[Rf].message), (this.code = Rf);
  }
}
class _U extends Nn {
  constructor(t) {
    super(t, Kt[Ff].message), (this.code = Ff);
  }
}
class AU extends Nn {
  constructor(t) {
    super(t, Kt[Nf].message), (this.code = Nf);
  }
}
class xU extends Nn {
  constructor(t) {
    super(t, Kt[Lf].message), (this.code = Lf);
  }
}
const sn = new Map();
sn.set(Tf, { error: hU });
sn.set(If, { error: pU });
sn.set(kf, { error: mU });
sn.set(Pf, { error: yU });
sn.set(Df, { error: gU });
sn.set(Of, { error: vU });
sn.set(Mf, { error: bU });
sn.set(Bf, { error: wU });
sn.set(Nf, { error: AU });
sn.set(Rf, { error: EU });
sn.set(Ff, { error: _U });
sn.set(Lf, { error: xU });
class SU extends ue {
  constructor(t) {
    super(`Format for the type ${t} is unsupported`),
      (this.type = t),
      (this.code = gj);
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), {
      type: this.type,
    });
  }
}
function ng(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Wrong positive integer: ${e}`);
}
function CU(e) {
  if (typeof e != "boolean") throw new Error(`Expected boolean, not ${e}`);
}
function p3(e, ...t) {
  if (!(e instanceof Uint8Array)) throw new Error("Expected Uint8Array");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(
      `Expected Uint8Array of length ${t}, not of length=${e.length}`
    );
}
function TU(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  ng(e.outputLen), ng(e.blockLen);
}
function IU(e, t = !0) {
  if (e.destroyed) throw new Error("Hash instance has been destroyed");
  if (t && e.finished) throw new Error("Hash#digest() has already been called");
}
function kU(e, t) {
  p3(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(
      `digestInto() expects output buffer of length at least ${n}`
    );
}
const qe = {
    number: ng,
    bool: CU,
    bytes: p3,
    hash: TU,
    exists: IU,
    output: kU,
  },
  ed = BigInt(2 ** 32 - 1),
  rg = BigInt(32);
function m3(e, t = !1) {
  return t
    ? { h: Number(e & ed), l: Number((e >> rg) & ed) }
    : { h: Number((e >> rg) & ed) | 0, l: Number(e & ed) | 0 };
}
function PU(e, t = !1) {
  let n = new Uint32Array(e.length),
    r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = m3(e[i], t);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const DU = (e, t) => (BigInt(e >>> 0) << rg) | BigInt(t >>> 0),
  OU = (e, t, n) => e >>> n,
  RU = (e, t, n) => (e << (32 - n)) | (t >>> n),
  BU = (e, t, n) => (e >>> n) | (t << (32 - n)),
  NU = (e, t, n) => (e << (32 - n)) | (t >>> n),
  MU = (e, t, n) => (e << (64 - n)) | (t >>> (n - 32)),
  LU = (e, t, n) => (e >>> (n - 32)) | (t << (64 - n)),
  FU = (e, t) => t,
  jU = (e, t) => e,
  UU = (e, t, n) => (e << n) | (t >>> (32 - n)),
  $U = (e, t, n) => (t << n) | (e >>> (32 - n)),
  HU = (e, t, n) => (t << (n - 32)) | (e >>> (64 - n)),
  zU = (e, t, n) => (e << (n - 32)) | (t >>> (64 - n));
function GU(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: (e + n + ((i / 2 ** 32) | 0)) | 0, l: i | 0 };
}
const qU = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0),
  WU = (e, t, n, r) => (t + n + r + ((e / 2 ** 32) | 0)) | 0,
  QU = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0),
  VU = (e, t, n, r, i) => (t + n + r + i + ((e / 2 ** 32) | 0)) | 0,
  KU = (e, t, n, r, i) =>
    (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0),
  ZU = (e, t, n, r, i, s) => (t + n + r + i + s + ((e / 2 ** 32) | 0)) | 0,
  oe = {
    fromBig: m3,
    split: PU,
    toBig: DU,
    shrSH: OU,
    shrSL: RU,
    rotrSH: BU,
    rotrSL: NU,
    rotrBH: MU,
    rotrBL: LU,
    rotr32H: FU,
    rotr32L: jU,
    rotlSH: UU,
    rotlSL: $U,
    rotlBH: HU,
    rotlBL: zU,
    add: GU,
    add3L: qU,
    add3H: WU,
    add4L: QU,
    add4H: VU,
    add5H: ZU,
    add5L: KU,
  },
  Td =
    typeof globalThis == "object" && "crypto" in globalThis
      ? globalThis.crypto
      : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const y3 =
    (e) => e instanceof Uint8Array,
  Id = (e) =>
    new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)),
  kd = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength),
  Er = (e, t) => (e << (32 - t)) | (e >>> t),
  JU = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!JU) throw new Error("Non little-endian hardware is not supported");
Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function wa(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function no(e) {
  if ((typeof e == "string" && (e = wa(e)), !y3(e)))
    throw new Error(`expected Uint8Array, got ${typeof e}`);
  return e;
}
function Uf(...e) {
  const t = new Uint8Array(e.reduce((r, i) => r + i.length, 0));
  let n = 0;
  return (
    e.forEach((r) => {
      if (!y3(r)) throw new Error("Uint8Array expected");
      t.set(r, n), (n += r.length);
    }),
    t
  );
}
class Db {
  clone() {
    return this._cloneInto();
  }
}
const YU = (e) =>
  Object.prototype.toString.call(e) === "[object Object]" &&
  e.constructor === Object;
function g3(e, t) {
  if (t !== void 0 && (typeof t != "object" || !YU(t)))
    throw new Error("Options should be object or undefined");
  return Object.assign(e, t);
}
function yo(e) {
  const t = (r) => e().update(no(r)).digest(),
    n = e();
  return (
    (t.outputLen = n.outputLen),
    (t.blockLen = n.blockLen),
    (t.create = () => e()),
    t
  );
}
function XU(e) {
  const t = (r, i) => e(i).update(no(r)).digest(),
    n = e({});
  return (
    (t.outputLen = n.outputLen),
    (t.blockLen = n.blockLen),
    (t.create = (r) => e(r)),
    t
  );
}
function v3(e = 32) {
  if (Td && typeof Td.getRandomValues == "function")
    return Td.getRandomValues(new Uint8Array(e));
  throw new Error("crypto.getRandomValues must be defined");
}
const [b3, w3, E3] = [[], [], []],
  e9 = BigInt(0),
  cu = BigInt(1),
  t9 = BigInt(2),
  n9 = BigInt(7),
  r9 = BigInt(256),
  i9 = BigInt(113);
for (let e = 0, t = cu, n = 1, r = 0; e < 24; e++) {
  ([n, r] = [r, (2 * n + 3 * r) % 5]),
    b3.push(2 * (5 * r + n)),
    w3.push((((e + 1) * (e + 2)) / 2) % 64);
  let i = e9;
  for (let s = 0; s < 7; s++)
    (t = ((t << cu) ^ ((t >> n9) * i9)) % r9),
      t & t9 && (i ^= cu << ((cu << BigInt(s)) - cu));
  E3.push(i);
}
const [s9, o9] = oe.split(E3, !0),
  C_ = (e, t, n) => (n > 32 ? oe.rotlBH(e, t, n) : oe.rotlSH(e, t, n)),
  T_ = (e, t, n) => (n > 32 ? oe.rotlBL(e, t, n) : oe.rotlSL(e, t, n));
function a9(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      n[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const a = (o + 8) % 10,
        u = (o + 2) % 10,
        l = n[u],
        c = n[u + 1],
        d = C_(l, c, 1) ^ n[a],
        f = T_(l, c, 1) ^ n[a + 1];
      for (let p = 0; p < 50; p += 10) (e[o + p] ^= d), (e[o + p + 1] ^= f);
    }
    let i = e[2],
      s = e[3];
    for (let o = 0; o < 24; o++) {
      const a = w3[o],
        u = C_(i, s, a),
        l = T_(i, s, a),
        c = b3[o];
      (i = e[c]), (s = e[c + 1]), (e[c] = u), (e[c + 1] = l);
    }
    for (let o = 0; o < 50; o += 10) {
      for (let a = 0; a < 10; a++) n[a] = e[o + a];
      for (let a = 0; a < 10; a++)
        e[o + a] ^= ~n[(a + 2) % 10] & n[(a + 4) % 10];
    }
    (e[0] ^= s9[r]), (e[1] ^= o9[r]);
  }
  n.fill(0);
}
class cp extends Db {
  constructor(t, n, r, i = !1, s = 24) {
    if (
      (super(),
      (this.blockLen = t),
      (this.suffix = n),
      (this.outputLen = r),
      (this.enableXOF = i),
      (this.rounds = s),
      (this.pos = 0),
      (this.posOut = 0),
      (this.finished = !1),
      (this.destroyed = !1),
      qe.number(r),
      0 >= this.blockLen || this.blockLen >= 200)
    )
      throw new Error("Sha3 supports only keccak-f1600 function");
    (this.state = new Uint8Array(200)), (this.state32 = Id(this.state));
  }
  keccak() {
    a9(this.state32, this.rounds), (this.posOut = 0), (this.pos = 0);
  }
  update(t) {
    qe.exists(this);
    const { blockLen: n, state: r } = this;
    t = no(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let a = 0; a < o; a++) r[this.pos++] ^= t[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    (t[r] ^= n),
      n & 128 && r === i - 1 && this.keccak(),
      (t[i - 1] ^= 128),
      this.keccak();
  }
  writeInto(t) {
    qe.exists(this, !1), qe.bytes(t), this.finish();
    const n = this.state,
      { blockLen: r } = this;
    for (let i = 0, s = t.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      t.set(n.subarray(this.posOut, this.posOut + o), i),
        (this.posOut += o),
        (i += o);
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return qe.number(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if ((qe.output(t, this), this.finished))
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    (this.destroyed = !0), this.state.fill(0);
  }
  _cloneInto(t) {
    const {
      blockLen: n,
      suffix: r,
      outputLen: i,
      rounds: s,
      enableXOF: o,
    } = this;
    return (
      t || (t = new cp(n, r, i, o, s)),
      t.state32.set(this.state32),
      (t.pos = this.pos),
      (t.posOut = this.posOut),
      (t.finished = this.finished),
      (t.rounds = s),
      (t.suffix = r),
      (t.outputLen = i),
      (t.enableXOF = o),
      (t.destroyed = this.destroyed),
      t
    );
  }
}
const gs = (e, t, n) => yo(() => new cp(t, e, n));
gs(6, 144, 224 / 8);
gs(6, 136, 256 / 8);
gs(6, 104, 384 / 8);
gs(6, 72, 512 / 8);
gs(1, 144, 224 / 8);
const I_ = gs(1, 136, 256 / 8);
gs(1, 104, 384 / 8);
gs(1, 72, 512 / 8);
const _3 = (e, t, n) =>
  XU((r = {}) => new cp(t, e, r.dkLen === void 0 ? n : r.dkLen, !0));
_3(31, 168, 128 / 8);
_3(31, 136, 256 / 8);
const $f = qe.bytes;
function A3(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof e}`);
  return new TextDecoder().decode(e);
}
function u9(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function c9(e) {
  return (t) => (qe.bytes(t), e(t));
}
(() => {
  const e =
      typeof globalThis == "object" && "crypto" in globalThis
        ? globalThis.crypto
        : void 0,
    t =
      typeof module < "u" &&
      typeof module.require == "function" &&
      module.require.bind(module);
  return { node: t && !e ? t("crypto") : void 0, web: e };
})();
const Zt = (() => {
  const e = c9(I_);
  return (e.create = I_.create), e;
})();
var Pe;
(function (e) {
  e.assertEqual = (i) => i;
  function t(i) {}
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  (e.assertNever = n),
    (e.arrayToEnum = (i) => {
      const s = {};
      for (const o of i) s[o] = o;
      return s;
    }),
    (e.getValidEnumValues = (i) => {
      const s = e.objectKeys(i).filter((a) => typeof i[i[a]] != "number"),
        o = {};
      for (const a of s) o[a] = i[a];
      return e.objectValues(o);
    }),
    (e.objectValues = (i) =>
      e.objectKeys(i).map(function (s) {
        return i[s];
      })),
    (e.objectKeys =
      typeof Object.keys == "function"
        ? (i) => Object.keys(i)
        : (i) => {
            const s = [];
            for (const o in i)
              Object.prototype.hasOwnProperty.call(i, o) && s.push(o);
            return s;
          }),
    (e.find = (i, s) => {
      for (const o of i) if (s(o)) return o;
    }),
    (e.isInteger =
      typeof Number.isInteger == "function"
        ? (i) => Number.isInteger(i)
        : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i);
  function r(i, s = " | ") {
    return i.map((o) => (typeof o == "string" ? `'${o}'` : o)).join(s);
  }
  (e.joinValues = r),
    (e.jsonStringifyReplacer = (i, s) =>
      typeof s == "bigint" ? s.toString() : s);
})(Pe || (Pe = {}));
var ig;
(function (e) {
  e.mergeShapes = (t, n) => ({ ...t, ...n });
})(ig || (ig = {}));
const V = Pe.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  Li = (e) => {
    switch (typeof e) {
      case "undefined":
        return V.undefined;
      case "string":
        return V.string;
      case "number":
        return isNaN(e) ? V.nan : V.number;
      case "boolean":
        return V.boolean;
      case "function":
        return V.function;
      case "bigint":
        return V.bigint;
      case "symbol":
        return V.symbol;
      case "object":
        return Array.isArray(e)
          ? V.array
          : e === null
          ? V.null
          : e.then &&
            typeof e.then == "function" &&
            e.catch &&
            typeof e.catch == "function"
          ? V.promise
          : typeof Map < "u" && e instanceof Map
          ? V.map
          : typeof Set < "u" && e instanceof Set
          ? V.set
          : typeof Date < "u" && e instanceof Date
          ? V.date
          : V.object;
      default:
        return V.unknown;
    }
  },
  H = Pe.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  l9 = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class dr extends Error {
  constructor(t) {
    super(),
      (this.issues = []),
      (this.addIssue = (r) => {
        this.issues = [...this.issues, r];
      }),
      (this.addIssues = (r = []) => {
        this.issues = [...this.issues, ...r];
      });
    const n = new.target.prototype;
    Object.setPrototypeOf
      ? Object.setPrototypeOf(this, n)
      : (this.__proto__ = n),
      (this.name = "ZodError"),
      (this.issues = t);
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n =
        t ||
        function (s) {
          return s.message;
        },
      r = { _errors: [] },
      i = (s) => {
        for (const o of s.issues)
          if (o.code === "invalid_union") o.unionErrors.map(i);
          else if (o.code === "invalid_return_type") i(o.returnTypeError);
          else if (o.code === "invalid_arguments") i(o.argumentsError);
          else if (o.path.length === 0) r._errors.push(n(o));
          else {
            let a = r,
              u = 0;
            for (; u < o.path.length; ) {
              const l = o.path[u];
              u === o.path.length - 1
                ? ((a[l] = a[l] || { _errors: [] }), a[l]._errors.push(n(o)))
                : (a[l] = a[l] || { _errors: [] }),
                (a = a[l]),
                u++;
            }
          }
      };
    return i(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Pe.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {},
      r = [];
    for (const i of this.issues)
      i.path.length > 0
        ? ((n[i.path[0]] = n[i.path[0]] || []), n[i.path[0]].push(t(i)))
        : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
dr.create = (e) => new dr(e);
const kc = (e, t) => {
  let n;
  switch (e.code) {
    case H.invalid_type:
      e.received === V.undefined
        ? (n = "Required")
        : (n = `Expected ${e.expected}, received ${e.received}`);
      break;
    case H.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(
        e.expected,
        Pe.jsonStringifyReplacer
      )}`;
      break;
    case H.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Pe.joinValues(e.keys, ", ")}`;
      break;
    case H.invalid_union:
      n = "Invalid input";
      break;
    case H.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Pe.joinValues(e.options)}`;
      break;
    case H.invalid_enum_value:
      n = `Invalid enum value. Expected ${Pe.joinValues(
        e.options
      )}, received '${e.received}'`;
      break;
    case H.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case H.invalid_return_type:
      n = "Invalid function return type";
      break;
    case H.invalid_date:
      n = "Invalid date";
      break;
    case H.invalid_string:
      typeof e.validation == "object"
        ? "includes" in e.validation
          ? ((n = `Invalid input: must include "${e.validation.includes}"`),
            typeof e.validation.position == "number" &&
              (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`))
          : "startsWith" in e.validation
          ? (n = `Invalid input: must start with "${e.validation.startsWith}"`)
          : "endsWith" in e.validation
          ? (n = `Invalid input: must end with "${e.validation.endsWith}"`)
          : Pe.assertNever(e.validation)
        : e.validation !== "regex"
        ? (n = `Invalid ${e.validation}`)
        : (n = "Invalid");
      break;
    case H.too_small:
      e.type === "array"
        ? (n = `Array must contain ${
            e.exact ? "exactly" : e.inclusive ? "at least" : "more than"
          } ${e.minimum} element(s)`)
        : e.type === "string"
        ? (n = `String must contain ${
            e.exact ? "exactly" : e.inclusive ? "at least" : "over"
          } ${e.minimum} character(s)`)
        : e.type === "number"
        ? (n = `Number must be ${
            e.exact
              ? "exactly equal to "
              : e.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${e.minimum}`)
        : e.type === "date"
        ? (n = `Date must be ${
            e.exact
              ? "exactly equal to "
              : e.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${new Date(Number(e.minimum))}`)
        : (n = "Invalid input");
      break;
    case H.too_big:
      e.type === "array"
        ? (n = `Array must contain ${
            e.exact ? "exactly" : e.inclusive ? "at most" : "less than"
          } ${e.maximum} element(s)`)
        : e.type === "string"
        ? (n = `String must contain ${
            e.exact ? "exactly" : e.inclusive ? "at most" : "under"
          } ${e.maximum} character(s)`)
        : e.type === "number"
        ? (n = `Number must be ${
            e.exact
              ? "exactly"
              : e.inclusive
              ? "less than or equal to"
              : "less than"
          } ${e.maximum}`)
        : e.type === "bigint"
        ? (n = `BigInt must be ${
            e.exact
              ? "exactly"
              : e.inclusive
              ? "less than or equal to"
              : "less than"
          } ${e.maximum}`)
        : e.type === "date"
        ? (n = `Date must be ${
            e.exact
              ? "exactly"
              : e.inclusive
              ? "smaller than or equal to"
              : "smaller than"
          } ${new Date(Number(e.maximum))}`)
        : (n = "Invalid input");
      break;
    case H.custom:
      n = "Invalid input";
      break;
    case H.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case H.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case H.not_finite:
      n = "Number must be finite";
      break;
    default:
      (n = t.defaultError), Pe.assertNever(e);
  }
  return { message: n };
};
let x3 = kc;
function d9(e) {
  x3 = e;
}
function Hf() {
  return x3;
}
const zf = (e) => {
    const { data: t, path: n, errorMaps: r, issueData: i } = e,
      s = [...n, ...(i.path || [])],
      o = { ...i, path: s };
    let a = "";
    const u = r
      .filter((l) => !!l)
      .slice()
      .reverse();
    for (const l of u) a = l(o, { data: t, defaultError: a }).message;
    return { ...i, path: s, message: i.message || a };
  },
  f9 = [];
function K(e, t) {
  const n = zf({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, Hf(), kc].filter(
      (r) => !!r
    ),
  });
  e.common.issues.push(n);
}
class Xt {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted") return le;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n) r.push({ key: await i.key, value: await i.value });
    return Xt.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: s, value: o } = i;
      if (s.status === "aborted" || o.status === "aborted") return le;
      s.status === "dirty" && t.dirty(),
        o.status === "dirty" && t.dirty(),
        s.value !== "__proto__" &&
          (typeof o.value < "u" || i.alwaysSet) &&
          (r[s.value] = o.value);
    }
    return { status: t.value, value: r };
  }
}
const le = Object.freeze({ status: "aborted" }),
  S3 = (e) => ({ status: "dirty", value: e }),
  on = (e) => ({ status: "valid", value: e }),
  sg = (e) => e.status === "aborted",
  og = (e) => e.status === "dirty",
  Pc = (e) => e.status === "valid",
  Gf = (e) => typeof Promise < "u" && e instanceof Promise;
var te;
(function (e) {
  (e.errToObj = (t) => (typeof t == "string" ? { message: t } : t || {})),
    (e.toString = (t) =>
      typeof t == "string" ? t : t == null ? void 0 : t.message);
})(te || (te = {}));
class Rr {
  constructor(t, n, r, i) {
    (this._cachedPath = []),
      (this.parent = t),
      (this.data = n),
      (this._path = r),
      (this._key = i);
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    );
  }
}
const k_ = (e, t) => {
  if (Pc(t)) return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error) return this._error;
      const n = new dr(e.common.issues);
      return (this._error = n), this._error;
    },
  };
};
function fe(e) {
  if (!e) return {};
  const {
    errorMap: t,
    invalid_type_error: n,
    required_error: r,
    description: i,
  } = e;
  if (t && (n || r))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  return t
    ? { errorMap: t, description: i }
    : {
        errorMap: (o, a) =>
          o.code !== "invalid_type"
            ? { message: a.defaultError }
            : typeof a.data > "u"
            ? { message: r ?? a.defaultError }
            : { message: n ?? a.defaultError },
        description: i,
      };
}
class ye {
  constructor(t) {
    (this.spa = this.safeParseAsync),
      (this._def = t),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this));
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Li(t.data);
  }
  _getOrReturnCtx(t, n) {
    return (
      n || {
        common: t.parent.common,
        data: t.data,
        parsedType: Li(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent,
      }
    );
  }
  _processInputParams(t) {
    return {
      status: new Xt(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Li(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent,
      },
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Gf(n)) throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success) return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
        common: {
          issues: [],
          async:
            (r = n == null ? void 0 : n.async) !== null && r !== void 0
              ? r
              : !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: Li(t),
      },
      s = this._parseSync({ data: t, path: i.path, parent: i });
    return k_(i, s);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success) return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
        common: {
          issues: [],
          contextualErrorMap: n == null ? void 0 : n.errorMap,
          async: !0,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: t,
        parsedType: Li(t),
      },
      i = this._parse({ data: t, path: r.path, parent: r }),
      s = await (Gf(i) ? i : Promise.resolve(i));
    return k_(r, s);
  }
  refine(t, n) {
    const r = (i) =>
      typeof n == "string" || typeof n > "u"
        ? { message: n }
        : typeof n == "function"
        ? n(i)
        : n;
    return this._refinement((i, s) => {
      const o = t(i),
        a = () => s.addIssue({ code: H.custom, ...r(i) });
      return typeof Promise < "u" && o instanceof Promise
        ? o.then((u) => (u ? !0 : (a(), !1)))
        : o
        ? !0
        : (a(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) =>
      t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1)
    );
  }
  _refinement(t) {
    return new mr({
      schema: this,
      typeName: re.ZodEffects,
      effect: { type: "refinement", refinement: t },
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return si.create(this, this._def);
  }
  nullable() {
    return so.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return fr.create(this, this._def);
  }
  promise() {
    return _a.create(this, this._def);
  }
  or(t) {
    return Bc.create([this, t], this._def);
  }
  and(t) {
    return Nc.create(this, t, this._def);
  }
  transform(t) {
    return new mr({
      ...fe(this._def),
      schema: this,
      typeName: re.ZodEffects,
      effect: { type: "transform", transform: t },
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Uc({
      ...fe(this._def),
      innerType: this,
      defaultValue: n,
      typeName: re.ZodDefault,
    });
  }
  brand() {
    return new T3({ typeName: re.ZodBranded, type: this, ...fe(this._def) });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Vf({
      ...fe(this._def),
      innerType: this,
      catchValue: n,
      typeName: re.ZodCatch,
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({ ...this._def, description: t });
  }
  pipe(t) {
    return gl.create(this, t);
  }
  readonly() {
    return Zf.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const h9 = /^c[^\s-]{8,}$/i,
  p9 = /^[a-z][a-z0-9]*$/,
  m9 = /^[0-9A-HJKMNP-TV-Z]{26}$/,
  y9 =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  g9 =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  v9 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let jm;
const b9 =
    /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/,
  w9 =
    /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  E9 = (e) =>
    e.precision
      ? e.offset
        ? new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
          )
        : new RegExp(
            `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`
          )
      : e.precision === 0
      ? e.offset
        ? new RegExp(
            "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$"
          )
        : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$")
      : e.offset
      ? new RegExp(
          "^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$"
        )
      : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function _9(e, t) {
  return !!(
    ((t === "v4" || !t) && b9.test(e)) ||
    ((t === "v6" || !t) && w9.test(e))
  );
}
class ur extends ye {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = String(t.data)),
      this._getType(t) !== V.string)
    ) {
      const s = this._getOrReturnCtx(t);
      return (
        K(s, {
          code: H.invalid_type,
          expected: V.string,
          received: s.parsedType,
        }),
        le
      );
    }
    const r = new Xt();
    let i;
    for (const s of this._def.checks)
      if (s.kind === "min")
        t.data.length < s.value &&
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            code: H.too_small,
            minimum: s.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "max")
        t.data.length > s.value &&
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            code: H.too_big,
            maximum: s.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "length") {
        const o = t.data.length > s.value,
          a = t.data.length < s.value;
        (o || a) &&
          ((i = this._getOrReturnCtx(t, i)),
          o
            ? K(i, {
                code: H.too_big,
                maximum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message,
              })
            : a &&
              K(i, {
                code: H.too_small,
                minimum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message,
              }),
          r.dirty());
      } else if (s.kind === "email")
        g9.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            validation: "email",
            code: H.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "emoji")
        jm || (jm = new RegExp(v9, "u")),
          jm.test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            K(i, {
              validation: "emoji",
              code: H.invalid_string,
              message: s.message,
            }),
            r.dirty());
      else if (s.kind === "uuid")
        y9.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            validation: "uuid",
            code: H.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "cuid")
        h9.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            validation: "cuid",
            code: H.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "cuid2")
        p9.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            validation: "cuid2",
            code: H.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "ulid")
        m9.test(t.data) ||
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            validation: "ulid",
            code: H.invalid_string,
            message: s.message,
          }),
          r.dirty());
      else if (s.kind === "url")
        try {
          new URL(t.data);
        } catch {
          (i = this._getOrReturnCtx(t, i)),
            K(i, {
              validation: "url",
              code: H.invalid_string,
              message: s.message,
            }),
            r.dirty();
        }
      else
        s.kind === "regex"
          ? ((s.regex.lastIndex = 0),
            s.regex.test(t.data) ||
              ((i = this._getOrReturnCtx(t, i)),
              K(i, {
                validation: "regex",
                code: H.invalid_string,
                message: s.message,
              }),
              r.dirty()))
          : s.kind === "trim"
          ? (t.data = t.data.trim())
          : s.kind === "includes"
          ? t.data.includes(s.value, s.position) ||
            ((i = this._getOrReturnCtx(t, i)),
            K(i, {
              code: H.invalid_string,
              validation: { includes: s.value, position: s.position },
              message: s.message,
            }),
            r.dirty())
          : s.kind === "toLowerCase"
          ? (t.data = t.data.toLowerCase())
          : s.kind === "toUpperCase"
          ? (t.data = t.data.toUpperCase())
          : s.kind === "startsWith"
          ? t.data.startsWith(s.value) ||
            ((i = this._getOrReturnCtx(t, i)),
            K(i, {
              code: H.invalid_string,
              validation: { startsWith: s.value },
              message: s.message,
            }),
            r.dirty())
          : s.kind === "endsWith"
          ? t.data.endsWith(s.value) ||
            ((i = this._getOrReturnCtx(t, i)),
            K(i, {
              code: H.invalid_string,
              validation: { endsWith: s.value },
              message: s.message,
            }),
            r.dirty())
          : s.kind === "datetime"
          ? E9(s).test(t.data) ||
            ((i = this._getOrReturnCtx(t, i)),
            K(i, {
              code: H.invalid_string,
              validation: "datetime",
              message: s.message,
            }),
            r.dirty())
          : s.kind === "ip"
          ? _9(t.data, s.version) ||
            ((i = this._getOrReturnCtx(t, i)),
            K(i, {
              validation: "ip",
              code: H.invalid_string,
              message: s.message,
            }),
            r.dirty())
          : Pe.assertNever(s);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: H.invalid_string,
      ...te.errToObj(r),
    });
  }
  _addCheck(t) {
    return new ur({ ...this._def, checks: [...this._def.checks, t] });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...te.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...te.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...te.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...te.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...te.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...te.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...te.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...te.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          message: t,
        })
      : this._addCheck({
          kind: "datetime",
          precision:
            typeof (t == null ? void 0 : t.precision) > "u"
              ? null
              : t == null
              ? void 0
              : t.precision,
          offset:
            (n = t == null ? void 0 : t.offset) !== null && n !== void 0
              ? n
              : !1,
          ...te.errToObj(t == null ? void 0 : t.message),
        });
  }
  regex(t, n) {
    return this._addCheck({ kind: "regex", regex: t, ...te.errToObj(n) });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...te.errToObj(n == null ? void 0 : n.message),
    });
  }
  startsWith(t, n) {
    return this._addCheck({ kind: "startsWith", value: t, ...te.errToObj(n) });
  }
  endsWith(t, n) {
    return this._addCheck({ kind: "endsWith", value: t, ...te.errToObj(n) });
  }
  min(t, n) {
    return this._addCheck({ kind: "min", value: t, ...te.errToObj(n) });
  }
  max(t, n) {
    return this._addCheck({ kind: "max", value: t, ...te.errToObj(n) });
  }
  length(t, n) {
    return this._addCheck({ kind: "length", value: t, ...te.errToObj(n) });
  }
  nonempty(t) {
    return this.min(1, te.errToObj(t));
  }
  trim() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }],
    });
  }
  toLowerCase() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }],
    });
  }
  toUpperCase() {
    return new ur({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
ur.create = (e) => {
  var t;
  return new ur({
    checks: [],
    typeName: re.ZodString,
    coerce:
      (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...fe(e),
  });
};
function A9(e, t) {
  const n = (e.toString().split(".")[1] || "").length,
    r = (t.toString().split(".")[1] || "").length,
    i = n > r ? n : r,
    s = parseInt(e.toFixed(i).replace(".", "")),
    o = parseInt(t.toFixed(i).replace(".", ""));
  return (s % o) / Math.pow(10, i);
}
class os extends ye {
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf);
  }
  _parse(t) {
    if (
      (this._def.coerce && (t.data = Number(t.data)),
      this._getType(t) !== V.number)
    ) {
      const s = this._getOrReturnCtx(t);
      return (
        K(s, {
          code: H.invalid_type,
          expected: V.number,
          received: s.parsedType,
        }),
        le
      );
    }
    let r;
    const i = new Xt();
    for (const s of this._def.checks)
      s.kind === "int"
        ? Pe.isInteger(t.data) ||
          ((r = this._getOrReturnCtx(t, r)),
          K(r, {
            code: H.invalid_type,
            expected: "integer",
            received: "float",
            message: s.message,
          }),
          i.dirty())
        : s.kind === "min"
        ? (s.inclusive ? t.data < s.value : t.data <= s.value) &&
          ((r = this._getOrReturnCtx(t, r)),
          K(r, {
            code: H.too_small,
            minimum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "max"
        ? (s.inclusive ? t.data > s.value : t.data >= s.value) &&
          ((r = this._getOrReturnCtx(t, r)),
          K(r, {
            code: H.too_big,
            maximum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "multipleOf"
        ? A9(t.data, s.value) !== 0 &&
          ((r = this._getOrReturnCtx(t, r)),
          K(r, {
            code: H.not_multiple_of,
            multipleOf: s.value,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "finite"
        ? Number.isFinite(t.data) ||
          ((r = this._getOrReturnCtx(t, r)),
          K(r, { code: H.not_finite, message: s.message }),
          i.dirty())
        : Pe.assertNever(s);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, te.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, te.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, te.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, te.toString(n));
  }
  setLimit(t, n, r, i) {
    return new os({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: t, value: n, inclusive: r, message: te.toString(i) },
      ],
    });
  }
  _addCheck(t) {
    return new os({ ...this._def, checks: [...this._def.checks, t] });
  }
  int(t) {
    return this._addCheck({ kind: "int", message: te.toString(t) });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: te.toString(t),
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: te.toString(t),
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: te.toString(t),
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: te.toString(t),
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: te.toString(n),
    });
  }
  finite(t) {
    return this._addCheck({ kind: "finite", message: te.toString(t) });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: te.toString(t),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: te.toString(t),
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find(
      (t) =>
        t.kind === "int" || (t.kind === "multipleOf" && Pe.isInteger(t.value))
    );
  }
  get isFinite() {
    let t = null,
      n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min"
        ? (n === null || r.value > n) && (n = r.value)
        : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
os.create = (e) =>
  new os({
    checks: [],
    typeName: re.ZodNumber,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...fe(e),
  });
class as extends ye {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte);
  }
  _parse(t) {
    if (
      (this._def.coerce && (t.data = BigInt(t.data)),
      this._getType(t) !== V.bigint)
    ) {
      const s = this._getOrReturnCtx(t);
      return (
        K(s, {
          code: H.invalid_type,
          expected: V.bigint,
          received: s.parsedType,
        }),
        le
      );
    }
    let r;
    const i = new Xt();
    for (const s of this._def.checks)
      s.kind === "min"
        ? (s.inclusive ? t.data < s.value : t.data <= s.value) &&
          ((r = this._getOrReturnCtx(t, r)),
          K(r, {
            code: H.too_small,
            type: "bigint",
            minimum: s.value,
            inclusive: s.inclusive,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "max"
        ? (s.inclusive ? t.data > s.value : t.data >= s.value) &&
          ((r = this._getOrReturnCtx(t, r)),
          K(r, {
            code: H.too_big,
            type: "bigint",
            maximum: s.value,
            inclusive: s.inclusive,
            message: s.message,
          }),
          i.dirty())
        : s.kind === "multipleOf"
        ? t.data % s.value !== BigInt(0) &&
          ((r = this._getOrReturnCtx(t, r)),
          K(r, {
            code: H.not_multiple_of,
            multipleOf: s.value,
            message: s.message,
          }),
          i.dirty())
        : Pe.assertNever(s);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, te.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, te.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, te.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, te.toString(n));
  }
  setLimit(t, n, r, i) {
    return new as({
      ...this._def,
      checks: [
        ...this._def.checks,
        { kind: t, value: n, inclusive: r, message: te.toString(i) },
      ],
    });
  }
  _addCheck(t) {
    return new as({ ...this._def, checks: [...this._def.checks, t] });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: te.toString(t),
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: te.toString(t),
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: te.toString(t),
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: te.toString(t),
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: te.toString(n),
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
as.create = (e) => {
  var t;
  return new as({
    checks: [],
    typeName: re.ZodBigInt,
    coerce:
      (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...fe(e),
  });
};
class Dc extends ye {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = !!t.data), this._getType(t) !== V.boolean)
    ) {
      const r = this._getOrReturnCtx(t);
      return (
        K(r, {
          code: H.invalid_type,
          expected: V.boolean,
          received: r.parsedType,
        }),
        le
      );
    }
    return on(t.data);
  }
}
Dc.create = (e) =>
  new Dc({
    typeName: re.ZodBoolean,
    coerce: (e == null ? void 0 : e.coerce) || !1,
    ...fe(e),
  });
class ro extends ye {
  _parse(t) {
    if (
      (this._def.coerce && (t.data = new Date(t.data)),
      this._getType(t) !== V.date)
    ) {
      const s = this._getOrReturnCtx(t);
      return (
        K(s, {
          code: H.invalid_type,
          expected: V.date,
          received: s.parsedType,
        }),
        le
      );
    }
    if (isNaN(t.data.getTime())) {
      const s = this._getOrReturnCtx(t);
      return K(s, { code: H.invalid_date }), le;
    }
    const r = new Xt();
    let i;
    for (const s of this._def.checks)
      s.kind === "min"
        ? t.data.getTime() < s.value &&
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            code: H.too_small,
            message: s.message,
            inclusive: !0,
            exact: !1,
            minimum: s.value,
            type: "date",
          }),
          r.dirty())
        : s.kind === "max"
        ? t.data.getTime() > s.value &&
          ((i = this._getOrReturnCtx(t, i)),
          K(i, {
            code: H.too_big,
            message: s.message,
            inclusive: !0,
            exact: !1,
            maximum: s.value,
            type: "date",
          }),
          r.dirty())
        : Pe.assertNever(s);
    return { status: r.value, value: new Date(t.data.getTime()) };
  }
  _addCheck(t) {
    return new ro({ ...this._def, checks: [...this._def.checks, t] });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: te.toString(n),
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: te.toString(n),
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
ro.create = (e) =>
  new ro({
    checks: [],
    coerce: (e == null ? void 0 : e.coerce) || !1,
    typeName: re.ZodDate,
    ...fe(e),
  });
class qf extends ye {
  _parse(t) {
    if (this._getType(t) !== V.symbol) {
      const r = this._getOrReturnCtx(t);
      return (
        K(r, {
          code: H.invalid_type,
          expected: V.symbol,
          received: r.parsedType,
        }),
        le
      );
    }
    return on(t.data);
  }
}
qf.create = (e) => new qf({ typeName: re.ZodSymbol, ...fe(e) });
class Oc extends ye {
  _parse(t) {
    if (this._getType(t) !== V.undefined) {
      const r = this._getOrReturnCtx(t);
      return (
        K(r, {
          code: H.invalid_type,
          expected: V.undefined,
          received: r.parsedType,
        }),
        le
      );
    }
    return on(t.data);
  }
}
Oc.create = (e) => new Oc({ typeName: re.ZodUndefined, ...fe(e) });
class Rc extends ye {
  _parse(t) {
    if (this._getType(t) !== V.null) {
      const r = this._getOrReturnCtx(t);
      return (
        K(r, {
          code: H.invalid_type,
          expected: V.null,
          received: r.parsedType,
        }),
        le
      );
    }
    return on(t.data);
  }
}
Rc.create = (e) => new Rc({ typeName: re.ZodNull, ...fe(e) });
class Ea extends ye {
  constructor() {
    super(...arguments), (this._any = !0);
  }
  _parse(t) {
    return on(t.data);
  }
}
Ea.create = (e) => new Ea({ typeName: re.ZodAny, ...fe(e) });
class Gs extends ye {
  constructor() {
    super(...arguments), (this._unknown = !0);
  }
  _parse(t) {
    return on(t.data);
  }
}
Gs.create = (e) => new Gs({ typeName: re.ZodUnknown, ...fe(e) });
class pi extends ye {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return (
      K(n, { code: H.invalid_type, expected: V.never, received: n.parsedType }),
      le
    );
  }
}
pi.create = (e) => new pi({ typeName: re.ZodNever, ...fe(e) });
class Wf extends ye {
  _parse(t) {
    if (this._getType(t) !== V.undefined) {
      const r = this._getOrReturnCtx(t);
      return (
        K(r, {
          code: H.invalid_type,
          expected: V.void,
          received: r.parsedType,
        }),
        le
      );
    }
    return on(t.data);
  }
}
Wf.create = (e) => new Wf({ typeName: re.ZodVoid, ...fe(e) });
class fr extends ye {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t),
      i = this._def;
    if (n.parsedType !== V.array)
      return (
        K(n, {
          code: H.invalid_type,
          expected: V.array,
          received: n.parsedType,
        }),
        le
      );
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value,
        a = n.data.length < i.exactLength.value;
      (o || a) &&
        (K(n, {
          code: o ? H.too_big : H.too_small,
          minimum: a ? i.exactLength.value : void 0,
          maximum: o ? i.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: i.exactLength.message,
        }),
        r.dirty());
    }
    if (
      (i.minLength !== null &&
        n.data.length < i.minLength.value &&
        (K(n, {
          code: H.too_small,
          minimum: i.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: i.minLength.message,
        }),
        r.dirty()),
      i.maxLength !== null &&
        n.data.length > i.maxLength.value &&
        (K(n, {
          code: H.too_big,
          maximum: i.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: i.maxLength.message,
        }),
        r.dirty()),
      n.common.async)
    )
      return Promise.all(
        [...n.data].map((o, a) => i.type._parseAsync(new Rr(n, o, n.path, a)))
      ).then((o) => Xt.mergeArray(r, o));
    const s = [...n.data].map((o, a) =>
      i.type._parseSync(new Rr(n, o, n.path, a))
    );
    return Xt.mergeArray(r, s);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new fr({
      ...this._def,
      minLength: { value: t, message: te.toString(n) },
    });
  }
  max(t, n) {
    return new fr({
      ...this._def,
      maxLength: { value: t, message: te.toString(n) },
    });
  }
  length(t, n) {
    return new fr({
      ...this._def,
      exactLength: { value: t, message: te.toString(n) },
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
fr.create = (e, t) =>
  new fr({
    type: e,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: re.ZodArray,
    ...fe(t),
  });
function Po(e) {
  if (e instanceof Ze) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = si.create(Po(r));
    }
    return new Ze({ ...e._def, shape: () => t });
  } else
    return e instanceof fr
      ? new fr({ ...e._def, type: Po(e.element) })
      : e instanceof si
      ? si.create(Po(e.unwrap()))
      : e instanceof so
      ? so.create(Po(e.unwrap()))
      : e instanceof Br
      ? Br.create(e.items.map((t) => Po(t)))
      : e;
}
class Ze extends ye {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend);
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const t = this._def.shape(),
      n = Pe.objectKeys(t);
    return (this._cached = { shape: t, keys: n });
  }
  _parse(t) {
    if (this._getType(t) !== V.object) {
      const l = this._getOrReturnCtx(t);
      return (
        K(l, {
          code: H.invalid_type,
          expected: V.object,
          received: l.parsedType,
        }),
        le
      );
    }
    const { status: r, ctx: i } = this._processInputParams(t),
      { shape: s, keys: o } = this._getCached(),
      a = [];
    if (
      !(this._def.catchall instanceof pi && this._def.unknownKeys === "strip")
    )
      for (const l in i.data) o.includes(l) || a.push(l);
    const u = [];
    for (const l of o) {
      const c = s[l],
        d = i.data[l];
      u.push({
        key: { status: "valid", value: l },
        value: c._parse(new Rr(i, d, i.path, l)),
        alwaysSet: l in i.data,
      });
    }
    if (this._def.catchall instanceof pi) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const c of a)
          u.push({
            key: { status: "valid", value: c },
            value: { status: "valid", value: i.data[c] },
          });
      else if (l === "strict")
        a.length > 0 &&
          (K(i, { code: H.unrecognized_keys, keys: a }), r.dirty());
      else if (l !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const c of a) {
        const d = i.data[c];
        u.push({
          key: { status: "valid", value: c },
          value: l._parse(new Rr(i, d, i.path, c)),
          alwaysSet: c in i.data,
        });
      }
    }
    return i.common.async
      ? Promise.resolve()
          .then(async () => {
            const l = [];
            for (const c of u) {
              const d = await c.key;
              l.push({ key: d, value: await c.value, alwaysSet: c.alwaysSet });
            }
            return l;
          })
          .then((l) => Xt.mergeObjectSync(r, l))
      : Xt.mergeObjectSync(r, u);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return (
      te.errToObj,
      new Ze({
        ...this._def,
        unknownKeys: "strict",
        ...(t !== void 0
          ? {
              errorMap: (n, r) => {
                var i, s, o, a;
                const u =
                  (o =
                    (s = (i = this._def).errorMap) === null || s === void 0
                      ? void 0
                      : s.call(i, n, r).message) !== null && o !== void 0
                    ? o
                    : r.defaultError;
                return n.code === "unrecognized_keys"
                  ? {
                      message:
                        (a = te.errToObj(t).message) !== null && a !== void 0
                          ? a
                          : u,
                    }
                  : { message: u };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new Ze({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new Ze({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(t) {
    return new Ze({
      ...this._def,
      shape: () => ({ ...this._def.shape(), ...t }),
    });
  }
  merge(t) {
    return new Ze({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({ ...this._def.shape(), ...t._def.shape() }),
      typeName: re.ZodObject,
    });
  }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  catchall(t) {
    return new Ze({ ...this._def, catchall: t });
  }
  pick(t) {
    const n = {};
    return (
      Pe.objectKeys(t).forEach((r) => {
        t[r] && this.shape[r] && (n[r] = this.shape[r]);
      }),
      new Ze({ ...this._def, shape: () => n })
    );
  }
  omit(t) {
    const n = {};
    return (
      Pe.objectKeys(this.shape).forEach((r) => {
        t[r] || (n[r] = this.shape[r]);
      }),
      new Ze({ ...this._def, shape: () => n })
    );
  }
  deepPartial() {
    return Po(this);
  }
  partial(t) {
    const n = {};
    return (
      Pe.objectKeys(this.shape).forEach((r) => {
        const i = this.shape[r];
        t && !t[r] ? (n[r] = i) : (n[r] = i.optional());
      }),
      new Ze({ ...this._def, shape: () => n })
    );
  }
  required(t) {
    const n = {};
    return (
      Pe.objectKeys(this.shape).forEach((r) => {
        if (t && !t[r]) n[r] = this.shape[r];
        else {
          let s = this.shape[r];
          for (; s instanceof si; ) s = s._def.innerType;
          n[r] = s;
        }
      }),
      new Ze({ ...this._def, shape: () => n })
    );
  }
  keyof() {
    return C3(Pe.objectKeys(this.shape));
  }
}
Ze.create = (e, t) =>
  new Ze({
    shape: () => e,
    unknownKeys: "strip",
    catchall: pi.create(),
    typeName: re.ZodObject,
    ...fe(t),
  });
Ze.strictCreate = (e, t) =>
  new Ze({
    shape: () => e,
    unknownKeys: "strict",
    catchall: pi.create(),
    typeName: re.ZodObject,
    ...fe(t),
  });
Ze.lazycreate = (e, t) =>
  new Ze({
    shape: e,
    unknownKeys: "strip",
    catchall: pi.create(),
    typeName: re.ZodObject,
    ...fe(t),
  });
class Bc extends ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t),
      r = this._def.options;
    function i(s) {
      for (const a of s) if (a.result.status === "valid") return a.result;
      for (const a of s)
        if (a.result.status === "dirty")
          return n.common.issues.push(...a.ctx.common.issues), a.result;
      const o = s.map((a) => new dr(a.ctx.common.issues));
      return K(n, { code: H.invalid_union, unionErrors: o }), le;
    }
    if (n.common.async)
      return Promise.all(
        r.map(async (s) => {
          const o = { ...n, common: { ...n.common, issues: [] }, parent: null };
          return {
            result: await s._parseAsync({
              data: n.data,
              path: n.path,
              parent: o,
            }),
            ctx: o,
          };
        })
      ).then(i);
    {
      let s;
      const o = [];
      for (const u of r) {
        const l = { ...n, common: { ...n.common, issues: [] }, parent: null },
          c = u._parseSync({ data: n.data, path: n.path, parent: l });
        if (c.status === "valid") return c;
        c.status === "dirty" && !s && (s = { result: c, ctx: l }),
          l.common.issues.length && o.push(l.common.issues);
      }
      if (s) return n.common.issues.push(...s.ctx.common.issues), s.result;
      const a = o.map((u) => new dr(u));
      return K(n, { code: H.invalid_union, unionErrors: a }), le;
    }
  }
  get options() {
    return this._def.options;
  }
}
Bc.create = (e, t) => new Bc({ options: e, typeName: re.ZodUnion, ...fe(t) });
const Pd = (e) =>
  e instanceof Lc
    ? Pd(e.schema)
    : e instanceof mr
    ? Pd(e.innerType())
    : e instanceof Fc
    ? [e.value]
    : e instanceof us
    ? e.options
    : e instanceof jc
    ? Object.keys(e.enum)
    : e instanceof Uc
    ? Pd(e._def.innerType)
    : e instanceof Oc
    ? [void 0]
    : e instanceof Rc
    ? [null]
    : null;
class lp extends ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== V.object)
      return (
        K(n, {
          code: H.invalid_type,
          expected: V.object,
          received: n.parsedType,
        }),
        le
      );
    const r = this.discriminator,
      i = n.data[r],
      s = this.optionsMap.get(i);
    return s
      ? n.common.async
        ? s._parseAsync({ data: n.data, path: n.path, parent: n })
        : s._parseSync({ data: n.data, path: n.path, parent: n })
      : (K(n, {
          code: H.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [r],
        }),
        le);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(t, n, r) {
    const i = new Map();
    for (const s of n) {
      const o = Pd(s.shape[t]);
      if (!o)
        throw new Error(
          `A discriminator value for key \`${t}\` could not be extracted from all schema options`
        );
      for (const a of o) {
        if (i.has(a))
          throw new Error(
            `Discriminator property ${String(t)} has duplicate value ${String(
              a
            )}`
          );
        i.set(a, s);
      }
    }
    return new lp({
      typeName: re.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...fe(r),
    });
  }
}
function ag(e, t) {
  const n = Li(e),
    r = Li(t);
  if (e === t) return { valid: !0, data: e };
  if (n === V.object && r === V.object) {
    const i = Pe.objectKeys(t),
      s = Pe.objectKeys(e).filter((a) => i.indexOf(a) !== -1),
      o = { ...e, ...t };
    for (const a of s) {
      const u = ag(e[a], t[a]);
      if (!u.valid) return { valid: !1 };
      o[a] = u.data;
    }
    return { valid: !0, data: o };
  } else if (n === V.array && r === V.array) {
    if (e.length !== t.length) return { valid: !1 };
    const i = [];
    for (let s = 0; s < e.length; s++) {
      const o = e[s],
        a = t[s],
        u = ag(o, a);
      if (!u.valid) return { valid: !1 };
      i.push(u.data);
    }
    return { valid: !0, data: i };
  } else
    return n === V.date && r === V.date && +e == +t
      ? { valid: !0, data: e }
      : { valid: !1 };
}
class Nc extends ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t),
      i = (s, o) => {
        if (sg(s) || sg(o)) return le;
        const a = ag(s.value, o.value);
        return a.valid
          ? ((og(s) || og(o)) && n.dirty(), { status: n.value, value: a.data })
          : (K(r, { code: H.invalid_intersection_types }), le);
      };
    return r.common.async
      ? Promise.all([
          this._def.left._parseAsync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r,
          }),
        ]).then(([s, o]) => i(s, o))
      : i(
          this._def.left._parseSync({ data: r.data, path: r.path, parent: r }),
          this._def.right._parseSync({ data: r.data, path: r.path, parent: r })
        );
  }
}
Nc.create = (e, t, n) =>
  new Nc({ left: e, right: t, typeName: re.ZodIntersection, ...fe(n) });
class Br extends ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== V.array)
      return (
        K(r, {
          code: H.invalid_type,
          expected: V.array,
          received: r.parsedType,
        }),
        le
      );
    if (r.data.length < this._def.items.length)
      return (
        K(r, {
          code: H.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        le
      );
    !this._def.rest &&
      r.data.length > this._def.items.length &&
      (K(r, {
        code: H.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      n.dirty());
    const s = [...r.data]
      .map((o, a) => {
        const u = this._def.items[a] || this._def.rest;
        return u ? u._parse(new Rr(r, o, r.path, a)) : null;
      })
      .filter((o) => !!o);
    return r.common.async
      ? Promise.all(s).then((o) => Xt.mergeArray(n, o))
      : Xt.mergeArray(n, s);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Br({ ...this._def, rest: t });
  }
}
Br.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Br({ items: e, typeName: re.ZodTuple, rest: null, ...fe(t) });
};
class Mc extends ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== V.object)
      return (
        K(r, {
          code: H.invalid_type,
          expected: V.object,
          received: r.parsedType,
        }),
        le
      );
    const i = [],
      s = this._def.keyType,
      o = this._def.valueType;
    for (const a in r.data)
      i.push({
        key: s._parse(new Rr(r, a, r.path, a)),
        value: o._parse(new Rr(r, r.data[a], r.path, a)),
      });
    return r.common.async
      ? Xt.mergeObjectAsync(n, i)
      : Xt.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof ye
      ? new Mc({ keyType: t, valueType: n, typeName: re.ZodRecord, ...fe(r) })
      : new Mc({
          keyType: ur.create(),
          valueType: t,
          typeName: re.ZodRecord,
          ...fe(n),
        });
  }
}
class Qf extends ye {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== V.map)
      return (
        K(r, { code: H.invalid_type, expected: V.map, received: r.parsedType }),
        le
      );
    const i = this._def.keyType,
      s = this._def.valueType,
      o = [...r.data.entries()].map(([a, u], l) => ({
        key: i._parse(new Rr(r, a, r.path, [l, "key"])),
        value: s._parse(new Rr(r, u, r.path, [l, "value"])),
      }));
    if (r.common.async) {
      const a = new Map();
      return Promise.resolve().then(async () => {
        for (const u of o) {
          const l = await u.key,
            c = await u.value;
          if (l.status === "aborted" || c.status === "aborted") return le;
          (l.status === "dirty" || c.status === "dirty") && n.dirty(),
            a.set(l.value, c.value);
        }
        return { status: n.value, value: a };
      });
    } else {
      const a = new Map();
      for (const u of o) {
        const l = u.key,
          c = u.value;
        if (l.status === "aborted" || c.status === "aborted") return le;
        (l.status === "dirty" || c.status === "dirty") && n.dirty(),
          a.set(l.value, c.value);
      }
      return { status: n.value, value: a };
    }
  }
}
Qf.create = (e, t, n) =>
  new Qf({ valueType: t, keyType: e, typeName: re.ZodMap, ...fe(n) });
class io extends ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== V.set)
      return (
        K(r, { code: H.invalid_type, expected: V.set, received: r.parsedType }),
        le
      );
    const i = this._def;
    i.minSize !== null &&
      r.data.size < i.minSize.value &&
      (K(r, {
        code: H.too_small,
        minimum: i.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: i.minSize.message,
      }),
      n.dirty()),
      i.maxSize !== null &&
        r.data.size > i.maxSize.value &&
        (K(r, {
          code: H.too_big,
          maximum: i.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: i.maxSize.message,
        }),
        n.dirty());
    const s = this._def.valueType;
    function o(u) {
      const l = new Set();
      for (const c of u) {
        if (c.status === "aborted") return le;
        c.status === "dirty" && n.dirty(), l.add(c.value);
      }
      return { status: n.value, value: l };
    }
    const a = [...r.data.values()].map((u, l) =>
      s._parse(new Rr(r, u, r.path, l))
    );
    return r.common.async ? Promise.all(a).then((u) => o(u)) : o(a);
  }
  min(t, n) {
    return new io({
      ...this._def,
      minSize: { value: t, message: te.toString(n) },
    });
  }
  max(t, n) {
    return new io({
      ...this._def,
      maxSize: { value: t, message: te.toString(n) },
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
io.create = (e, t) =>
  new io({
    valueType: e,
    minSize: null,
    maxSize: null,
    typeName: re.ZodSet,
    ...fe(t),
  });
class ia extends ye {
  constructor() {
    super(...arguments), (this.validate = this.implement);
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== V.function)
      return (
        K(n, {
          code: H.invalid_type,
          expected: V.function,
          received: n.parsedType,
        }),
        le
      );
    function r(a, u) {
      return zf({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Hf(),
          kc,
        ].filter((l) => !!l),
        issueData: { code: H.invalid_arguments, argumentsError: u },
      });
    }
    function i(a, u) {
      return zf({
        data: a,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Hf(),
          kc,
        ].filter((l) => !!l),
        issueData: { code: H.invalid_return_type, returnTypeError: u },
      });
    }
    const s = { errorMap: n.common.contextualErrorMap },
      o = n.data;
    if (this._def.returns instanceof _a) {
      const a = this;
      return on(async function (...u) {
        const l = new dr([]),
          c = await a._def.args.parseAsync(u, s).catch((p) => {
            throw (l.addIssue(r(u, p)), l);
          }),
          d = await Reflect.apply(o, this, c);
        return await a._def.returns._def.type.parseAsync(d, s).catch((p) => {
          throw (l.addIssue(i(d, p)), l);
        });
      });
    } else {
      const a = this;
      return on(function (...u) {
        const l = a._def.args.safeParse(u, s);
        if (!l.success) throw new dr([r(u, l.error)]);
        const c = Reflect.apply(o, this, l.data),
          d = a._def.returns.safeParse(c, s);
        if (!d.success) throw new dr([i(c, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new ia({ ...this._def, args: Br.create(t).rest(Gs.create()) });
  }
  returns(t) {
    return new ia({ ...this._def, returns: t });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new ia({
      args: t || Br.create([]).rest(Gs.create()),
      returns: n || Gs.create(),
      typeName: re.ZodFunction,
      ...fe(r),
    });
  }
}
class Lc extends ye {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Lc.create = (e, t) => new Lc({ getter: e, typeName: re.ZodLazy, ...fe(t) });
class Fc extends ye {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return (
        K(n, {
          received: n.data,
          code: H.invalid_literal,
          expected: this._def.value,
        }),
        le
      );
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Fc.create = (e, t) => new Fc({ value: e, typeName: re.ZodLiteral, ...fe(t) });
function C3(e, t) {
  return new us({ values: e, typeName: re.ZodEnum, ...fe(t) });
}
class us extends ye {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t),
        r = this._def.values;
      return (
        K(n, {
          expected: Pe.joinValues(r),
          received: n.parsedType,
          code: H.invalid_type,
        }),
        le
      );
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t),
        r = this._def.values;
      return (
        K(n, { received: n.data, code: H.invalid_enum_value, options: r }), le
      );
    }
    return on(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values) t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values) t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values) t[n] = n;
    return t;
  }
  extract(t) {
    return us.create(t);
  }
  exclude(t) {
    return us.create(this.options.filter((n) => !t.includes(n)));
  }
}
us.create = C3;
class jc extends ye {
  _parse(t) {
    const n = Pe.getValidEnumValues(this._def.values),
      r = this._getOrReturnCtx(t);
    if (r.parsedType !== V.string && r.parsedType !== V.number) {
      const i = Pe.objectValues(n);
      return (
        K(r, {
          expected: Pe.joinValues(i),
          received: r.parsedType,
          code: H.invalid_type,
        }),
        le
      );
    }
    if (n.indexOf(t.data) === -1) {
      const i = Pe.objectValues(n);
      return (
        K(r, { received: r.data, code: H.invalid_enum_value, options: i }), le
      );
    }
    return on(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
jc.create = (e, t) =>
  new jc({ values: e, typeName: re.ZodNativeEnum, ...fe(t) });
class _a extends ye {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== V.promise && n.common.async === !1)
      return (
        K(n, {
          code: H.invalid_type,
          expected: V.promise,
          received: n.parsedType,
        }),
        le
      );
    const r = n.parsedType === V.promise ? n.data : Promise.resolve(n.data);
    return on(
      r.then((i) =>
        this._def.type.parseAsync(i, {
          path: n.path,
          errorMap: n.common.contextualErrorMap,
        })
      )
    );
  }
}
_a.create = (e, t) => new _a({ type: e, typeName: re.ZodPromise, ...fe(t) });
class mr extends ye {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === re.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t),
      i = this._def.effect || null,
      s = {
        addIssue: (o) => {
          K(r, o), o.fatal ? n.abort() : n.dirty();
        },
        get path() {
          return r.path;
        },
      };
    if (((s.addIssue = s.addIssue.bind(s)), i.type === "preprocess")) {
      const o = i.transform(r.data, s);
      return r.common.issues.length
        ? { status: "dirty", value: r.data }
        : r.common.async
        ? Promise.resolve(o).then((a) =>
            this._def.schema._parseAsync({ data: a, path: r.path, parent: r })
          )
        : this._def.schema._parseSync({ data: o, path: r.path, parent: r });
    }
    if (i.type === "refinement") {
      const o = (a) => {
        const u = i.refinement(a, s);
        if (r.common.async) return Promise.resolve(u);
        if (u instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return a;
      };
      if (r.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r,
        });
        return a.status === "aborted"
          ? le
          : (a.status === "dirty" && n.dirty(),
            o(a.value),
            { status: n.value, value: a.value });
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then((a) =>
            a.status === "aborted"
              ? le
              : (a.status === "dirty" && n.dirty(),
                o(a.value).then(() => ({ status: n.value, value: a.value })))
          );
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r,
        });
        if (!Pc(o)) return o;
        const a = i.transform(o.value, s);
        if (a instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return { status: n.value, value: a };
      } else
        return this._def.schema
          ._parseAsync({ data: r.data, path: r.path, parent: r })
          .then((o) =>
            Pc(o)
              ? Promise.resolve(i.transform(o.value, s)).then((a) => ({
                  status: n.value,
                  value: a,
                }))
              : o
          );
    Pe.assertNever(i);
  }
}
mr.create = (e, t, n) =>
  new mr({ schema: e, typeName: re.ZodEffects, effect: t, ...fe(n) });
mr.createWithPreprocess = (e, t, n) =>
  new mr({
    schema: t,
    effect: { type: "preprocess", transform: e },
    typeName: re.ZodEffects,
    ...fe(n),
  });
class si extends ye {
  _parse(t) {
    return this._getType(t) === V.undefined
      ? on(void 0)
      : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
si.create = (e, t) =>
  new si({ innerType: e, typeName: re.ZodOptional, ...fe(t) });
class so extends ye {
  _parse(t) {
    return this._getType(t) === V.null
      ? on(null)
      : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
so.create = (e, t) =>
  new so({ innerType: e, typeName: re.ZodNullable, ...fe(t) });
class Uc extends ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return (
      n.parsedType === V.undefined && (r = this._def.defaultValue()),
      this._def.innerType._parse({ data: r, path: n.path, parent: n })
    );
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Uc.create = (e, t) =>
  new Uc({
    innerType: e,
    typeName: re.ZodDefault,
    defaultValue: typeof t.default == "function" ? t.default : () => t.default,
    ...fe(t),
  });
class Vf extends ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t),
      r = { ...n, common: { ...n.common, issues: [] } },
      i = this._def.innerType._parse({
        data: r.data,
        path: r.path,
        parent: { ...r },
      });
    return Gf(i)
      ? i.then((s) => ({
          status: "valid",
          value:
            s.status === "valid"
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new dr(r.common.issues);
                  },
                  input: r.data,
                }),
        }))
      : {
          status: "valid",
          value:
            i.status === "valid"
              ? i.value
              : this._def.catchValue({
                  get error() {
                    return new dr(r.common.issues);
                  },
                  input: r.data,
                }),
        };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Vf.create = (e, t) =>
  new Vf({
    innerType: e,
    typeName: re.ZodCatch,
    catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
    ...fe(t),
  });
class Kf extends ye {
  _parse(t) {
    if (this._getType(t) !== V.nan) {
      const r = this._getOrReturnCtx(t);
      return (
        K(r, { code: H.invalid_type, expected: V.nan, received: r.parsedType }),
        le
      );
    }
    return { status: "valid", value: t.data };
  }
}
Kf.create = (e) => new Kf({ typeName: re.ZodNaN, ...fe(e) });
const x9 = Symbol("zod_brand");
class T3 extends ye {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t),
      r = n.data;
    return this._def.type._parse({ data: r, path: n.path, parent: n });
  }
  unwrap() {
    return this._def.type;
  }
}
class gl extends ye {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r,
        });
        return s.status === "aborted"
          ? le
          : s.status === "dirty"
          ? (n.dirty(), S3(s.value))
          : this._def.out._parseAsync({
              data: s.value,
              path: r.path,
              parent: r,
            });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r,
      });
      return i.status === "aborted"
        ? le
        : i.status === "dirty"
        ? (n.dirty(), { status: "dirty", value: i.value })
        : this._def.out._parseSync({ data: i.value, path: r.path, parent: r });
    }
  }
  static create(t, n) {
    return new gl({ in: t, out: n, typeName: re.ZodPipeline });
  }
}
class Zf extends ye {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return Pc(n) && (n.value = Object.freeze(n.value)), n;
  }
}
Zf.create = (e, t) =>
  new Zf({ innerType: e, typeName: re.ZodReadonly, ...fe(t) });
const I3 = (e, t = {}, n) =>
    e
      ? Ea.create().superRefine((r, i) => {
          var s, o;
          if (!e(r)) {
            const a =
                typeof t == "function"
                  ? t(r)
                  : typeof t == "string"
                  ? { message: t }
                  : t,
              u =
                (o = (s = a.fatal) !== null && s !== void 0 ? s : n) !== null &&
                o !== void 0
                  ? o
                  : !0,
              l = typeof a == "string" ? { message: a } : a;
            i.addIssue({ code: "custom", ...l, fatal: u });
          }
        })
      : Ea.create(),
  S9 = { object: Ze.lazycreate };
var re;
(function (e) {
  (e.ZodString = "ZodString"),
    (e.ZodNumber = "ZodNumber"),
    (e.ZodNaN = "ZodNaN"),
    (e.ZodBigInt = "ZodBigInt"),
    (e.ZodBoolean = "ZodBoolean"),
    (e.ZodDate = "ZodDate"),
    (e.ZodSymbol = "ZodSymbol"),
    (e.ZodUndefined = "ZodUndefined"),
    (e.ZodNull = "ZodNull"),
    (e.ZodAny = "ZodAny"),
    (e.ZodUnknown = "ZodUnknown"),
    (e.ZodNever = "ZodNever"),
    (e.ZodVoid = "ZodVoid"),
    (e.ZodArray = "ZodArray"),
    (e.ZodObject = "ZodObject"),
    (e.ZodUnion = "ZodUnion"),
    (e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (e.ZodIntersection = "ZodIntersection"),
    (e.ZodTuple = "ZodTuple"),
    (e.ZodRecord = "ZodRecord"),
    (e.ZodMap = "ZodMap"),
    (e.ZodSet = "ZodSet"),
    (e.ZodFunction = "ZodFunction"),
    (e.ZodLazy = "ZodLazy"),
    (e.ZodLiteral = "ZodLiteral"),
    (e.ZodEnum = "ZodEnum"),
    (e.ZodEffects = "ZodEffects"),
    (e.ZodNativeEnum = "ZodNativeEnum"),
    (e.ZodOptional = "ZodOptional"),
    (e.ZodNullable = "ZodNullable"),
    (e.ZodDefault = "ZodDefault"),
    (e.ZodCatch = "ZodCatch"),
    (e.ZodPromise = "ZodPromise"),
    (e.ZodBranded = "ZodBranded"),
    (e.ZodPipeline = "ZodPipeline"),
    (e.ZodReadonly = "ZodReadonly");
})(re || (re = {}));
const C9 = (e, t = { message: `Input not instance of ${e.name}` }) =>
    I3((n) => n instanceof e, t),
  k3 = ur.create,
  P3 = os.create,
  T9 = Kf.create,
  I9 = as.create,
  D3 = Dc.create,
  k9 = ro.create,
  P9 = qf.create,
  D9 = Oc.create,
  O9 = Rc.create,
  R9 = Ea.create,
  B9 = Gs.create,
  N9 = pi.create,
  M9 = Wf.create,
  L9 = fr.create,
  F9 = Ze.create,
  j9 = Ze.strictCreate,
  U9 = Bc.create,
  $9 = lp.create,
  H9 = Nc.create,
  z9 = Br.create,
  G9 = Mc.create,
  q9 = Qf.create,
  W9 = io.create,
  Q9 = ia.create,
  V9 = Lc.create,
  K9 = Fc.create,
  Z9 = us.create,
  J9 = jc.create,
  Y9 = _a.create,
  P_ = mr.create,
  X9 = si.create,
  e$ = so.create,
  t$ = mr.createWithPreprocess,
  n$ = gl.create,
  r$ = () => k3().optional(),
  i$ = () => P3().optional(),
  s$ = () => D3().optional(),
  o$ = {
    string: (e) => ur.create({ ...e, coerce: !0 }),
    number: (e) => os.create({ ...e, coerce: !0 }),
    boolean: (e) => Dc.create({ ...e, coerce: !0 }),
    bigint: (e) => as.create({ ...e, coerce: !0 }),
    date: (e) => ro.create({ ...e, coerce: !0 }),
  },
  a$ = le;
var _r = Object.freeze({
  __proto__: null,
  defaultErrorMap: kc,
  setErrorMap: d9,
  getErrorMap: Hf,
  makeIssue: zf,
  EMPTY_PATH: f9,
  addIssueToContext: K,
  ParseStatus: Xt,
  INVALID: le,
  DIRTY: S3,
  OK: on,
  isAborted: sg,
  isDirty: og,
  isValid: Pc,
  isAsync: Gf,
  get util() {
    return Pe;
  },
  get objectUtil() {
    return ig;
  },
  ZodParsedType: V,
  getParsedType: Li,
  ZodType: ye,
  ZodString: ur,
  ZodNumber: os,
  ZodBigInt: as,
  ZodBoolean: Dc,
  ZodDate: ro,
  ZodSymbol: qf,
  ZodUndefined: Oc,
  ZodNull: Rc,
  ZodAny: Ea,
  ZodUnknown: Gs,
  ZodNever: pi,
  ZodVoid: Wf,
  ZodArray: fr,
  ZodObject: Ze,
  ZodUnion: Bc,
  ZodDiscriminatedUnion: lp,
  ZodIntersection: Nc,
  ZodTuple: Br,
  ZodRecord: Mc,
  ZodMap: Qf,
  ZodSet: io,
  ZodFunction: ia,
  ZodLazy: Lc,
  ZodLiteral: Fc,
  ZodEnum: us,
  ZodNativeEnum: jc,
  ZodPromise: _a,
  ZodEffects: mr,
  ZodTransformer: mr,
  ZodOptional: si,
  ZodNullable: so,
  ZodDefault: Uc,
  ZodCatch: Vf,
  ZodNaN: Kf,
  BRAND: x9,
  ZodBranded: T3,
  ZodPipeline: gl,
  ZodReadonly: Zf,
  custom: I3,
  Schema: ye,
  ZodSchema: ye,
  late: S9,
  get ZodFirstPartyTypeKind() {
    return re;
  },
  coerce: o$,
  any: R9,
  array: L9,
  bigint: I9,
  boolean: D3,
  date: k9,
  discriminatedUnion: $9,
  effect: P_,
  enum: Z9,
  function: Q9,
  instanceof: C9,
  intersection: H9,
  lazy: V9,
  literal: K9,
  map: q9,
  nan: T9,
  nativeEnum: J9,
  never: N9,
  null: O9,
  nullable: e$,
  number: P3,
  object: F9,
  oboolean: s$,
  onumber: i$,
  optional: X9,
  ostring: r$,
  pipeline: n$,
  preprocess: t$,
  promise: Y9,
  record: G9,
  set: W9,
  strictObject: j9,
  string: k3,
  symbol: P9,
  transformer: P_,
  tuple: z9,
  undefined: D9,
  union: U9,
  unknown: B9,
  void: M9,
  NEVER: a$,
  ZodIssueCode: H,
  quotelessJson: l9,
  ZodError: dr,
});
const u$ = (e) => (e.message ? e.message : "unspecified error");
class Aa extends ue {
  constructor(t) {
    super(),
      (this.code = yj),
      (this.errors = t),
      (super.message = `Web3 validator found ${t.length} error[s]:
${this._compileErrors().join(`
`)}`);
  }
  _compileErrors() {
    return this.errors.map(u$);
  }
}
const c$ = ["bool", "int", "uint", "bytes", "string", "address", "tuple"],
  O3 = (e) => typeof e == "object" && "type" in e && "name" in e,
  Ob = (e) => typeof e == "string",
  De = (e) => typeof e == "string" && /^((-)?0x[0-9a-f]+|(0x))$/i.test(e);
function R3(e, t) {
  return !(
    typeof e != "string" ||
    !e.match(/^0x[0-9A-Fa-f]*$/) ||
    (typeof t < "u" && t > 0 && e.length !== 2 + 2 * t)
  );
}
const Rb = (e) =>
  typeof e == "number" ||
  typeof e == "bigint" ||
  (typeof e == "string" && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(e));
function Bb(e) {
  if (typeof e != "string")
    throw new Error(
      `[isHexPrefixed] input must be type 'string', received type ${typeof e}`
    );
  return e.startsWith("0x");
}
const Nb = function (e) {
    for (const [t, n] of Object.entries(e))
      if (n !== void 0 && n.length > 0 && n[0] === 0)
        throw new Error(
          `${t} cannot have leading zeroes, received: ${n.toString()}`
        );
  },
  l$ = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"],
  go = (e) => {
    let t = e.replace(/ /, ""),
      n,
      r = !1,
      i = [];
    if (
      (e.includes("[") &&
        ((t = t.slice(0, t.indexOf("["))),
        (i = [...e.matchAll(/(?:\[(\d*)\])/g)]
          .map((s) => parseInt(s[1], 10))
          .map((s) => (Number.isNaN(s) ? -1 : s))),
        (r = i.length > 0)),
      c$.includes(t))
    )
      return { baseType: t, isArray: r, baseTypeSize: n, arraySizes: i };
    if (t.startsWith("int")) (n = parseInt(t.substring(3), 10)), (t = "int");
    else if (t.startsWith("uint"))
      (n = parseInt(e.substring(4), 10)), (t = "uint");
    else if (t.startsWith("bytes"))
      (n = parseInt(t.substring(5), 10)), (t = "bytes");
    else
      return {
        baseType: void 0,
        isArray: !1,
        baseTypeSize: void 0,
        arraySizes: i,
      };
    return { baseType: t, isArray: r, baseTypeSize: n, arraySizes: i };
  },
  Um = (e, t = {}) => {
    if (Object.keys(t).includes("type"))
      throw new Aa([
        {
          keyword: "eth",
          message: 'Either "eth" or "type" can be presented in schema',
          params: { eth: e },
          instancePath: "",
          schemaPath: "",
        },
      ]);
    const { baseType: r, baseTypeSize: i } = go(e);
    if (!r && !l$.includes(e))
      throw new Aa([
        {
          keyword: "eth",
          message: `Eth data type "${e}" is not valid`,
          params: { eth: e },
          instancePath: "",
          schemaPath: "",
        },
      ]);
    if (r) {
      if (r === "tuple")
        throw new Error('"tuple" type is not implemented directly.');
      return { format: `${r}${i ?? ""}`, required: !0 };
    }
    return e ? { format: e, required: !0 } : {};
  },
  Jf = (e, t = "/0") => {
    const n = {
      type: "array",
      items: [],
      maxItems: e.length,
      minItems: e.length,
    };
    for (const [r, i] of e.entries()) {
      let s,
        o,
        a = [];
      O3(i)
        ? ((s = i.type), (o = i.name), (a = i.components))
        : typeof i == "string"
        ? ((s = i), (o = `${t}/${r}`))
        : Array.isArray(i) &&
          (i[0] &&
          typeof i[0] == "string" &&
          i[0].startsWith("tuple") &&
          !Array.isArray(i[0]) &&
          i[1] &&
          Array.isArray(i[1])
            ? ((s = i[0]), (o = `${t}/${r}`), (a = i[1]))
            : ((s = "tuple"), (o = `${t}/${r}`), (a = i)));
      const { baseType: u, isArray: l, arraySizes: c } = go(s);
      let d,
        f = n;
      for (let p = c.length - 1; p > 0; p -= 1)
        (d = { type: "array", items: [], maxItems: c[p], minItems: c[p] }),
          c[p] < 0 && (delete d.maxItems, delete d.minItems),
          Array.isArray(f.items)
            ? f.items.length === 0
              ? (f.items = d)
              : f.items.push(d)
            : (f.items = [f.items, d]),
          (f = d);
      if (u === "tuple" && !l) {
        const p = Jf(a, o);
        (p.$id = o), f.items.push(p);
      } else if (u === "tuple" && l) {
        const p = c[0],
          m = {
            $id: o,
            type: "array",
            items: Jf(a, o),
            maxItems: p,
            minItems: p,
          };
        p < 0 && (delete m.maxItems, delete m.minItems), f.items.push(m);
      } else if (l) {
        const p = c[0],
          m = {
            type: "array",
            $id: o,
            items: Um(String(u)),
            minItems: p,
            maxItems: p,
          };
        p < 0 && (delete m.maxItems, delete m.minItems), f.items.push(m);
      } else
        Array.isArray(f.items)
          ? f.items.push(Object.assign({ $id: o }, Um(s)))
          : f.items.items.push(Object.assign({ $id: o }, Um(s)));
      f = n;
    }
    return n;
  },
  Mb = (e) => Jf(e),
  Lb = (e, t) => (t === 1 ? e : Lb(e[0], t - 1)),
  $u = (e, t, n) => {
    const r = [];
    for (const [i, s] of e.entries()) {
      let o,
        a,
        u = [];
      O3(s)
        ? ((o = s.type), (a = s.name), (u = s.components))
        : typeof s == "string"
        ? (o = s)
        : Array.isArray(s) &&
          (s[1] && Array.isArray(s[1])
            ? ((o = s[0]), (u = s[1]))
            : ((o = "tuple"), (u = s)));
      const { baseType: l, isArray: c, arraySizes: d } = go(o),
        f = Array.isArray(t) ? t[i] : t[a];
      if (l === "tuple" && !c) r.push($u(u, f, n));
      else if (l === "tuple" && c) {
        const p = [];
        for (const m of f)
          if (d.length > 1) {
            const g = Lb(m, d.length - 1),
              w = [];
            for (const v of g) w.push($u(u, v, n));
            p.push(w);
          } else p.push($u(u, m, n));
        r.push(p);
      } else r.push(f);
    }
    return (n = n ?? []), n.push(...r), n;
  },
  B3 = (e) => {
    if (e >= 48 && e <= 57) return e - 48;
    if (e >= 65 && e <= 70) return e - 55;
    if (e >= 97 && e <= 102) return e - 87;
    throw new Error(`Invalid code point: ${e}`);
  },
  dp = (e) => {
    if (!De(e)) throw new Error("Invalid hex string");
    const [t, n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e],
      r = BigInt(n);
    return r > Number.MAX_SAFE_INTEGER
      ? t
        ? -r
        : r
      : r < Number.MIN_SAFE_INTEGER
      ? r
      : t
      ? -1 * Number(r)
      : Number(r);
  },
  fp = (e) => {
    if ((typeof e == "number" || typeof e == "bigint") && e < 0)
      return `-0x${e.toString(16).slice(1)}`;
    if ((typeof e == "number" || typeof e == "bigint") && e >= 0)
      return `0x${e.toString(16)}`;
    if (typeof e == "string" && De(e)) {
      const [t, n] = e.startsWith("-") ? [!0, e.slice(1)] : [!1, e],
        r = n.split(/^(-)?0(x|X)/).slice(-1)[0];
      return `${t ? "-" : ""}0x${r.replace(/^0+/, "").toLowerCase()}`;
    }
    if (typeof e == "string" && !De(e)) return fp(BigInt(e));
    throw new Ib(e);
  },
  Yf = (e, t, n = "0") => {
    if (typeof e == "string" && !De(e)) return e.padStart(t, n);
    const r = typeof e == "string" && De(e) ? e : fp(e),
      [i, s] = r.startsWith("-") ? ["-0x", r.slice(3)] : ["0x", r.slice(2)];
    return `${i}${s.padStart(t, n)}`;
  };
function vs(e) {
  let t = "0x";
  for (const n of e) {
    const r = n.toString(16);
    t += r.length === 1 ? `0${r}` : r;
  }
  return t;
}
function vo(e) {
  let t;
  if (
    (e.toLowerCase().startsWith("0x") ? (t = e.slice(2)) : (t = e),
    t.length % 2 !== 0)
  )
    throw new Uu(`hex string has odd length: ${e}`);
  const n = new Uint8Array(Math.ceil(t.length / 2));
  for (let r = 0; r < n.length; r += 1) {
    const i = parseInt(t.substring(r * 2, r * 2 + 2), 16);
    n[r] = i;
  }
  return n;
}
const N3 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        abiSchemaToJsonSchema: Jf,
        codePointToInt: B3,
        ethAbiToJsonSchema: Mb,
        fetchArrayElement: Lb,
        hexToNumber: dp,
        hexToUint8Array: vo,
        numberToHex: fp,
        padLeft: Yf,
        parseBaseType: go,
        transformJsonDataToAbiFormat: $u,
        uint8ArrayToHexString: vs,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  M3 = (e) => {
    if (!/^(0x)?[0-9a-f]{40}$/i.test(e)) return !1;
    const t = e.slice(2),
      n = wa(t.toLowerCase()),
      r = vs(Zt(n)).slice(2);
    for (let i = 0; i < 40; i += 1)
      if (
        (parseInt(r[i], 16) > 7 && t[i].toUpperCase() !== t[i]) ||
        (parseInt(r[i], 16) <= 7 && t[i].toLowerCase() !== t[i])
      )
        return !1;
    return !0;
  },
  er = (e, t = !0) => {
    if (typeof e != "string" && !(e instanceof Uint8Array)) return !1;
    let n;
    return (
      e instanceof Uint8Array
        ? (n = vs(e))
        : typeof e == "string" && !De(e)
        ? (n = e.toLowerCase().startsWith("0x") ? e : `0x${e}`)
        : (n = e),
      /^(0x)?[0-9a-f]{40}$/i.test(n)
        ? /^(0x|0X)?[0-9a-f]{40}$/.test(n) || /^(0x|0X)?[0-9A-F]{40}$/.test(n)
          ? !0
          : t
          ? M3(n)
          : !0
        : !1
    );
  };
var Kn;
(function (e) {
  (e.NUMBER = "NUMBER_NUMBER"),
    (e.HEX = "NUMBER_HEX"),
    (e.STR = "NUMBER_STR"),
    (e.BIGINT = "NUMBER_BIGINT");
})(Kn || (Kn = {}));
var mi;
(function (e) {
  (e.HEX = "BYTES_HEX"), (e.UINT8ARRAY = "BYTES_UINT8ARRAY");
})(mi || (mi = {}));
const Y = { number: Kn.BIGINT, bytes: mi.HEX },
  ae = { number: Kn.HEX, bytes: mi.HEX };
var Zr;
(function (e) {
  (e.EARLIEST = "earliest"),
    (e.LATEST = "latest"),
    (e.PENDING = "pending"),
    (e.SAFE = "safe"),
    (e.FINALIZED = "finalized");
})(Zr || (Zr = {}));
var Hu;
(function (e) {
  (e.chainstart = "chainstart"),
    (e.frontier = "frontier"),
    (e.homestead = "homestead"),
    (e.dao = "dao"),
    (e.tangerineWhistle = "tangerineWhistle"),
    (e.spuriousDragon = "spuriousDragon"),
    (e.byzantium = "byzantium"),
    (e.constantinople = "constantinople"),
    (e.petersburg = "petersburg"),
    (e.istanbul = "istanbul"),
    (e.muirGlacier = "muirGlacier"),
    (e.berlin = "berlin"),
    (e.london = "london"),
    (e.altair = "altair"),
    (e.arrowGlacier = "arrowGlacier"),
    (e.grayGlacier = "grayGlacier"),
    (e.bellatrix = "bellatrix"),
    (e.merge = "merge"),
    (e.capella = "capella"),
    (e.shanghai = "shanghai");
})(Hu || (Hu = {}));
const Fb = Object.getPrototypeOf(Uint8Array);
var D_ = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const O_ = Symbol.for("web3/base-provider");
class vl {
  static isWeb3Provider(t) {
    return t instanceof vl || !!(t && t[O_]);
  }
  get [O_]() {
    return !0;
  }
  send(t, n) {
    this.request(t)
      .then((r) => {
        n(null, r);
      })
      .catch((r) => {
        n(r);
      });
  }
  sendAsync(t) {
    return D_(this, void 0, void 0, function* () {
      return this.request(t);
    });
  }
  asEIP1193Provider() {
    const t = Object.create(this),
      n = t.request;
    return (
      (t.request = function (i) {
        return D_(this, void 0, void 0, function* () {
          return (yield n(i)).result;
        });
      }),
      (t.asEIP1193Provider = void 0),
      t
    );
  }
}
class d$ extends Array {
  constructor(t) {
    super(), (this._accountProvider = t);
  }
}
const $c = (e, t) => {
    let n = e;
    for (let r = 1; r < t; r += 1) n *= e;
    return n;
  },
  oo = (e, t = { abiType: "uint" }) => {
    if (
      !["number", "string", "bigint"].includes(typeof e) ||
      (typeof e == "string" && e.length === 0)
    )
      return !1;
    let n;
    if (t != null && t.abiType) {
      const { baseTypeSize: i } = go(t.abiType);
      i && (n = i);
    } else t.bitSize && (n = t.bitSize);
    const r = $c(BigInt(2), BigInt(n ?? 256)) - BigInt(1);
    try {
      const i = typeof e == "string" && De(e) ? BigInt(dp(e)) : BigInt(e);
      return i >= 0 && i <= r;
    } catch {
      return !1;
    }
  },
  hp = (e, t = { abiType: "int" }) => {
    if (
      !["number", "string", "bigint"].includes(typeof e) ||
      (typeof e == "number" && e > Number.MAX_SAFE_INTEGER)
    )
      return !1;
    let n;
    if (t != null && t.abiType) {
      const { baseTypeSize: s, baseType: o } = go(t.abiType);
      if (o !== "int") return !1;
      s && (n = s);
    } else t.bitSize && (n = t.bitSize);
    const r = $c(BigInt(2), BigInt((n ?? 256) - 1)),
      i = BigInt(-1) * $c(BigInt(2), BigInt((n ?? 256) - 1));
    try {
      const s = typeof e == "string" && De(e) ? BigInt(dp(e)) : BigInt(e);
      return s >= i && s <= r;
    } catch {
      return !1;
    }
  },
  L3 = (e) =>
    !!(
      hp(e) ||
      (typeof e == "string" &&
        /[0-9.]/.test(e) &&
        e.indexOf(".") === e.lastIndexOf(".")) ||
      typeof e == "number"
    ),
  F3 = (e) => oo(e),
  _t = (e) => Object.values(Zr).includes(e),
  ug = (e) => _t(e) || F3(e),
  qa = (e) =>
    typeof e != "string" || !/^(0x)?[0-9a-f]{512}$/i.test(e)
      ? !1
      : !!(/^(0x)?[0-9a-f]{512}$/.test(e) || /^(0x)?[0-9A-F]{512}$/.test(e)),
  pp = (e, t) => {
    if ((typeof t == "string" && !De(t)) || !qa(e)) return !1;
    const n = typeof t == "string" ? vo(t) : t,
      r = vs(Zt(n)).slice(2);
    for (let i = 0; i < 12; i += 4) {
      const s =
          ((parseInt(r.slice(i, i + 2), 16) << 8) +
            parseInt(r.slice(i + 2, i + 4), 16)) &
          2047,
        o = B3(e.charCodeAt(e.length - 1 - Math.floor(s / 4))),
        a = 1 << s % 4;
      if ((o & a) !== a) return !1;
    }
    return !0;
  },
  f$ = (e, t) => {
    if (!qa(e) || !er(t)) return !1;
    const n = Yf(t, 64);
    return pp(e, n);
  },
  h$ = (e, t) => (!qa(e) || !er(t) ? !1 : pp(e, t)),
  p$ = (e) =>
    ["number", "string", "boolean"].includes(typeof e)
      ? typeof e == "boolean"
        ? !0
        : typeof e == "string" && !De(e)
        ? e === "1" || e === "0"
        : typeof e == "string" && De(e)
        ? e === "0x1" || e === "0x0"
        : e === 1 || e === 0
      : !1,
  bs = (e, t = { abiType: "bytes" }) => {
    if (
      (typeof e != "string" &&
        !Array.isArray(e) &&
        !(e instanceof Uint8Array)) ||
      (typeof e == "string" && De(e) && e.startsWith("-")) ||
      (typeof e == "string" && !De(e))
    )
      return !1;
    let n;
    if (typeof e == "string") {
      if (e.length % 2 !== 0) return !1;
      n = vo(e);
    } else if (Array.isArray(e)) {
      if (e.some((r) => r < 0 || r > 255 || !Number.isInteger(r))) return !1;
      n = new Uint8Array(e);
    } else n = e;
    if (t != null && t.abiType) {
      const { baseTypeSize: r } = go(t.abiType);
      return r ? n.length === r : !0;
    }
    return t != null && t.size
      ? n.length === (t == null ? void 0 : t.size)
      : !0;
  },
  M = (e) => e == null,
  sa = (e) =>
    typeof e == "object" && !M(e) && !Array.isArray(e) && !(e instanceof Fb),
  Xf = (e) =>
    typeof e != "string" || !/^(0x)?[0-9a-f]{64}$/i.test(e)
      ? !1
      : !!(/^(0x)?[0-9a-f]{64}$/.test(e) || /^(0x)?[0-9A-F]{64}$/.test(e)),
  m$ = (e, t) => (!qa(e) || !Xf(t) ? !1 : pp(e, t)),
  y$ = (e) => {
    const t = ["fromBlock", "toBlock", "address", "topics", "blockHash"];
    if (
      M(e) ||
      typeof e != "object" ||
      !Object.keys(e).every((n) => t.includes(n)) ||
      (!M(e.fromBlock) && !ug(e.fromBlock)) ||
      (!M(e.toBlock) && !ug(e.toBlock))
    )
      return !1;
    if (!M(e.address)) {
      if (Array.isArray(e.address)) {
        if (!e.address.every((n) => er(n))) return !1;
      } else if (!er(e.address)) return !1;
    }
    return !(
      !M(e.topics) &&
      !e.topics.every((n) =>
        M(n) ? !0 : Array.isArray(n) ? n.every((r) => Xf(r)) : !!Xf(n)
      )
    );
  },
  ao = {
    address: (e) => er(e),
    bloom: (e) => qa(e),
    blockNumber: (e) => F3(e),
    blockTag: (e) => _t(e),
    blockNumberOrTag: (e) => ug(e),
    bool: (e) => p$(e),
    bytes: (e) => bs(e),
    filter: (e) => y$(e),
    hex: (e) => De(e),
    uint: (e) => oo(e),
    int: (e) => hp(e),
    number: (e) => L3(e),
    string: (e) => Ob(e),
  };
for (let e = 8; e <= 256; e += 8)
  (ao[`int${e}`] = (t) => hp(t, { bitSize: e })),
    (ao[`uint${e}`] = (t) => oo(t, { bitSize: e }));
for (let e = 1; e <= 32; e += 1) ao[`bytes${e}`] = (t) => bs(t, { size: e });
ao.bytes256 = ao.bytes;
const _u = (e) => {
  if (
    (!(e != null && e.type) || (e == null ? void 0 : e.type) === "object") &&
    e != null &&
    e.properties
  ) {
    const t = {};
    for (const n of Object.keys(e.properties)) {
      const r = _u(e.properties[n]);
      r && (t[n] = r);
    }
    return Array.isArray(e.required)
      ? _r
          .object(t)
          .partial()
          .required(
            e.required.reduce(
              (n, r) => Object.assign(Object.assign({}, n), { [r]: !0 }),
              {}
            )
          )
      : _r.object(t).partial();
  }
  if ((e == null ? void 0 : e.type) === "array" && e != null && e.items) {
    if (Array.isArray(e.items) && e.items.length > 0) {
      const t = [];
      for (const n of e.items) {
        const r = _u(n);
        r && t.push(r);
      }
      return _r.tuple(t);
    }
    return _r.array(_u(e.items));
  }
  if (e.oneOf && Array.isArray(e.oneOf))
    return _r.union(e.oneOf.map((t) => _u(t)));
  if (e != null && e.format) {
    if (!ao[e.format]) throw new SU(e.format);
    return _r
      .any()
      .refine(ao[e.format], (t) => ({
        params: { value: t, format: e.format },
      }));
  }
  return e != null &&
    e.type &&
    (e == null ? void 0 : e.type) !== "object" &&
    typeof _r[String(e.type)] == "function"
    ? _r[String(e.type)]()
    : _r.object({ data: _r.any() }).partial();
};
class Vo {
  static factory() {
    return (
      Vo.validatorInstance || (Vo.validatorInstance = new Vo()),
      Vo.validatorInstance
    );
  }
  validate(t, n, r) {
    var i, s;
    const a = _u(t).safeParse(n);
    if (!a.success) {
      const u = this.convertErrors(
        (s = (i = a.error) === null || i === void 0 ? void 0 : i.issues) !==
          null && s !== void 0
          ? s
          : []
      );
      if (u) {
        if (r != null && r.silent) return u;
        throw new Aa(u);
      }
    }
  }
  convertErrors(t) {
    if (t && Array.isArray(t) && t.length > 0)
      return t.map((n) => {
        var r;
        let i, s, o, a;
        a = n.path.join("/");
        const u = String(n.path[n.path.length - 1]),
          l = n.path.join("/");
        if (n.code === H.too_big)
          (s = "maxItems"),
            (a = `${l}/maxItems`),
            (o = { limit: n.maximum }),
            (i = `must NOT have more than ${n.maximum} items`);
        else if (n.code === H.too_small)
          (s = "minItems"),
            (a = `${l}/minItems`),
            (o = { limit: n.minimum }),
            (i = `must NOT have fewer than ${n.minimum} items`);
        else if (n.code === H.custom) {
          const { value: c, format: d } =
            (r = n.params) !== null && r !== void 0 ? r : {};
          typeof c > "u"
            ? (i = `value at "/${a}" is required`)
            : (i = `value "${
                typeof c == "object" ? JSON.stringify(c) : c
              }" at "/${a}" must pass "${d}" validation`),
            (o = { value: c });
        }
        return {
          keyword: s ?? u,
          instancePath: l ? `/${l}` : "",
          schemaPath: a ? `#${a}` : "#",
          params: o ?? { value: n.message },
          message: i ?? n.message,
        };
      });
  }
}
class g$ {
  constructor() {
    this._validator = Vo.factory();
  }
  validateJSONSchema(t, n, r) {
    return this._validator.validate(t, n, r);
  }
  validate(t, n, r = { silent: !1 }) {
    var i, s;
    const o = Mb(t);
    if (
      !(
        Array.isArray(o.items) &&
        ((i = o.items) === null || i === void 0 ? void 0 : i.length) === 0 &&
        n.length === 0
      )
    ) {
      if (
        Array.isArray(o.items) &&
        ((s = o.items) === null || s === void 0 ? void 0 : s.length) === 0 &&
        n.length !== 0
      )
        throw new Aa([
          {
            instancePath: "/0",
            schemaPath: "/",
            keyword: "required",
            message: "empty schema against data can not be validated",
            params: n,
          },
        ]);
      return this._validator.validate(o, n, r);
    }
  }
}
const ie = new g$(),
  jb = {
    noether: BigInt(0),
    wei: BigInt(1),
    kwei: BigInt(1e3),
    Kwei: BigInt(1e3),
    babbage: BigInt(1e3),
    femtoether: BigInt(1e3),
    mwei: BigInt(1e6),
    Mwei: BigInt(1e6),
    lovelace: BigInt(1e6),
    picoether: BigInt(1e6),
    gwei: BigInt(1e9),
    Gwei: BigInt(1e9),
    shannon: BigInt(1e9),
    nanoether: BigInt(1e9),
    nano: BigInt(1e9),
    szabo: BigInt(1e12),
    microether: BigInt(1e12),
    micro: BigInt(1e12),
    finney: BigInt(1e15),
    milliether: BigInt(1e15),
    milli: BigInt(1e15),
    ether: BigInt("1000000000000000000"),
    kether: BigInt("1000000000000000000000"),
    grand: BigInt("1000000000000000000000"),
    mether: BigInt("1000000000000000000000000"),
    gether: BigInt("1000000000000000000000000000"),
    tether: BigInt("1000000000000000000000000000000"),
  },
  Nr = (e) => {
    if ((ie.validate(["bytes"], [e]), e instanceof Uint8Array)) return e;
    if (Array.isArray(e)) return new Uint8Array(e);
    if (typeof e == "string") return vo(e);
    throw new Uu(e);
  },
  { uint8ArrayToHexString: v$ } = N3,
  ve = (e) => v$(Nr(e)),
  He = (e) =>
    typeof e == "string" && e.slice(0, 2).toLowerCase() !== "0x"
      ? Nr(`0x${e}`)
      : Nr(e),
  bl = (e) => (ie.validate(["hex"], [e]), dp(e)),
  b$ = bl,
  kn = (e, t) => {
    typeof e != "bigint" && ie.validate(["int"], [e]);
    let n = fp(e);
    return (
      t &&
        (!n.startsWith("-") && n.length % 2 === 1
          ? (n = "0x0".concat(n.slice(2)))
          : n.length % 2 === 0 &&
            n.startsWith("-") &&
            (n = "-0x0".concat(n.slice(3)))),
      n
    );
  },
  w$ = kn,
  E$ = (e) => bl(e).toString(),
  yr = (e) => {
    ie.validate(["string"], [e]);
    let t = e.replace(/^(?:\u0000)/, "");
    return (t = t.replace(/(?:\u0000)$/, "")), ve(new TextEncoder().encode(t));
  },
  j3 = yr,
  _$ = yr,
  mp = (e) => A3(He(e)),
  A$ = (e) =>
    typeof e == "string" ? mp(e) : (ie.validate(["bytes"], [e]), A3(e)),
  Ub = wa,
  x$ = mp,
  U3 = (e) => {
    ie.validate(["string"], [e]);
    let t = "";
    for (let n = 0; n < e.length; n += 1) {
      const r = e.charCodeAt(n).toString(16);
      t += r.length % 2 !== 0 ? `0${r}` : r;
    }
    return `0x${t}`;
  },
  S$ = U3,
  $3 = (e) => new TextDecoder("ascii").decode(He(e)),
  C$ = $3,
  cs = (e, t) => {
    if (typeof e == "string" && er(e))
      return t ? "address" : `0x${e.toLowerCase().replace(/^0x/i, "")}`;
    if (typeof e == "boolean") return t ? "bool" : e ? "0x01" : "0x00";
    if (typeof e == "number") return t ? (e < 0 ? "int256" : "uint256") : kn(e);
    if (typeof e == "bigint") return t ? "bigint" : kn(e);
    if (typeof e == "object" && e) return t ? "string" : yr(JSON.stringify(e));
    if (typeof e == "string") {
      if (e.startsWith("-0x") || e.startsWith("-0X"))
        return t ? "int256" : kn(e);
      if (De(e)) return t ? "bytes" : e;
      if (Rb(e) && !hp(e)) return t ? "bytes" : `0x${e}`;
      if (!Number.isFinite(e)) return t ? "string" : yr(e);
    }
    throw new uU(e);
  },
  yn = (e) => {
    if (typeof e == "number") return e;
    if (typeof e == "bigint")
      return e >= Number.MIN_SAFE_INTEGER && e <= Number.MAX_SAFE_INTEGER
        ? Number(e)
        : e;
    if (typeof e == "string" && De(e)) return bl(e);
    try {
      return yn(BigInt(e));
    } catch {
      throw new Ib(e);
    }
  },
  Bs = (e) => {
    if (typeof e == "number") return BigInt(e);
    if (typeof e == "bigint") return e;
    if (typeof e == "string" && Rb(e))
      return e.startsWith("-") ? -BigInt(e.substring(1)) : BigInt(e);
    throw new Ib(e);
  },
  T$ = (e, t) => {
    const n = jb[t];
    if (!n) throw new d3(t);
    const r = String(yn(e)),
      i = n.toString().length - 1;
    if (i <= 0) return r.toString();
    const s = r.padStart(i, "0"),
      o = s.slice(0, -i),
      a = s.slice(-i).replace(/\.?0+$/, "");
    return o === "" ? `0.${a}` : a === "" ? o : `${o}.${a}`;
  },
  I$ = (e, t) => {
    ie.validate(["number"], [e]);
    const n = jb[t];
    if (!n) throw new d3(t);
    const [r, i] = String(typeof e == "string" && !De(e) ? e : yn(e))
        .split(".")
        .concat(""),
      o = BigInt(`${r}${i}`) * n,
      a = n.toString().length - 1,
      u = Math.min(i.length, a);
    return u === 0 ? o.toString() : o.toString().padStart(u, "0").slice(0, -u);
  },
  Lr = (e) => {
    if (!er(e, !1)) throw new kb(e);
    const t = e.toLowerCase().replace(/^0x/i, ""),
      n = vs(Zt(Ub(t)));
    if (
      M(n) ||
      n === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"
    )
      return "";
    let r = "0x";
    const i = n.replace(/^0x/i, "");
    for (let s = 0; s < t.length; s += 1)
      parseInt(i[s], 16) > 7 ? (r += t[s].toUpperCase()) : (r += t[s]);
    return r;
  },
  H3 = (e) => {
    if (typeof e == "boolean") return e;
    if (
      (typeof e == "number" && (e === 0 || e === 1)) ||
      (typeof e == "bigint" && (e === BigInt(0) || e === BigInt(1)))
    )
      return !!e;
    if (
      typeof e == "string" &&
      !De(e) &&
      (e === "1" || e === "0" || e === "false" || e === "true")
    )
      return e === "true" ? !0 : e === "false" ? !1 : !!Number(e);
    if (typeof e == "string" && De(e) && (e === "0x1" || e === "0x0"))
      return !!yn(e);
    throw new Pb(e);
  };
var $b = { exports: {} },
  oa = typeof Reflect == "object" ? Reflect : null,
  R_ =
    oa && typeof oa.apply == "function"
      ? oa.apply
      : function (t, n, r) {
          return Function.prototype.apply.call(t, n, r);
        },
  Dd;
oa && typeof oa.ownKeys == "function"
  ? (Dd = oa.ownKeys)
  : Object.getOwnPropertySymbols
  ? (Dd = function (t) {
      return Object.getOwnPropertyNames(t).concat(
        Object.getOwnPropertySymbols(t)
      );
    })
  : (Dd = function (t) {
      return Object.getOwnPropertyNames(t);
    });
function k$(e) {
  console && console.warn && console.warn(e);
}
var z3 =
  Number.isNaN ||
  function (t) {
    return t !== t;
  };
function Le() {
  Le.init.call(this);
}
$b.exports = Le;
$b.exports.once = R$;
Le.EventEmitter = Le;
Le.prototype._events = void 0;
Le.prototype._eventsCount = 0;
Le.prototype._maxListeners = void 0;
var B_ = 10;
function yp(e) {
  if (typeof e != "function")
    throw new TypeError(
      'The "listener" argument must be of type Function. Received type ' +
        typeof e
    );
}
Object.defineProperty(Le, "defaultMaxListeners", {
  enumerable: !0,
  get: function () {
    return B_;
  },
  set: function (e) {
    if (typeof e != "number" || e < 0 || z3(e))
      throw new RangeError(
        'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
          e +
          "."
      );
    B_ = e;
  },
});
Le.init = function () {
  (this._events === void 0 ||
    this._events === Object.getPrototypeOf(this)._events) &&
    ((this._events = Object.create(null)), (this._eventsCount = 0)),
    (this._maxListeners = this._maxListeners || void 0);
};
Le.prototype.setMaxListeners = function (t) {
  if (typeof t != "number" || t < 0 || z3(t))
    throw new RangeError(
      'The value of "n" is out of range. It must be a non-negative number. Received ' +
        t +
        "."
    );
  return (this._maxListeners = t), this;
};
function G3(e) {
  return e._maxListeners === void 0 ? Le.defaultMaxListeners : e._maxListeners;
}
Le.prototype.getMaxListeners = function () {
  return G3(this);
};
Le.prototype.emit = function (t) {
  for (var n = [], r = 1; r < arguments.length; r++) n.push(arguments[r]);
  var i = t === "error",
    s = this._events;
  if (s !== void 0) i = i && s.error === void 0;
  else if (!i) return !1;
  if (i) {
    var o;
    if ((n.length > 0 && (o = n[0]), o instanceof Error)) throw o;
    var a = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
    throw ((a.context = o), a);
  }
  var u = s[t];
  if (u === void 0) return !1;
  if (typeof u == "function") R_(u, this, n);
  else
    for (var l = u.length, c = K3(u, l), r = 0; r < l; ++r) R_(c[r], this, n);
  return !0;
};
function q3(e, t, n, r) {
  var i, s, o;
  if (
    (yp(n),
    (s = e._events),
    s === void 0
      ? ((s = e._events = Object.create(null)), (e._eventsCount = 0))
      : (s.newListener !== void 0 &&
          (e.emit("newListener", t, n.listener ? n.listener : n),
          (s = e._events)),
        (o = s[t])),
    o === void 0)
  )
    (o = s[t] = n), ++e._eventsCount;
  else if (
    (typeof o == "function"
      ? (o = s[t] = r ? [n, o] : [o, n])
      : r
      ? o.unshift(n)
      : o.push(n),
    (i = G3(e)),
    i > 0 && o.length > i && !o.warned)
  ) {
    o.warned = !0;
    var a = new Error(
      "Possible EventEmitter memory leak detected. " +
        o.length +
        " " +
        String(t) +
        " listeners added. Use emitter.setMaxListeners() to increase limit"
    );
    (a.name = "MaxListenersExceededWarning"),
      (a.emitter = e),
      (a.type = t),
      (a.count = o.length),
      k$(a);
  }
  return e;
}
Le.prototype.addListener = function (t, n) {
  return q3(this, t, n, !1);
};
Le.prototype.on = Le.prototype.addListener;
Le.prototype.prependListener = function (t, n) {
  return q3(this, t, n, !0);
};
function P$() {
  if (!this.fired)
    return (
      this.target.removeListener(this.type, this.wrapFn),
      (this.fired = !0),
      arguments.length === 0
        ? this.listener.call(this.target)
        : this.listener.apply(this.target, arguments)
    );
}
function W3(e, t, n) {
  var r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: n },
    i = P$.bind(r);
  return (i.listener = n), (r.wrapFn = i), i;
}
Le.prototype.once = function (t, n) {
  return yp(n), this.on(t, W3(this, t, n)), this;
};
Le.prototype.prependOnceListener = function (t, n) {
  return yp(n), this.prependListener(t, W3(this, t, n)), this;
};
Le.prototype.removeListener = function (t, n) {
  var r, i, s, o, a;
  if ((yp(n), (i = this._events), i === void 0)) return this;
  if (((r = i[t]), r === void 0)) return this;
  if (r === n || r.listener === n)
    --this._eventsCount === 0
      ? (this._events = Object.create(null))
      : (delete i[t],
        i.removeListener && this.emit("removeListener", t, r.listener || n));
  else if (typeof r != "function") {
    for (s = -1, o = r.length - 1; o >= 0; o--)
      if (r[o] === n || r[o].listener === n) {
        (a = r[o].listener), (s = o);
        break;
      }
    if (s < 0) return this;
    s === 0 ? r.shift() : D$(r, s),
      r.length === 1 && (i[t] = r[0]),
      i.removeListener !== void 0 && this.emit("removeListener", t, a || n);
  }
  return this;
};
Le.prototype.off = Le.prototype.removeListener;
Le.prototype.removeAllListeners = function (t) {
  var n, r, i;
  if (((r = this._events), r === void 0)) return this;
  if (r.removeListener === void 0)
    return (
      arguments.length === 0
        ? ((this._events = Object.create(null)), (this._eventsCount = 0))
        : r[t] !== void 0 &&
          (--this._eventsCount === 0
            ? (this._events = Object.create(null))
            : delete r[t]),
      this
    );
  if (arguments.length === 0) {
    var s = Object.keys(r),
      o;
    for (i = 0; i < s.length; ++i)
      (o = s[i]), o !== "removeListener" && this.removeAllListeners(o);
    return (
      this.removeAllListeners("removeListener"),
      (this._events = Object.create(null)),
      (this._eventsCount = 0),
      this
    );
  }
  if (((n = r[t]), typeof n == "function")) this.removeListener(t, n);
  else if (n !== void 0)
    for (i = n.length - 1; i >= 0; i--) this.removeListener(t, n[i]);
  return this;
};
function Q3(e, t, n) {
  var r = e._events;
  if (r === void 0) return [];
  var i = r[t];
  return i === void 0
    ? []
    : typeof i == "function"
    ? n
      ? [i.listener || i]
      : [i]
    : n
    ? O$(i)
    : K3(i, i.length);
}
Le.prototype.listeners = function (t) {
  return Q3(this, t, !0);
};
Le.prototype.rawListeners = function (t) {
  return Q3(this, t, !1);
};
Le.listenerCount = function (e, t) {
  return typeof e.listenerCount == "function"
    ? e.listenerCount(t)
    : V3.call(e, t);
};
Le.prototype.listenerCount = V3;
function V3(e) {
  var t = this._events;
  if (t !== void 0) {
    var n = t[e];
    if (typeof n == "function") return 1;
    if (n !== void 0) return n.length;
  }
  return 0;
}
Le.prototype.eventNames = function () {
  return this._eventsCount > 0 ? Dd(this._events) : [];
};
function K3(e, t) {
  for (var n = new Array(t), r = 0; r < t; ++r) n[r] = e[r];
  return n;
}
function D$(e, t) {
  for (; t + 1 < e.length; t++) e[t] = e[t + 1];
  e.pop();
}
function O$(e) {
  for (var t = new Array(e.length), n = 0; n < t.length; ++n)
    t[n] = e[n].listener || e[n];
  return t;
}
function R$(e, t) {
  return new Promise(function (n, r) {
    function i(o) {
      e.removeListener(t, s), r(o);
    }
    function s() {
      typeof e.removeListener == "function" && e.removeListener("error", i),
        n([].slice.call(arguments));
    }
    Z3(e, t, s, { once: !0 }), t !== "error" && B$(e, i, { once: !0 });
  });
}
function B$(e, t, n) {
  typeof e.on == "function" && Z3(e, "error", t, n);
}
function Z3(e, t, n, r) {
  if (typeof e.on == "function") r.once ? e.once(t, n) : e.on(t, n);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function i(s) {
      r.once && e.removeEventListener(t, i), n(s);
    });
  else
    throw new TypeError(
      'The "emitter" argument must be of type EventEmitter. Received type ' +
        typeof e
    );
}
var Hb = $b.exports;
const lK = Xc(Hb);
var N$ = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const M$ = (e) => (t) => e(t.detail);
class L$ extends EventTarget {
  constructor() {
    super(...arguments),
      (this._listeners = {}),
      (this.maxListeners = Number.MAX_SAFE_INTEGER);
  }
  on(t, n) {
    return this.addEventListener(t, n), this;
  }
  once(t, n) {
    const r = (i) =>
      N$(this, void 0, void 0, function* () {
        this.off(t, r), yield n(i);
      });
    return this.on(t, r);
  }
  off(t, n) {
    return this.removeEventListener(t, n), this;
  }
  emit(t, n) {
    const r = new CustomEvent(t, { detail: n });
    return super.dispatchEvent(r);
  }
  listenerCount(t) {
    const n = this._listeners[t];
    return n ? n.length : 0;
  }
  listeners(t) {
    return this._listeners[t].map((n) => n[0]) || [];
  }
  eventNames() {
    return Object.keys(this._listeners);
  }
  removeAllListeners() {
    return (
      Object.keys(this._listeners).forEach((t) => {
        this._listeners[t].forEach((n) => {
          super.removeEventListener(t, n[1]);
        });
      }),
      (this._listeners = {}),
      this
    );
  }
  setMaxListeners(t) {
    return (this.maxListeners = t), this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
  addEventListener(t, n) {
    const r = M$(n);
    super.addEventListener(t, r),
      this._listeners[t] || (this._listeners[t] = []),
      this._listeners[t].push([n, r]);
  }
  removeEventListener(t, n) {
    const r = this._listeners[t];
    if (r) {
      const i = r.findIndex((s) => s[0] === n);
      i !== -1 && (super.removeEventListener(t, r[i][1]), r.splice(i, 1));
    }
  }
}
let cg;
typeof window > "u" ? (cg = Hb.EventEmitter) : (cg = L$);
class zb extends cg {}
const F$ = De,
  j$ = Rb,
  U$ = M3,
  $$ = er,
  H$ = qa,
  z$ = pp,
  G$ = f$,
  q$ = h$,
  W$ = Xf,
  Q$ = m$,
  V$ = (e, t) => {
    const n = typeof e == "string" && _t(e),
      r = typeof t == "string" && _t(t);
    if (
      e === t ||
      ((e === "earliest" || e === 0) && (t === "earliest" || t === 0))
    )
      return 0;
    if (e === "earliest" && t > 0) return -1;
    if (t === "earliest" && e > 0) return 1;
    if (n && r) {
      const o = {
        [Zr.EARLIEST]: 1,
        [Zr.FINALIZED]: 2,
        [Zr.SAFE]: 3,
        [Zr.LATEST]: 4,
        [Zr.PENDING]: 5,
      };
      return o[e] < o[t] ? -1 : 1;
    }
    if ((n && !r) || (!n && r))
      throw new lU("Cannot compare blocktag with provided non-blocktag input.");
    const i = BigInt(e),
      s = BigInt(t);
    return i < s ? -1 : i === s ? 0 : 1;
  },
  $i = (e) =>
    typeof e == "object" &&
    !M(e) &&
    Object.keys(e).length !== 0 &&
    [
      "input",
      "data",
      "from",
      "gas",
      "gasPrice",
      "gasLimit",
      "address",
      "jsonInterface",
      "syncWithContext",
      "dataInputFill",
    ].some((t) => t in e),
  ce = M,
  N_ = (e) =>
    typeof e == "object" && !M(e) && !Array.isArray(e) && !(e instanceof Fb),
  ws = (e, ...t) => {
    const n = e;
    if (!N_(n)) return n;
    for (const r of t)
      for (const i in r)
        N_(r[i])
          ? (n[i] || (n[i] = {}), ws(n[i], r[i]))
          : !M(r[i]) &&
            Object.hasOwnProperty.call(r, i) &&
            (Array.isArray(r[i]) || r[i] instanceof Fb
              ? (n[i] = r[i].slice(0))
              : (n[i] = r[i]));
    return n;
  },
  xa = (e, t, n = "0") =>
    typeof e == "string"
      ? De(e)
        ? Yf(e, t, n)
        : e.padStart(t, n)
      : (ie.validate(["int"], [e]), Yf(e, t, n)),
  J3 = (e, t, n = "0") => {
    if (typeof e == "string" && !De(e)) return e.padEnd(t, n);
    ie.validate(["int"], [e]);
    const r = typeof e == "string" && De(e) ? e : kn(e),
      i = r.startsWith("-") ? 3 : 2;
    return r.padEnd(t + i, n);
  },
  Y3 = J3,
  Hc = xa,
  X3 = (e, t = 64) => {
    ie.validate(["int"], [e]);
    const n = yn(e);
    if (n >= 0) return xa(cs(n), t);
    const r = $c(BigInt(2), BigInt(t * 4));
    if (-n >= r) throw new f3(`value: ${e}, nibbleWidth: ${t}`);
    const s = BigInt(n) + r;
    return xa(kn(s), t);
  },
  K$ = (e, t = 64) => {
    ie.validate(["int"], [e]);
    const n = yn(e);
    if (n < 0) return n;
    const r = Math.ceil(Math.log(Number(n)) / Math.log(2));
    if (r > t * 4) throw new f3(`value: "${e}", nibbleWidth: "${t}"`);
    if (t * 4 !== r) return n;
    const i = $c(BigInt(2), BigInt(t) * BigInt(4));
    return yn(BigInt(n) - i);
  };
function an(...e) {
  const t = e.reduce((i, s) => i + s.length, 0),
    n = new Uint8Array(t);
  let r = 0;
  for (const i of e) n.set(i, r), (r += i.length);
  return n;
}
function gp(e, t) {
  if (e === t) return !0;
  if (e.byteLength !== t.byteLength) return !1;
  for (let n = 0; n < e.byteLength; n += 1) if (e[n] !== t[n]) return !1;
  return !0;
}
const { parseBaseType: Z$ } = N3,
  Qr = (e) => typeof e == "object" && !M(e) && "number" in e && "bytes" in e,
  J$ = (e, t, n = []) => {
    let r = Object.assign({}, e),
      i;
    for (const s of t) {
      if (r.oneOf && i) {
        const o = n.find(function (a) {
          return this === a[0];
        }, i ?? "");
        o && o[0] === i && (r = r.oneOf[o[1]]);
      }
      if (!r.properties && !r.items) return;
      if (r.properties) r = r.properties[s];
      else if (r.items && r.items.properties) {
        const o = r.items.properties;
        if (!o) return;
        r = o[s];
      } else
        r.items && sa(r.items)
          ? (r = r.items)
          : r.items && Array.isArray(r.items) && (r = r.items[parseInt(s, 10)]);
      r && s && (i = s);
    }
    return r;
  },
  Au = (e, t, n) => {
    try {
      const { baseType: r, baseTypeSize: i } = Z$(t);
      if (r === "int" || r === "uint")
        switch (n.number) {
          case Kn.NUMBER:
            return Number(Bs(e));
          case Kn.HEX:
            return kn(Bs(e));
          case Kn.STR:
            return Bs(e).toString();
          case Kn.BIGINT:
            return Bs(e);
          default:
            throw new Xy(`Invalid format: ${String(n.number)}`);
        }
      if (r === "bytes") {
        let s;
        switch (
          (i
            ? typeof e == "string"
              ? (s = xa(e, i * 2))
              : e instanceof Uint8Array &&
                (s = an(new Uint8Array(i - e.length), e))
            : (s = e),
          n.bytes)
        ) {
          case mi.HEX:
            return ve(Nr(s));
          case mi.UINT8ARRAY:
            return Nr(s);
          default:
            throw new Xy(`Invalid format: ${String(n.bytes)}`);
        }
      }
    } catch {
      return e;
    }
    return e;
  },
  eh = (e, t, n, r, i = []) => {
    var s, o;
    if (!sa(e) && !Array.isArray(e))
      return Au(e, t == null ? void 0 : t.format, r);
    const a = e;
    for (const [u, l] of Object.entries(a)) {
      n.push(u);
      const c = J$(t, n, i);
      if (M(c)) {
        delete a[u], n.pop();
        continue;
      }
      if (sa(l)) {
        eh(l, t, n, r), n.pop();
        continue;
      }
      if (Array.isArray(l)) {
        let d = c;
        if (
          ((c == null ? void 0 : c.oneOf) !== void 0 &&
            c.oneOf.forEach((f, p) => {
              var m, g;
              !Array.isArray(c == null ? void 0 : c.items) &&
                ((typeof l[0] == "object" &&
                  ((m = f == null ? void 0 : f.items) === null || m === void 0
                    ? void 0
                    : m.type) === "object") ||
                  (typeof l[0] == "string" &&
                    ((g = f == null ? void 0 : f.items) === null || g === void 0
                      ? void 0
                      : g.type) !== "object")) &&
                ((d = f), i.push([u, p]));
            }),
          M(d == null ? void 0 : d.items))
        ) {
          delete a[u], n.pop();
          continue;
        }
        if (sa(d.items) && !M(d.items.format)) {
          for (let f = 0; f < l.length; f += 1)
            a[u][f] = Au(
              l[f],
              (s = d == null ? void 0 : d.items) === null || s === void 0
                ? void 0
                : s.format,
              r
            );
          n.pop();
          continue;
        }
        if (
          !Array.isArray(d == null ? void 0 : d.items) &&
          ((o = d == null ? void 0 : d.items) === null || o === void 0
            ? void 0
            : o.type) === "object"
        ) {
          for (const f of l) eh(f, t, n, r, i);
          n.pop();
          continue;
        }
        if (Array.isArray(d == null ? void 0 : d.items)) {
          for (let f = 0; f < l.length; f += 1)
            a[u][f] = Au(l[f], d.items[f].format, r);
          n.pop();
          continue;
        }
      }
      (a[u] = Au(l, c.format, r)), n.pop();
    }
    return a;
  },
  $ = (e, t, n) => {
    let r;
    sa(t) ? (r = ws({}, t)) : Array.isArray(t) ? (r = [...t]) : (r = t);
    const i = sa(e) ? e : Mb(e);
    if (!i.properties && !i.items && !i.format)
      throw new Xy("Invalid json schema for formatting");
    return eh(r, i, [], n);
  },
  eT = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
  wl = (e) => {
    let t;
    typeof e == "string"
      ? e.startsWith("0x") && De(e)
        ? (t = He(e))
        : (t = wa(e))
      : (t = e);
    const n = ve(Zt(t));
    return n === eT ? void 0 : n;
  },
  On = (e) => {
    const t = wl(e);
    return M(t) ? eT : t;
  },
  zc = (e) => {
    let t;
    return (
      typeof e == "bigint" || typeof e == "number"
        ? (t = wa(e.toString()))
        : Array.isArray(e)
        ? (t = new Uint8Array(e))
        : typeof e == "string" && !De(e)
        ? (t = wa(e))
        : (t = Nr(e)),
      ve(Zt(t))
    );
  },
  Y$ = (e) => {
    if (Array.isArray(e))
      throw new Error("Autodetection of array types is not supported.");
    let t, n;
    if (
      typeof e == "object" &&
      ("t" in e || "type" in e) &&
      ("v" in e || "value" in e)
    )
      (t = "t" in e ? e.t : e.type),
        (n = "v" in e ? e.v : e.value),
        (t = t.toLowerCase() === "bigint" ? "int" : t);
    else {
      if (typeof e == "bigint") return ["int", e];
      (t = cs(e, !0)),
        (n = cs(e)),
        !t.startsWith("int") && !t.startsWith("uint") && (t = "bytes");
    }
    return (
      (t.startsWith("int") || t.startsWith("uint")) &&
        typeof n == "string" &&
        !/^(-)?0x/i.test(n) &&
        (n = Bs(n)),
      [t, n]
    );
  },
  X$ = (e) =>
    e.startsWith("int[")
      ? `int256${e.slice(3)}`
      : e === "int"
      ? "int256"
      : e.startsWith("uint[")
      ? `uint256'${e.slice(4)}`
      : e === "uint"
      ? "uint256"
      : e,
  $m = (e, t) => {
    const n = /^(\d+).*$/.exec(e.slice(t));
    return n ? parseInt(n[1], 10) : 0;
  },
  M_ = (e) => e.toString(2).length,
  L_ = (e, t) => {
    const n = t.toString();
    if (e === "string") {
      if (typeof t == "string") return yr(t);
      throw new aU(t);
    }
    if (e === "bool" || e === "boolean") {
      if (typeof t == "boolean") return t ? "01" : "00";
      throw new Pb(t);
    }
    if (e === "address") {
      if (!er(n)) throw new kb(n);
      return n;
    }
    const r = X$(e);
    if (e.startsWith("uint")) {
      const i = $m(r, 4);
      if (i % 8 || i < 8 || i > 256) throw new E_(n);
      const s = yn(n);
      if (M_(s) > i) throw new __(n);
      if (s < BigInt(0)) throw new cU(n);
      return i ? Hc(s.toString(16), (i / 8) * 2) : s.toString(16);
    }
    if (e.startsWith("int")) {
      const i = $m(r, 3);
      if (i % 8 || i < 8 || i > 256) throw new E_(e);
      const s = yn(n);
      if (M_(s) > i) throw new __(n);
      return s < BigInt(0)
        ? X3(s.toString(), (i / 8) * 2)
        : i
        ? Hc(s.toString(16), i / 4)
        : s.toString(16);
    }
    if (r === "bytes") {
      if (n.replace(/^0x/i, "").length % 2 !== 0) throw new Uu(n);
      return n;
    }
    if (e.startsWith("bytes")) {
      if (n.replace(/^0x/i, "").length % 2 !== 0) throw new Uu(n);
      const i = $m(e, 5);
      if (!i || i < 1 || i > 64 || i < n.replace(/^0x/i, "").length / 2)
        throw new Uu(n);
      return Y3(n, i * 2);
    }
    return "";
  },
  tT = (e) => {
    const [t, n] = Y$(e);
    return Array.isArray(n)
      ? n.map((s) => L_(t, s).replace("0x", "")).join("")
      : L_(t, n).replace("0x", "");
  },
  Gb = (...e) => `0x${e.map(tT).join("").toLowerCase()}`,
  eH = (...e) => wl(Gb(...e)),
  tH = (...e) => On(Gb(...e)),
  nH = (e) =>
    wl(`0x${(typeof e == "number" ? e.toString() : e).padStart(64, "0")}`);
function rH(e) {
  return v3(e);
}
const Gc = (e) => rH(e),
  iH = (e) => ve(Gc(e));
var vp = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function nT(e) {
  return (
    (typeof e == "object" || typeof e == "function") &&
    typeof e.then == "function"
  );
}
function rT(e, t, n) {
  return vp(this, void 0, void 0, function* () {
    let r;
    const i = yield Promise.race([
      e instanceof Promise ? e : e(),
      new Promise((s, o) => {
        r = setTimeout(() => (n ? o(n) : s(void 0)), t);
      }),
    ]);
    if ((r && clearTimeout(r), i instanceof Error)) throw i;
    return i;
  });
}
function qb(e, t) {
  let n;
  return [
    new Promise((i, s) => {
      n = setInterval(
        (function o() {
          return (
            vp(this, void 0, void 0, function* () {
              try {
                const a = yield rT(e, t);
                M(a) || (clearInterval(n), i(a));
              } catch (a) {
                clearInterval(n), s(a);
              }
            }),
            o
          );
        })(),
        t
      );
    }),
    n,
  ];
}
function sH(e, t) {
  return vp(this, void 0, void 0, function* () {
    return qb(e, t)[0];
  });
}
function Wb(e, t) {
  let n;
  const r = new Promise((i, s) => {
    n = setTimeout(() => {
      s(t);
    }, e);
  });
  return [n, r];
}
function iT(e, t) {
  let n;
  const r = new Promise((i, s) => {
    n = setInterval(() => {
      vp(this, void 0, void 0, function* () {
        const o = yield e();
        o && (clearInterval(n), s(o));
      });
    }, t);
  });
  return [n, r];
}
const Qb = () => {
    const e = Gc(16);
    (e[6] = (e[6] & 15) | 64), (e[8] = (e[8] & 63) | 128);
    const t = ve(e);
    return [
      t.substring(2, 10),
      t.substring(10, 14),
      t.substring(14, 18),
      t.substring(18, 22),
      t.substring(22, 34),
    ].join("-");
  },
  Vb = (e) => {
    const t = e.error.code;
    return sn.has(t) || (t >= -32099 && t <= -32e3);
  },
  ei = (e) =>
    !Array.isArray(e) &&
    !!e &&
    e.jsonrpc === "2.0" &&
    "result" in e &&
    M(e.error) &&
    (typeof e.id == "number" || typeof e.id == "string"),
  ti = (e) =>
    !Array.isArray(e) &&
    e.jsonrpc === "2.0" &&
    !!e &&
    M(e.result) &&
    "error" in e &&
    (typeof e.id == "number" || typeof e.id == "string"),
  bp = (e) =>
    !Array.isArray(e) &&
    !!e &&
    e.jsonrpc === "2.0" &&
    !M(e.params) &&
    !M(e.method),
  sT = (e) =>
    !Array.isArray(e) &&
    !!e &&
    e.jsonrpc === "2.0" &&
    "id" in e &&
    "result" in e,
  th = (e) => ei(e) || ti(e),
  Kb = (e) => (Array.isArray(e) ? e.every(th) : th(e)),
  qc = (e) => Array.isArray(e) && e.length > 0 && Kb(e);
let Od;
const oT = (e) => {
    Od = e;
  },
  uo = (e) => {
    var t, n, r, i;
    return (
      typeof Od < "u" && (Od += 1),
      {
        jsonrpc: (t = e.jsonrpc) !== null && t !== void 0 ? t : "2.0",
        id:
          (r = (n = e.id) !== null && n !== void 0 ? n : Od) !== null &&
          r !== void 0
            ? r
            : Qb(),
        method: e.method,
        params: (i = e.params) !== null && i !== void 0 ? i : void 0,
      }
    );
  },
  Zb = (e) => e.map((t) => uo(t)),
  ir = (e) => Array.isArray(e) && e.length > 0,
  oH = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        isBatchRequest: ir,
        isBatchResponse: qc,
        isResponseRpcError: Vb,
        isResponseWithError: ti,
        isResponseWithNotification: bp,
        isResponseWithResult: ei,
        isSubscriptionResult: sT,
        isValidResponse: Kb,
        setRequestIdStart: oT,
        toBatchPayload: Zb,
        toPayload: uo,
        validateResponse: th,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
var Hm = function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(c) {
        try {
          l(r.next(c));
        } catch (d) {
          o(d);
        }
      }
      function u(c) {
        try {
          l(r.throw(c));
        } catch (d) {
          o(d);
        }
      }
      function l(c) {
        c.done ? s(c.value) : i(c.value).then(a, u);
      }
      l((r = r.apply(e, t || [])).next());
    });
  },
  aT;
class nh {
  constructor(
    { timeout: t, eagerStart: n, timeoutMessage: r } = {
      timeout: 0,
      eagerStart: !1,
      timeoutMessage: "DeferredPromise timed out",
    }
  ) {
    (this[aT] = "Promise"),
      (this._state = "pending"),
      (this._promise = new Promise((i, s) => {
        (this._resolve = i), (this._reject = s);
      })),
      (this._timeoutMessage = r),
      (this._timeoutInterval = t),
      n && this.startTimer();
  }
  get state() {
    return this._state;
  }
  then(t, n) {
    return Hm(this, void 0, void 0, function* () {
      return this._promise.then(t, n);
    });
  }
  catch(t) {
    return Hm(this, void 0, void 0, function* () {
      return this._promise.catch(t);
    });
  }
  finally(t) {
    return Hm(this, void 0, void 0, function* () {
      return this._promise.finally(t);
    });
  }
  resolve(t) {
    this._resolve(t), (this._state = "fulfilled"), this._clearTimeout();
  }
  reject(t) {
    this._reject(t), (this._state = "rejected"), this._clearTimeout();
  }
  startTimer() {
    this._timeoutInterval &&
      this._timeoutInterval > 0 &&
      (this._timeoutId = setTimeout(
        this._checkTimeout.bind(this),
        this._timeoutInterval
      ));
  }
  _checkTimeout() {
    this._state === "pending" &&
      this._timeoutId &&
      this.reject(new i3(this._timeoutMessage));
  }
  _clearTimeout() {
    this._timeoutId && clearTimeout(this._timeoutId);
  }
}
aT = Symbol.toStringTag;
class uT {
  constructor(t, n) {
    (this.eventEmitter = t), (this.autoReconnect = n);
  }
  clearQueues() {
    typeof this._clearQueues == "function" && this._clearQueues();
  }
  onError(t) {
    this._clearQueues = t;
  }
  parseResponse(t) {
    const n = [];
    return (
      t
        .replace(/\}[\n\r]?\{/g, "}|--|{")
        .replace(/\}\][\n\r]?\[\{/g, "}]|--|[{")
        .replace(/\}[\n\r]?\[\{/g, "}|--|[{")
        .replace(/\}\][\n\r]?\{/g, "}]|--|{")
        .split("|--|")
        .forEach((i) => {
          let s = i;
          this.lastChunk && (s = this.lastChunk + s);
          let o;
          try {
            o = JSON.parse(s);
          } catch {
            (this.lastChunk = s),
              this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout),
              (this.lastChunkTimeout = setTimeout(() => {
                this.autoReconnect ||
                  (this.clearQueues(),
                  this.eventEmitter.emit(
                    "error",
                    new Ic({
                      id: 1,
                      jsonrpc: "2.0",
                      error: { code: 2, message: "Chunk timeout" },
                    })
                  ));
              }, 1e3 * 15));
            return;
          }
          clearTimeout(this.lastChunkTimeout),
            (this.lastChunk = void 0),
            o && n.push(o);
        }),
      n
    );
  }
}
var F_ = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class cT extends vl {
  constructor() {
    super(...arguments),
      (this._eventEmitter = new Hb.EventEmitter()),
      (this._chainId = ""),
      (this._accounts = []);
  }
  _getChainId() {
    var t;
    return F_(this, void 0, void 0, function* () {
      const n = yield this.request(uo({ method: "eth_chainId", params: [] }));
      return (t = n == null ? void 0 : n.result) !== null && t !== void 0
        ? t
        : "";
    });
  }
  _getAccounts() {
    var t;
    return F_(this, void 0, void 0, function* () {
      const n = yield this.request(uo({ method: "eth_accounts", params: [] }));
      return (t = n == null ? void 0 : n.result) !== null && t !== void 0
        ? t
        : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId()
        .then((t) => {
          t !== this._chainId &&
            ((this._chainId = t),
            this._eventEmitter.emit("chainChanged", this._chainId));
        })
        .catch((t) => {
          console.error(t);
        }),
      this._getAccounts()
        .then((t) => {
          (this._accounts.length === t.length &&
            t.every((n) => t.includes(n))) ||
            ((this._accounts = t), this._onAccountsChanged());
        })
        .catch((t) => {
          console.error(t);
        }),
    ])
      .then(() =>
        this._eventEmitter.emit("connect", { chainId: this._chainId })
      )
      .catch((t) => {
        console.error(t);
      });
  }
  _onDisconnect(t, n) {
    this._eventEmitter.emit("disconnect", new fU(t, n));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
}
var zm = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const aH = { autoReconnect: !0, delay: 5e3, maxAttempts: 5 },
  uH = 1e3;
class lT extends cT {
  constructor(t, n, r) {
    if (
      (super(),
      (this._connectionStatus = "connecting"),
      (this._onMessageHandler = this._onMessage.bind(this)),
      (this._onOpenHandler = this._onConnect.bind(this)),
      (this._onCloseHandler = this._onCloseEvent.bind(this)),
      (this._onErrorHandler = this._onError.bind(this)),
      !this._validateProviderPath(t))
    )
      throw new eg(t);
    (this._socketPath = t),
      (this._socketOptions = n),
      (this._reconnectOptions = Object.assign(Object.assign({}, aH), r ?? {})),
      (this._pendingRequestsQueue = new Map()),
      (this._sentRequestsQueue = new Map()),
      this._init(),
      this.connect(),
      (this.chunkResponseParser = new uT(
        this._eventEmitter,
        this._reconnectOptions.autoReconnect
      )),
      this.chunkResponseParser.onError(() => {
        this._clearQueues();
      }),
      (this.isReconnecting = !1);
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection(),
        (this._connectionStatus = "connecting"),
        this._addSocketListeners();
    } catch (t) {
      if (this.isReconnecting)
        setImmediate(() => {
          this._reconnect();
        });
      else
        throw (
          ((this._connectionStatus = "disconnected"),
          t && t.message
            ? new yl(
                `Error while connecting to ${this._socketPath}. Reason: ${t.message}`
              )
            : new eg(this._socketPath))
        );
    }
  }
  _validateProviderPath(t) {
    return !!t;
  }
  getPendingRequestQueueSize() {
    return this._pendingRequestsQueue.size;
  }
  getSentRequestsQueueSize() {
    return this._sentRequestsQueue.size;
  }
  supportsSubscriptions() {
    return !0;
  }
  on(t, n) {
    this._eventEmitter.on(t, n);
  }
  once(t, n) {
    this._eventEmitter.once(t, n);
  }
  removeListener(t, n) {
    this._eventEmitter.removeListener(t, n);
  }
  _onDisconnect(t, n) {
    (this._connectionStatus = "disconnected"), super._onDisconnect(t, n);
  }
  disconnect(t, n) {
    const r = t ?? uH;
    this._removeSocketListeners(),
      this.getStatus() !== "disconnected" && this._closeSocketConnection(r, n),
      this._onDisconnect(r, n);
  }
  safeDisconnect(t, n, r = !1, i = 1e3) {
    return zm(this, void 0, void 0, function* () {
      let s = 0;
      yield zm(this, void 0, void 0, function* () {
        return new Promise((a) => {
          const u = setInterval(() => {
            r && s === 5 && this.clearQueues(),
              this.getPendingRequestQueueSize() === 0 &&
                this.getSentRequestsQueueSize() === 0 &&
                (clearInterval(u), a(!0)),
              (s += 1);
          }, i);
        });
      }),
        this.disconnect(t, n);
    });
  }
  removeAllListeners(t) {
    this._eventEmitter.removeAllListeners(t);
  }
  _onError(t) {
    this.isReconnecting
      ? this._reconnect()
      : this._eventEmitter.emit("error", t);
  }
  reset() {
    this._sentRequestsQueue.clear(),
      this._pendingRequestsQueue.clear(),
      this._init(),
      this._removeSocketListeners(),
      this._addSocketListeners();
  }
  _reconnect() {
    this.isReconnecting ||
      ((this.isReconnecting = !0),
      this._sentRequestsQueue.size > 0 &&
        this._sentRequestsQueue.forEach((t, n) => {
          t.deferredPromise.reject(new Cj()), this._sentRequestsQueue.delete(n);
        }),
      this._reconnectAttempts < this._reconnectOptions.maxAttempts
        ? ((this._reconnectAttempts += 1),
          setTimeout(() => {
            this._removeSocketListeners(),
              this.connect(),
              (this.isReconnecting = !1);
          }, this._reconnectOptions.delay))
        : ((this.isReconnecting = !1),
          this._clearQueues(),
          this._removeSocketListeners(),
          this._eventEmitter.emit(
            "error",
            new Sj(this._reconnectOptions.maxAttempts)
          )));
  }
  request(t) {
    return zm(this, void 0, void 0, function* () {
      if (ce(this._socketConnection))
        throw new Error("Connection is undefined");
      this.getStatus() === "disconnected" && this.connect();
      const n = ir(t) ? t[0].id : t.id;
      if (!n) throw new Rj("Request Id not defined");
      if (this._sentRequestsQueue.has(n)) throw new Tj(n);
      const r = new nh();
      r.catch((s) => {
        this._eventEmitter.emit("error", s);
      });
      const i = { payload: t, deferredPromise: r };
      if (this.getStatus() === "connecting")
        return this._pendingRequestsQueue.set(n, i), i.deferredPromise;
      this._sentRequestsQueue.set(n, i);
      try {
        this._sendToSocket(i.payload);
      } catch (s) {
        this._sentRequestsQueue.delete(n), this._eventEmitter.emit("error", s);
      }
      return r;
    });
  }
  _onConnect() {
    (this._connectionStatus = "connected"),
      (this._reconnectAttempts = 0),
      super._onConnect(),
      this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [t, n] of this._pendingRequestsQueue.entries())
      this._sendToSocket(n.payload),
        this._pendingRequestsQueue.delete(t),
        this._sentRequestsQueue.set(t, n);
  }
  _onMessage(t) {
    const n = this._parseResponses(t);
    if (!(ce(n) || n.length === 0))
      for (const r of n) {
        if (bp(r) && r.method.endsWith("_subscription")) {
          this._eventEmitter.emit("message", r);
          return;
        }
        const i = qc(r) ? r[0].id : r.id,
          s = this._sentRequestsQueue.get(i);
        if (!s) return;
        (qc(r) || ei(r) || ti(r)) &&
          (this._eventEmitter.emit("message", r), s.deferredPromise.resolve(r)),
          this._sentRequestsQueue.delete(i);
      }
  }
  clearQueues(t) {
    this._clearQueues(t);
  }
  _clearQueues(t) {
    this._pendingRequestsQueue.size > 0 &&
      this._pendingRequestsQueue.forEach((n, r) => {
        n.deferredPromise.reject(new Yy(t)),
          this._pendingRequestsQueue.delete(r);
      }),
      this._sentRequestsQueue.size > 0 &&
        this._sentRequestsQueue.forEach((n, r) => {
          n.deferredPromise.reject(new Yy(t)),
            this._sentRequestsQueue.delete(r);
        }),
      this._removeSocketListeners();
  }
}
const dT = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ChunkResponseParser: uT,
      Eip1193Provider: cT,
      EventEmitter: zb,
      SocketProvider: lT,
      Web3DeferredPromise: nh,
      asciiToHex: U3,
      bytesToHex: ve,
      bytesToUint8Array: Nr,
      checkAddressCheckSum: U$,
      compareBlockNumbers: V$,
      convert: eh,
      convertScalarValue: Au,
      encodePacked: Gb,
      ethUnitMap: jb,
      format: $,
      fromAscii: S$,
      fromDecimal: w$,
      fromTwosComplement: K$,
      fromUtf8: j3,
      fromWei: T$,
      getStorageSlotNumForLongString: nH,
      hexToAscii: $3,
      hexToBytes: He,
      hexToNumber: bl,
      hexToNumberString: E$,
      hexToString: x$,
      hexToUtf8: mp,
      isAddress: $$,
      isBatchRequest: ir,
      isBatchResponse: qc,
      isBloom: H$,
      isContractAddressInBloom: q$,
      isContractInitOptions: $i,
      isDataFormat: Qr,
      isHex: j$,
      isHexStrict: F$,
      isInBloom: z$,
      isNullish: ce,
      isPromise: nT,
      isResponseRpcError: Vb,
      isResponseWithError: ti,
      isResponseWithNotification: bp,
      isResponseWithResult: ei,
      isSubscriptionResult: sT,
      isTopic: W$,
      isTopicInBloom: Q$,
      isUserEthereumAddressInBloom: G$,
      isValidResponse: Kb,
      jsonRpc: oH,
      keccak256: zc,
      keccak256Wrapper: zc,
      leftPad: Hc,
      mergeDeep: ws,
      numberToHex: kn,
      padLeft: xa,
      padRight: J3,
      pollTillDefined: sH,
      pollTillDefinedAndReturnIntervalId: qb,
      processSolidityEncodePackedArgs: tT,
      randomBytes: Gc,
      randomHex: iH,
      rejectIfConditionAtInterval: iT,
      rejectIfTimeout: Wb,
      rightPad: Y3,
      setRequestIdStart: oT,
      sha3: wl,
      sha3Raw: On,
      soliditySha3: eH,
      soliditySha3Raw: tH,
      stringToHex: _$,
      toAscii: C$,
      toBatchPayload: Zb,
      toBigInt: Bs,
      toBool: H3,
      toChecksumAddress: Lr,
      toDecimal: b$,
      toHex: cs,
      toNumber: yn,
      toPayload: uo,
      toTwosComplement: X3,
      toUtf8: A$,
      toWei: I$,
      uint8ArrayConcat: an,
      uint8ArrayEquals: gp,
      utf8ToBytes: Ub,
      utf8ToHex: yr,
      uuidV4: Qb,
      validateResponse: th,
      waitWithTimeout: rT,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
class wp {
  constructor() {
    this._emitter = new zb();
  }
  on(t, n) {
    this._emitter.on(t, n);
  }
  once(t, n) {
    this._emitter.once(t, n);
  }
  off(t, n) {
    this._emitter.off(t, n);
  }
  emit(t, n) {
    this._emitter.emit(t, n);
  }
  listenerCount(t) {
    return this._emitter.listenerCount(t);
  }
  listeners(t) {
    return this._emitter.listeners(t);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(t) {
    this._emitter.setMaxListeners(t);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
}
var co;
(function (e) {
  e.CONFIG_CHANGE = "CONFIG_CHANGE";
})(co || (co = {}));
class cH extends wp {
  constructor(t) {
    super(),
      (this.config = {
        handleRevert: !1,
        defaultAccount: void 0,
        defaultBlock: "latest",
        transactionBlockTimeout: 50,
        transactionConfirmationBlocks: 24,
        transactionPollingInterval: 1e3,
        transactionPollingTimeout: 750 * 1e3,
        transactionReceiptPollingInterval: void 0,
        transactionSendTimeout: 750 * 1e3,
        transactionConfirmationPollingInterval: void 0,
        blockHeaderTimeout: 10,
        maxListenersWarningThreshold: 100,
        contractDataInputFill: "data",
        defaultNetworkId: void 0,
        defaultChain: "mainnet",
        defaultHardfork: "london",
        defaultCommon: void 0,
        defaultTransactionType: "0x2",
        defaultMaxPriorityFeePerGas: cs(25e8),
        enableExperimentalFeatures: {
          useSubscriptionWhenCheckingBlockTimeout: !1,
          useRpcCallSpecification: !1,
        },
        transactionBuilder: void 0,
        transactionTypeParser: void 0,
      }),
      this.setConfig(t ?? {});
  }
  setConfig(t) {
    const n = Object.keys(t);
    for (const r of n) this._triggerConfigChange(r, t[r]);
    Object.assign(this.config, t);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(t) {
    this._triggerConfigChange("handleRevert", t),
      (this.config.handleRevert = t);
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(t) {
    this._triggerConfigChange("contractDataInputFill", t),
      (this.config.contractDataInputFill = t);
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(t) {
    this._triggerConfigChange("defaultAccount", t),
      (this.config.defaultAccount = t);
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(t) {
    this._triggerConfigChange("defaultBlock", t),
      (this.config.defaultBlock = t);
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(t) {
    this._triggerConfigChange("transactionSendTimeout", t),
      (this.config.transactionSendTimeout = t);
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(t) {
    this._triggerConfigChange("transactionBlockTimeout", t),
      (this.config.transactionBlockTimeout = t);
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(t) {
    this._triggerConfigChange("transactionConfirmationBlocks", t),
      (this.config.transactionConfirmationBlocks = t);
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(t) {
    this._triggerConfigChange("transactionPollingInterval", t),
      (this.config.transactionPollingInterval = t),
      (this.transactionReceiptPollingInterval = t),
      (this.transactionConfirmationPollingInterval = t);
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(t) {
    this._triggerConfigChange("transactionPollingTimeout", t),
      (this.config.transactionPollingTimeout = t);
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(t) {
    this._triggerConfigChange("transactionReceiptPollingInterval", t),
      (this.config.transactionReceiptPollingInterval = t);
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(t) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", t),
      (this.config.transactionConfirmationPollingInterval = t);
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(t) {
    this._triggerConfigChange("blockHeaderTimeout", t),
      (this.config.blockHeaderTimeout = t);
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(t) {
    this._triggerConfigChange("enableExperimentalFeatures", t),
      (this.config.enableExperimentalFeatures = t);
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(t) {
    this._triggerConfigChange("maxListenersWarningThreshold", t),
      this.setMaxListenerWarningThreshold(t),
      (this.config.maxListenersWarningThreshold = t);
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(t) {
    this._triggerConfigChange("defaultNetworkId", t),
      (this.config.defaultNetworkId = t);
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(t) {
    if (
      !ce(this.config.defaultCommon) &&
      !ce(this.config.defaultCommon.baseChain) &&
      t !== this.config.defaultCommon.baseChain
    )
      throw new S_(this.config.defaultChain, t);
    this._triggerConfigChange("defaultChain", t),
      (this.config.defaultChain = t);
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(t) {
    if (
      !ce(this.config.defaultCommon) &&
      !ce(this.config.defaultCommon.hardfork) &&
      t !== this.config.defaultCommon.hardfork
    )
      throw new x_(this.config.defaultCommon.hardfork, t);
    this._triggerConfigChange("defaultHardfork", t),
      (this.config.defaultHardfork = t);
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(t) {
    if (
      !ce(this.config.defaultHardfork) &&
      !ce(t) &&
      !ce(t.hardfork) &&
      this.config.defaultHardfork !== t.hardfork
    )
      throw new x_(this.config.defaultHardfork, t.hardfork);
    if (
      !ce(this.config.defaultChain) &&
      !ce(t) &&
      !ce(t.baseChain) &&
      this.config.defaultChain !== t.baseChain
    )
      throw new S_(this.config.defaultChain, t.baseChain);
    this._triggerConfigChange("defaultCommon", t),
      (this.config.defaultCommon = t);
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(t) {
    this._triggerConfigChange("defaultTransactionType", t),
      (this.config.defaultTransactionType = t);
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(t) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", t),
      (this.config.defaultMaxPriorityFeePerGas = t);
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(t) {
    this._triggerConfigChange("transactionBuilder", t),
      (this.config.transactionBuilder = t);
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(t) {
    this._triggerConfigChange("transactionTypeParser", t),
      (this.config.transactionTypeParser = t);
  }
  _triggerConfigChange(t, n) {
    this.emit(co.CONFIG_CHANGE, {
      name: t,
      oldValue: this.config[t],
      newValue: n,
    });
  }
}
var lg = { exports: {} };
(function (e, t) {
  var n =
      (typeof globalThis < "u" && globalThis) ||
      (typeof self < "u" && self) ||
      (typeof Cu < "u" && Cu),
    r = (function () {
      function s() {
        (this.fetch = !1), (this.DOMException = n.DOMException);
      }
      return (s.prototype = n), new s();
    })();
  (function (s) {
    (function (o) {
      var a =
          (typeof s < "u" && s) ||
          (typeof self < "u" && self) ||
          (typeof a < "u" && a),
        u = {
          searchParams: "URLSearchParams" in a,
          iterable: "Symbol" in a && "iterator" in Symbol,
          blob:
            "FileReader" in a &&
            "Blob" in a &&
            (function () {
              try {
                return new Blob(), !0;
              } catch {
                return !1;
              }
            })(),
          formData: "FormData" in a,
          arrayBuffer: "ArrayBuffer" in a,
        };
      function l(S) {
        return S && DataView.prototype.isPrototypeOf(S);
      }
      if (u.arrayBuffer)
        var c = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]",
          ],
          d =
            ArrayBuffer.isView ||
            function (S) {
              return S && c.indexOf(Object.prototype.toString.call(S)) > -1;
            };
      function f(S) {
        if (
          (typeof S != "string" && (S = String(S)),
          /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(S) || S === "")
        )
          throw new TypeError(
            'Invalid character in header field name: "' + S + '"'
          );
        return S.toLowerCase();
      }
      function p(S) {
        return typeof S != "string" && (S = String(S)), S;
      }
      function m(S) {
        var T = {
          next: function () {
            var D = S.shift();
            return { done: D === void 0, value: D };
          },
        };
        return (
          u.iterable &&
            (T[Symbol.iterator] = function () {
              return T;
            }),
          T
        );
      }
      function g(S) {
        (this.map = {}),
          S instanceof g
            ? S.forEach(function (T, D) {
                this.append(D, T);
              }, this)
            : Array.isArray(S)
            ? S.forEach(function (T) {
                this.append(T[0], T[1]);
              }, this)
            : S &&
              Object.getOwnPropertyNames(S).forEach(function (T) {
                this.append(T, S[T]);
              }, this);
      }
      (g.prototype.append = function (S, T) {
        (S = f(S)), (T = p(T));
        var D = this.map[S];
        this.map[S] = D ? D + ", " + T : T;
      }),
        (g.prototype.delete = function (S) {
          delete this.map[f(S)];
        }),
        (g.prototype.get = function (S) {
          return (S = f(S)), this.has(S) ? this.map[S] : null;
        }),
        (g.prototype.has = function (S) {
          return this.map.hasOwnProperty(f(S));
        }),
        (g.prototype.set = function (S, T) {
          this.map[f(S)] = p(T);
        }),
        (g.prototype.forEach = function (S, T) {
          for (var D in this.map)
            this.map.hasOwnProperty(D) && S.call(T, this.map[D], D, this);
        }),
        (g.prototype.keys = function () {
          var S = [];
          return (
            this.forEach(function (T, D) {
              S.push(D);
            }),
            m(S)
          );
        }),
        (g.prototype.values = function () {
          var S = [];
          return (
            this.forEach(function (T) {
              S.push(T);
            }),
            m(S)
          );
        }),
        (g.prototype.entries = function () {
          var S = [];
          return (
            this.forEach(function (T, D) {
              S.push([D, T]);
            }),
            m(S)
          );
        }),
        u.iterable && (g.prototype[Symbol.iterator] = g.prototype.entries);
      function w(S) {
        if (S.bodyUsed) return Promise.reject(new TypeError("Already read"));
        S.bodyUsed = !0;
      }
      function v(S) {
        return new Promise(function (T, D) {
          (S.onload = function () {
            T(S.result);
          }),
            (S.onerror = function () {
              D(S.error);
            });
        });
      }
      function y(S) {
        var T = new FileReader(),
          D = v(T);
        return T.readAsArrayBuffer(S), D;
      }
      function b(S) {
        var T = new FileReader(),
          D = v(T);
        return T.readAsText(S), D;
      }
      function _(S) {
        for (
          var T = new Uint8Array(S), D = new Array(T.length), P = 0;
          P < T.length;
          P++
        )
          D[P] = String.fromCharCode(T[P]);
        return D.join("");
      }
      function A(S) {
        if (S.slice) return S.slice(0);
        var T = new Uint8Array(S.byteLength);
        return T.set(new Uint8Array(S)), T.buffer;
      }
      function x() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (S) {
            (this.bodyUsed = this.bodyUsed),
              (this._bodyInit = S),
              S
                ? typeof S == "string"
                  ? (this._bodyText = S)
                  : u.blob && Blob.prototype.isPrototypeOf(S)
                  ? (this._bodyBlob = S)
                  : u.formData && FormData.prototype.isPrototypeOf(S)
                  ? (this._bodyFormData = S)
                  : u.searchParams && URLSearchParams.prototype.isPrototypeOf(S)
                  ? (this._bodyText = S.toString())
                  : u.arrayBuffer && u.blob && l(S)
                  ? ((this._bodyArrayBuffer = A(S.buffer)),
                    (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                  : u.arrayBuffer &&
                    (ArrayBuffer.prototype.isPrototypeOf(S) || d(S))
                  ? (this._bodyArrayBuffer = A(S))
                  : (this._bodyText = S = Object.prototype.toString.call(S))
                : (this._bodyText = ""),
              this.headers.get("content-type") ||
                (typeof S == "string"
                  ? this.headers.set("content-type", "text/plain;charset=UTF-8")
                  : this._bodyBlob && this._bodyBlob.type
                  ? this.headers.set("content-type", this._bodyBlob.type)
                  : u.searchParams &&
                    URLSearchParams.prototype.isPrototypeOf(S) &&
                    this.headers.set(
                      "content-type",
                      "application/x-www-form-urlencoded;charset=UTF-8"
                    ));
          }),
          u.blob &&
            ((this.blob = function () {
              var S = w(this);
              if (S) return S;
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer)
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData)
                throw new Error("could not read FormData body as blob");
              return Promise.resolve(new Blob([this._bodyText]));
            }),
            (this.arrayBuffer = function () {
              if (this._bodyArrayBuffer) {
                var S = w(this);
                return (
                  S ||
                  (ArrayBuffer.isView(this._bodyArrayBuffer)
                    ? Promise.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset +
                            this._bodyArrayBuffer.byteLength
                        )
                      )
                    : Promise.resolve(this._bodyArrayBuffer))
                );
              } else return this.blob().then(y);
            })),
          (this.text = function () {
            var S = w(this);
            if (S) return S;
            if (this._bodyBlob) return b(this._bodyBlob);
            if (this._bodyArrayBuffer)
              return Promise.resolve(_(this._bodyArrayBuffer));
            if (this._bodyFormData)
              throw new Error("could not read FormData body as text");
            return Promise.resolve(this._bodyText);
          }),
          u.formData &&
            (this.formData = function () {
              return this.text().then(C);
            }),
          (this.json = function () {
            return this.text().then(JSON.parse);
          }),
          this
        );
      }
      var h = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function E(S) {
        var T = S.toUpperCase();
        return h.indexOf(T) > -1 ? T : S;
      }
      function I(S, T) {
        if (!(this instanceof I))
          throw new TypeError(
            'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
          );
        T = T || {};
        var D = T.body;
        if (S instanceof I) {
          if (S.bodyUsed) throw new TypeError("Already read");
          (this.url = S.url),
            (this.credentials = S.credentials),
            T.headers || (this.headers = new g(S.headers)),
            (this.method = S.method),
            (this.mode = S.mode),
            (this.signal = S.signal),
            !D && S._bodyInit != null && ((D = S._bodyInit), (S.bodyUsed = !0));
        } else this.url = String(S);
        if (
          ((this.credentials =
            T.credentials || this.credentials || "same-origin"),
          (T.headers || !this.headers) && (this.headers = new g(T.headers)),
          (this.method = E(T.method || this.method || "GET")),
          (this.mode = T.mode || this.mode || null),
          (this.signal = T.signal || this.signal),
          (this.referrer = null),
          (this.method === "GET" || this.method === "HEAD") && D)
        )
          throw new TypeError("Body not allowed for GET or HEAD requests");
        if (
          (this._initBody(D),
          (this.method === "GET" || this.method === "HEAD") &&
            (T.cache === "no-store" || T.cache === "no-cache"))
        ) {
          var P = /([?&])_=[^&]*/;
          if (P.test(this.url))
            this.url = this.url.replace(P, "$1_=" + new Date().getTime());
          else {
            var B = /\?/;
            this.url +=
              (B.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
          }
        }
      }
      I.prototype.clone = function () {
        return new I(this, { body: this._bodyInit });
      };
      function C(S) {
        var T = new FormData();
        return (
          S.trim()
            .split("&")
            .forEach(function (D) {
              if (D) {
                var P = D.split("="),
                  B = P.shift().replace(/\+/g, " "),
                  L = P.join("=").replace(/\+/g, " ");
                T.append(decodeURIComponent(B), decodeURIComponent(L));
              }
            }),
          T
        );
      }
      function k(S) {
        var T = new g(),
          D = S.replace(/\r?\n[\t ]+/g, " ");
        return (
          D.split("\r")
            .map(function (P) {
              return P.indexOf(`
`) === 0
                ? P.substr(1, P.length)
                : P;
            })
            .forEach(function (P) {
              var B = P.split(":"),
                L = B.shift().trim();
              if (L) {
                var Q = B.join(":").trim();
                T.append(L, Q);
              }
            }),
          T
        );
      }
      x.call(I.prototype);
      function O(S, T) {
        if (!(this instanceof O))
          throw new TypeError(
            'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
          );
        T || (T = {}),
          (this.type = "default"),
          (this.status = T.status === void 0 ? 200 : T.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = T.statusText === void 0 ? "" : "" + T.statusText),
          (this.headers = new g(T.headers)),
          (this.url = T.url || ""),
          this._initBody(S);
      }
      x.call(O.prototype),
        (O.prototype.clone = function () {
          return new O(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new g(this.headers),
            url: this.url,
          });
        }),
        (O.error = function () {
          var S = new O(null, { status: 0, statusText: "" });
          return (S.type = "error"), S;
        });
      var R = [301, 302, 303, 307, 308];
      (O.redirect = function (S, T) {
        if (R.indexOf(T) === -1) throw new RangeError("Invalid status code");
        return new O(null, { status: T, headers: { location: S } });
      }),
        (o.DOMException = a.DOMException);
      try {
        new o.DOMException();
      } catch {
        (o.DOMException = function (T, D) {
          (this.message = T), (this.name = D);
          var P = Error(T);
          this.stack = P.stack;
        }),
          (o.DOMException.prototype = Object.create(Error.prototype)),
          (o.DOMException.prototype.constructor = o.DOMException);
      }
      function N(S, T) {
        return new Promise(function (D, P) {
          var B = new I(S, T);
          if (B.signal && B.signal.aborted)
            return P(new o.DOMException("Aborted", "AbortError"));
          var L = new XMLHttpRequest();
          function Q() {
            L.abort();
          }
          (L.onload = function () {
            var j = {
              status: L.status,
              statusText: L.statusText,
              headers: k(L.getAllResponseHeaders() || ""),
            };
            j.url =
              "responseURL" in L
                ? L.responseURL
                : j.headers.get("X-Request-URL");
            var W = "response" in L ? L.response : L.responseText;
            setTimeout(function () {
              D(new O(W, j));
            }, 0);
          }),
            (L.onerror = function () {
              setTimeout(function () {
                P(new TypeError("Network request failed"));
              }, 0);
            }),
            (L.ontimeout = function () {
              setTimeout(function () {
                P(new TypeError("Network request failed"));
              }, 0);
            }),
            (L.onabort = function () {
              setTimeout(function () {
                P(new o.DOMException("Aborted", "AbortError"));
              }, 0);
            });
          function z(j) {
            try {
              return j === "" && a.location.href ? a.location.href : j;
            } catch {
              return j;
            }
          }
          L.open(B.method, z(B.url), !0),
            B.credentials === "include"
              ? (L.withCredentials = !0)
              : B.credentials === "omit" && (L.withCredentials = !1),
            "responseType" in L &&
              (u.blob
                ? (L.responseType = "blob")
                : u.arrayBuffer &&
                  B.headers.get("Content-Type") &&
                  B.headers
                    .get("Content-Type")
                    .indexOf("application/octet-stream") !== -1 &&
                  (L.responseType = "arraybuffer")),
            T && typeof T.headers == "object" && !(T.headers instanceof g)
              ? Object.getOwnPropertyNames(T.headers).forEach(function (j) {
                  L.setRequestHeader(j, p(T.headers[j]));
                })
              : B.headers.forEach(function (j, W) {
                  L.setRequestHeader(W, j);
                }),
            B.signal &&
              (B.signal.addEventListener("abort", Q),
              (L.onreadystatechange = function () {
                L.readyState === 4 && B.signal.removeEventListener("abort", Q);
              })),
            L.send(typeof B._bodyInit > "u" ? null : B._bodyInit);
        });
      }
      return (
        (N.polyfill = !0),
        a.fetch ||
          ((a.fetch = N), (a.Headers = g), (a.Request = I), (a.Response = O)),
        (o.Headers = g),
        (o.Request = I),
        (o.Response = O),
        (o.fetch = N),
        o
      );
    })({});
  })(r),
    (r.fetch.ponyfill = !0),
    delete r.fetch.polyfill;
  var i = n.fetch ? n : r;
  (t = i.fetch),
    (t.default = i.fetch),
    (t.fetch = i.fetch),
    (t.Headers = i.Headers),
    (t.Request = i.Request),
    (t.Response = i.Response),
    (e.exports = t);
})(lg, lg.exports);
var lH = lg.exports;
const dH = Xc(lH);
var fH = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class Jb extends vl {
  constructor(t, n) {
    if ((super(), !Jb.validateClientUrl(t))) throw new eg(t);
    (this.clientUrl = t), (this.httpProviderOptions = n);
  }
  static validateClientUrl(t) {
    return typeof t == "string" ? /^http(s)?:\/\//i.test(t) : !1;
  }
  getStatus() {
    throw new $r();
  }
  supportsSubscriptions() {
    return !1;
  }
  request(t, n) {
    var r;
    return fH(this, void 0, void 0, function* () {
      const i = Object.assign(
          Object.assign(
            {},
            (r = this.httpProviderOptions) === null || r === void 0
              ? void 0
              : r.providerOptions
          ),
          n
        ),
        s = yield dH(
          this.clientUrl,
          Object.assign(Object.assign({}, i), {
            method: "POST",
            headers: Object.assign(Object.assign({}, i.headers), {
              "Content-Type": "application/json",
            }),
            body: JSON.stringify(t),
          })
        );
      if (!s.ok) throw new Kr(yield s.json());
      return yield s.json();
    });
  }
  on() {
    throw new $r();
  }
  removeListener() {
    throw new $r();
  }
  once() {
    throw new $r();
  }
  removeAllListeners() {
    throw new $r();
  }
  connect() {
    throw new $r();
  }
  disconnect() {
    throw new $r();
  }
  reset() {
    throw new $r();
  }
  reconnect() {
    throw new $r();
  }
}
var Do = null;
typeof WebSocket < "u"
  ? (Do = WebSocket)
  : typeof MozWebSocket < "u"
  ? (Do = MozWebSocket)
  : typeof global < "u"
  ? (Do = global.WebSocket || global.MozWebSocket)
  : typeof window < "u"
  ? (Do = window.WebSocket || window.MozWebSocket)
  : typeof self < "u" && (Do = self.WebSocket || self.MozWebSocket);
const hH = Do;
class pH extends lT {
  constructor(t, n, r) {
    super(t, n, r);
  }
  _validateProviderPath(t) {
    return typeof t == "string" ? /^ws(s)?:\/\//i.test(t) : !1;
  }
  getStatus() {
    if (this._socketConnection && !ce(this._socketConnection))
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING:
          return "connecting";
        case this._socketConnection.OPEN:
          return "connected";
        default:
          return "disconnected";
      }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new hH(
      this._socketPath,
      void 0,
      this._socketOptions && Object.keys(this._socketOptions).length === 0
        ? void 0
        : this._socketOptions
    );
  }
  _closeSocketConnection(t, n) {
    var r;
    (r = this._socketConnection) === null || r === void 0 || r.close(t, n);
  }
  _sendToSocket(t) {
    var n;
    if (this.getStatus() === "disconnected") throw new Yy();
    (n = this._socketConnection) === null ||
      n === void 0 ||
      n.send(JSON.stringify(t));
  }
  _parseResponses(t) {
    return this.chunkResponseParser.parseResponse(t.data);
  }
  _addSocketListeners() {
    var t, n, r, i;
    (t = this._socketConnection) === null ||
      t === void 0 ||
      t.addEventListener("open", this._onOpenHandler),
      (n = this._socketConnection) === null ||
        n === void 0 ||
        n.addEventListener("message", this._onMessageHandler),
      (r = this._socketConnection) === null ||
        r === void 0 ||
        r.addEventListener("close", (s) => this._onCloseHandler(s)),
      (i = this._socketConnection) === null ||
        i === void 0 ||
        i.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var t, n, r;
    (t = this._socketConnection) === null ||
      t === void 0 ||
      t.removeEventListener("message", this._onMessageHandler),
      (n = this._socketConnection) === null ||
        n === void 0 ||
        n.removeEventListener("open", this._onOpenHandler),
      (r = this._socketConnection) === null ||
        r === void 0 ||
        r.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(t) {
    var n;
    if (
      this._reconnectOptions.autoReconnect &&
      (![1e3, 1001].includes(t.code) || !t.wasClean)
    ) {
      this._reconnect();
      return;
    }
    this._clearQueues(t),
      this._removeSocketListeners(),
      this._onDisconnect(t.code, t.reason),
      (n = this._socketConnection) === null ||
        n === void 0 ||
        n.removeEventListener("error", this._onErrorHandler);
  }
}
const fT = (e) => vl.isWeb3Provider(e),
  hT = (e) =>
    typeof e != "string" &&
    "request" in e &&
    e.request.constructor.name === "Function",
  pT = (e) =>
    typeof e != "string" &&
    "request" in e &&
    e.request.constructor.name === "AsyncFunction",
  mT = (e) => typeof e != "string" && "send" in e,
  yT = (e) => typeof e != "string" && "sendAsync" in e,
  rh = (e) => e && (fT(e) || pT(e) || hT(e) || yT(e) || mT(e)),
  mH = (e) =>
    e && "supportsSubscriptions" in e
      ? e.supportsSubscriptions()
      : !!(e && typeof e != "string" && "on" in e);
var Gm = function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(c) {
        try {
          l(r.next(c));
        } catch (d) {
          o(d);
        }
      }
      function u(c) {
        try {
          l(r.throw(c));
        } catch (d) {
          o(d);
        }
      }
      function l(c) {
        c.done ? s(c.value) : i(c.value).then(a, u);
      }
      l((r = r.apply(e, t || [])).next());
    });
  },
  Sa;
(function (e) {
  (e.PROVIDER_CHANGED = "PROVIDER_CHANGED"),
    (e.BEFORE_PROVIDER_CHANGE = "BEFORE_PROVIDER_CHANGE");
})(Sa || (Sa = {}));
const j_ = { HttpProvider: Jb, WebsocketProvider: pH };
class qs extends wp {
  constructor(t, n) {
    super(), ce(t) || this.setProvider(t), (this.useRpcCallSpecification = n);
  }
  static get providers() {
    return j_;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return j_;
  }
  setProvider(t) {
    let n;
    if (t && typeof t == "string" && this.providers)
      if (/^http(s)?:\/\//i.test(t)) n = new this.providers.HttpProvider(t);
      else if (/^ws(s)?:\/\//i.test(t))
        n = new this.providers.WebsocketProvider(t);
      else throw new Cd(`Can't autodetect provider for "${t}"`);
    else ce(t) ? (n = void 0) : (n = t);
    return (
      this.emit(Sa.BEFORE_PROVIDER_CHANGE, this._provider),
      (this._provider = n),
      this.emit(Sa.PROVIDER_CHANGED, this._provider),
      !0
    );
  }
  send(t) {
    return Gm(this, void 0, void 0, function* () {
      const n = yield this._sendRequest(t);
      if (ei(n)) return n.result;
      throw new Kr(n);
    });
  }
  sendBatch(t) {
    return Gm(this, void 0, void 0, function* () {
      return yield this._sendRequest(t);
    });
  }
  _sendRequest(t) {
    return Gm(this, void 0, void 0, function* () {
      const { provider: n } = this;
      if (ce(n))
        throw new Cd(
          "Provider not available. Use `.setProvider` or `.provider=` to initialize the provider."
        );
      const r = ir(t) ? Zb(t) : uo(t);
      if (fT(n)) {
        let i;
        try {
          i = yield n.request(r);
        } catch (s) {
          i = s;
        }
        return this._processJsonRpcResponse(r, i, { legacy: !1, error: !1 });
      }
      if (pT(n))
        return n
          .request(r)
          .then((i) =>
            this._processJsonRpcResponse(r, i, { legacy: !0, error: !1 })
          )
          .catch((i) =>
            this._processJsonRpcResponse(r, i, { legacy: !0, error: !0 })
          );
      if (hT(n))
        return new Promise((i, s) => {
          const o = (l) =>
              s(this._processJsonRpcResponse(r, l, { legacy: !0, error: !0 })),
            a = (l) =>
              i(this._processJsonRpcResponse(r, l, { legacy: !0, error: !1 })),
            u = n.request(r, (l, c) => (l ? o(l) : a(c)));
          nT(u) && u.then(a).catch(o);
        });
      if (mT(n))
        return new Promise((i, s) => {
          n.send(r, (o, a) => {
            if (o)
              return s(
                this._processJsonRpcResponse(r, o, { legacy: !0, error: !0 })
              );
            if (ce(a))
              throw new Kr("", 'Got a "nullish" response from provider.');
            return i(
              this._processJsonRpcResponse(r, a, { legacy: !0, error: !1 })
            );
          });
        });
      if (yT(n))
        return n
          .sendAsync(r)
          .then((i) =>
            this._processJsonRpcResponse(r, i, { legacy: !0, error: !1 })
          )
          .catch((i) =>
            this._processJsonRpcResponse(r, i, { legacy: !0, error: !0 })
          );
      throw new Cd("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(t, n, { legacy: r, error: i }) {
    if (ce(n)) return this._buildResponse(t, null, i);
    if (ti(n)) {
      if (this.useRpcCallSpecification && Vb(n)) {
        const s = n;
        if (sn.get(s.error.code)) {
          const o = sn.get(s.error.code).error;
          throw new o(s);
        } else throw new Nn(s);
      } else if (!qs._isReverted(n)) throw new Ic(n, t);
    }
    if (ei(n)) return n;
    if (n instanceof Error) throw (qs._isReverted(n), n);
    if ((!r && ir(t) && qc(n)) || (r && !i && ir(t))) return n;
    if (r && i && ir(t)) throw n;
    if (r && !ti(n) && !ei(n)) return this._buildResponse(t, n, i);
    throw ir(t) && !Array.isArray(n)
      ? new Kr(n, "Got normal response for a batch request.")
      : !ir(t) && Array.isArray(n)
      ? new Kr(n, "Got batch response for a normal request.")
      : (ti(n) || ei(n)) && !ir(t) && n.id && t.id !== n.id
      ? new Ic(n)
      : new Kr(n, "Invalid response");
  }
  static _isReverted(t) {
    let n;
    if (
      (ti(t) ? (n = t.error) : t instanceof Error && (n = t),
      n != null && n.message.includes("revert"))
    )
      throw new zs(n);
    return !1;
  }
  _buildResponse(t, n, r) {
    const i = { jsonrpc: "2.0", id: ir(t) ? t[0].id : "id" in t ? t.id : null };
    return r
      ? Object.assign(Object.assign({}, i), { error: n })
      : Object.assign(Object.assign({}, i), { result: n });
  }
}
var lu = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class dg {
  constructor(t, n, r = !1) {
    (this.requestManager = t),
      (this.registeredSubscriptions = n),
      (this.tolerateUnlinkedSubscription = r),
      (this._subscriptions = new Map()),
      this.requestManager.on(Sa.BEFORE_PROVIDER_CHANGE, () =>
        lu(this, void 0, void 0, function* () {
          yield this.unsubscribe();
        })
      ),
      this.requestManager.on(Sa.PROVIDER_CHANGED, () => {
        this.clear(), this.listenToProviderEvents();
      }),
      this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const t = this.requestManager.provider;
    !this.requestManager.provider ||
      (typeof (t == null ? void 0 : t.supportsSubscriptions) == "function" &&
        !(t != null && t.supportsSubscriptions())) ||
      (typeof this.requestManager.provider.on == "function" &&
        (typeof this.requestManager.provider.request == "function"
          ? this.requestManager.provider.on("message", (n) =>
              this.messageListener(n)
            )
          : t.on("data", (n) => this.messageListener(n))));
  }
  messageListener(t) {
    var n, r, i;
    if (!t)
      throw new or("Should not call messageListener with no data. Type was");
    const s =
      ((n = t.params) === null || n === void 0 ? void 0 : n.subscription) ||
      ((r = t.data) === null || r === void 0 ? void 0 : r.subscription) ||
      ((i = t.id) === null || i === void 0 ? void 0 : i.toString(16));
    if (s) {
      const o = this._subscriptions.get(s);
      o == null || o.processSubscriptionData(t);
    }
  }
  subscribe(t, n, r = Y) {
    return lu(this, void 0, void 0, function* () {
      const i = this.registeredSubscriptions[t];
      if (!i) throw new or("Invalid subscription type");
      const s = new i(n ?? void 0, {
        subscriptionManager: this,
        returnFormat: r,
      });
      return yield this.addSubscription(s), s;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(t) {
    return lu(this, void 0, void 0, function* () {
      if (!this.requestManager.provider) throw new Cd("Provider not available");
      if (!this.supportsSubscriptions())
        throw new or("The current provider does not support subscriptions");
      if (t.id && this._subscriptions.has(t.id))
        throw new or(`Subscription with id "${t.id}" already exists`);
      if ((yield t.sendSubscriptionRequest(), ce(t.id)))
        throw new or("Subscription is not subscribed yet.");
      return this._subscriptions.set(t.id, t), t.id;
    });
  }
  removeSubscription(t) {
    return lu(this, void 0, void 0, function* () {
      const { id: n } = t;
      if (ce(n))
        throw new or(
          "Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager."
        );
      if (!this._subscriptions.has(n) && !this.tolerateUnlinkedSubscription)
        throw new or(`Subscription with id "${n.toString()}" does not exists`);
      return yield t.sendUnsubscribeRequest(), this._subscriptions.delete(n), n;
    });
  }
  unsubscribe(t) {
    return lu(this, void 0, void 0, function* () {
      const n = [];
      for (const [r, i] of this.subscriptions.entries())
        (!t || (typeof t == "function" && t({ id: r, sub: i }))) &&
          n.push(this.removeSubscription(i));
      return Promise.all(n);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return ce(this.requestManager.provider)
      ? !1
      : mH(this.requestManager.provider);
  }
}
var du = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class El extends wp {
  constructor(t, n) {
    var r;
    super(), (this.args = t);
    const { requestManager: i } = n,
      { subscriptionManager: s } = n;
    if (i && s)
      throw new or(
        "Only requestManager or subscriptionManager should be provided at Subscription constructor"
      );
    if (!i && !s)
      throw new or(
        "Either requestManager or subscriptionManager should be provided at Subscription constructor"
      );
    i
      ? (this._subscriptionManager = new dg(i, {}, !0))
      : (this._subscriptionManager = s),
      (this._returnFormat =
        (r = n == null ? void 0 : n.returnFormat) !== null && r !== void 0
          ? r
          : Y);
  }
  get id() {
    return this._id;
  }
  get lastBlock() {
    return this._lastBlock;
  }
  subscribe() {
    return du(this, void 0, void 0, function* () {
      return this._subscriptionManager.addSubscription(this);
    });
  }
  processSubscriptionData(t) {
    var n, r;
    t != null && t.data
      ? this._processSubscriptionResult(
          (r =
            (n = t == null ? void 0 : t.data) === null || n === void 0
              ? void 0
              : n.result) !== null && r !== void 0
            ? r
            : t == null
            ? void 0
            : t.data
        )
      : t &&
        bp(t) &&
        this._processSubscriptionResult(t == null ? void 0 : t.params.result);
  }
  sendSubscriptionRequest() {
    return du(this, void 0, void 0, function* () {
      return (
        (this._id = yield this._subscriptionManager.requestManager.send({
          method: "eth_subscribe",
          params: this._buildSubscriptionParams(),
        })),
        this.emit("connected", this._id),
        this._id
      );
    });
  }
  get returnFormat() {
    return this._returnFormat;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  resubscribe() {
    return du(this, void 0, void 0, function* () {
      yield this.unsubscribe(), yield this.subscribe();
    });
  }
  unsubscribe() {
    return du(this, void 0, void 0, function* () {
      this.id && (yield this._subscriptionManager.removeSubscription(this));
    });
  }
  sendUnsubscribeRequest() {
    return du(this, void 0, void 0, function* () {
      yield this._subscriptionManager.requestManager.send({
        method: "eth_unsubscribe",
        params: [this.id],
      }),
        (this._id = void 0);
    });
  }
  formatSubscriptionResult(t) {
    return t;
  }
  _processSubscriptionResult(t) {
    this.emit("data", this.formatSubscriptionResult(t));
  }
  _processSubscriptionError(t) {
    this.emit("error", t);
  }
  _buildSubscriptionParams() {
    throw new Error("Implement in the child class");
  }
}
var Ao = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class ih extends d$ {
  constructor() {
    super(...arguments),
      (this._addressMap = new Map()),
      (this._defaultKeyName = "web3js_wallet");
  }
  static getStorage() {
    let t;
    try {
      t = window.localStorage;
      const n = "__storage_test__";
      return t.setItem(n, n), t.removeItem(n), t;
    } catch (n) {
      return n &&
        (n.code === 22 ||
          n.code === 1014 ||
          n.name === "QuotaExceededError" ||
          n.name === "NS_ERROR_DOM_QUOTA_REACHED") &&
        !M(t) &&
        t.length !== 0
        ? t
        : void 0;
    }
  }
  create(t) {
    for (let n = 0; n < t; n += 1) this.add(this._accountProvider.create());
    return this;
  }
  add(t) {
    var n;
    if (typeof t == "string")
      return this.add(this._accountProvider.privateKeyToAccount(t));
    let r = this.length;
    return (
      this.get(t.address) &&
        (console.warn(`Account ${t.address.toLowerCase()} already exists.`),
        (r =
          (n = this._addressMap.get(t.address.toLowerCase())) !== null &&
          n !== void 0
            ? n
            : r)),
      this._addressMap.set(t.address.toLowerCase(), r),
      (this[r] = t),
      this
    );
  }
  get(t) {
    if (typeof t == "string") {
      const n = this._addressMap.get(t.toLowerCase());
      return M(n) ? void 0 : this[n];
    }
    return this[t];
  }
  remove(t) {
    if (typeof t == "string") {
      const n = this._addressMap.get(t.toLowerCase());
      return M(n)
        ? !1
        : (this._addressMap.delete(t.toLowerCase()), this.splice(n, 1), !0);
    }
    return this[t] ? (this.splice(t, 1), !0) : !1;
  }
  clear() {
    return this._addressMap.clear(), (this.length = 0), this;
  }
  encrypt(t, n) {
    return Ao(this, void 0, void 0, function* () {
      return Promise.all(
        this.map((r) =>
          Ao(this, void 0, void 0, function* () {
            return r.encrypt(t, n);
          })
        )
      );
    });
  }
  decrypt(t, n, r) {
    return Ao(this, void 0, void 0, function* () {
      const i = yield Promise.all(
        t.map((s) =>
          Ao(this, void 0, void 0, function* () {
            return this._accountProvider.decrypt(s, n, r);
          })
        )
      );
      for (const s of i) this.add(s);
      return this;
    });
  }
  save(t, n) {
    return Ao(this, void 0, void 0, function* () {
      const r = ih.getStorage();
      if (!r) throw new Error("Local storage not available.");
      return (
        r.setItem(
          n ?? this._defaultKeyName,
          JSON.stringify(yield this.encrypt(t))
        ),
        !0
      );
    });
  }
  load(t, n) {
    return Ao(this, void 0, void 0, function* () {
      const r = ih.getStorage();
      if (!r) throw new Error("Local storage not available.");
      const i = r.getItem(n ?? this._defaultKeyName);
      return i && (yield this.decrypt(JSON.parse(i) || [], t)), this;
    });
  }
}
const Tr = { web: Td };
function gT(e, t, n) {
  if (!n.startsWith("aes-"))
    throw new Error(`AES submodule doesn't support mode ${n}`);
  if (t.length !== 16) throw new Error("AES: wrong IV length");
  if (
    (n.startsWith("aes-128") && e.length !== 16) ||
    (n.startsWith("aes-256") && e.length !== 32)
  )
    throw new Error("AES: wrong key length");
}
async function vT(e, t, n) {
  if (!Tr.web) throw new Error("Browser crypto not available.");
  let r;
  if (
    (["aes-128-cbc", "aes-256-cbc"].includes(e) && (r = "cbc"),
    ["aes-128-ctr", "aes-256-ctr"].includes(e) && (r = "ctr"),
    !r)
  )
    throw new Error("AES: unsupported mode");
  return [
    await Tr.web.subtle.importKey(
      "raw",
      t,
      { name: `AES-${r.toUpperCase()}`, length: t.length * 8 },
      !0,
      ["encrypt", "decrypt"]
    ),
    { name: `aes-${r}`, iv: n, counter: n, length: 128 },
  ];
}
async function Yb(e, t, n, r = "aes-128-ctr", i = !0) {
  if ((gT(t, n, r), Tr.web)) {
    const [s, o] = await vT(r, t, n),
      a = await Tr.web.subtle.encrypt(o, s, e);
    let u = new Uint8Array(a);
    return (
      !i && o.name === "aes-cbc" && !(e.length % 16) && (u = u.slice(0, -16)), u
    );
  } else if (Tr.node) {
    const s = Tr.node.createCipheriv(r, t, n);
    return s.setAutoPadding(i), Uf(s.update(e), s.final());
  } else throw new Error("The environment doesn't have AES module");
}
async function yH(e, t, n, r) {
  const i = e.slice(-16);
  for (let o = 0; o < 16; o++) i[o] ^= n[o] ^ 16;
  return (await Yb(i, t, n, r)).slice(0, 16);
}
async function gH(e, t, n, r = "aes-128-ctr", i = !0) {
  if ((gT(t, n, r), Tr.web)) {
    const [s, o] = await vT(r, t, n);
    if (!i && o.name === "aes-cbc") {
      const l = await yH(e, t, n, r);
      e = Uf(e, l);
    }
    const a = await Tr.web.subtle.decrypt(o, s, e),
      u = new Uint8Array(a);
    if (o.name === "aes-cbc") {
      const l = await Yb(u, t, n, r);
      if (!u9(l, e)) throw new Error("AES: wrong padding");
    }
    return u;
  } else if (Tr.node) {
    const s = Tr.node.createDecipheriv(r, t, n);
    return s.setAutoPadding(i), Uf(s.update(e), s.final());
  } else throw new Error("The environment doesn't have AES module");
}
class bT extends Db {
  constructor(t, n) {
    super(), (this.finished = !1), (this.destroyed = !1), qe.hash(t);
    const r = no(n);
    if (((this.iHash = t.create()), typeof this.iHash.update != "function"))
      throw new Error("Expected instance of class which extends utils.Hash");
    (this.blockLen = this.iHash.blockLen),
      (this.outputLen = this.iHash.outputLen);
    const i = this.blockLen,
      s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++) s[o] ^= 54;
    this.iHash.update(s), (this.oHash = t.create());
    for (let o = 0; o < s.length; o++) s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return qe.exists(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    qe.exists(this),
      qe.bytes(t, this.outputLen),
      (this.finished = !0),
      this.iHash.digestInto(t),
      this.oHash.update(t),
      this.oHash.digestInto(t),
      this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const {
      oHash: n,
      iHash: r,
      finished: i,
      destroyed: s,
      blockLen: o,
      outputLen: a,
    } = this;
    return (
      (t = t),
      (t.finished = i),
      (t.destroyed = s),
      (t.blockLen = o),
      (t.outputLen = a),
      (t.oHash = n._cloneInto(t.oHash)),
      (t.iHash = r._cloneInto(t.iHash)),
      t
    );
  }
  destroy() {
    (this.destroyed = !0), this.oHash.destroy(), this.iHash.destroy();
  }
}
const Xb = (e, t, n) => new bT(e, t).update(n).digest();
Xb.create = (e, t) => new bT(e, t);
function vH(e, t, n, r) {
  qe.hash(e);
  const i = g3({ dkLen: 32, asyncTick: 10 }, r),
    { c: s, dkLen: o, asyncTick: a } = i;
  if ((qe.number(s), qe.number(o), qe.number(a), s < 1))
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const u = no(t),
    l = no(n),
    c = new Uint8Array(o),
    d = Xb.create(e, u),
    f = d._cloneInto().update(l);
  return { c: s, dkLen: o, asyncTick: a, DK: c, PRF: d, PRFSalt: f };
}
function bH(e, t, n, r, i) {
  return e.destroy(), t.destroy(), r && r.destroy(), i.fill(0), n;
}
function ew(e, t, n, r) {
  const { c: i, dkLen: s, DK: o, PRF: a, PRFSalt: u } = vH(e, t, n, r);
  let l;
  const c = new Uint8Array(4),
    d = kd(c),
    f = new Uint8Array(a.outputLen);
  for (let p = 1, m = 0; m < s; p++, m += a.outputLen) {
    const g = o.subarray(m, m + a.outputLen);
    d.setInt32(0, p, !1),
      (l = u._cloneInto(l)).update(c).digestInto(f),
      g.set(f.subarray(0, g.length));
    for (let w = 1; w < i; w++) {
      a._cloneInto(l).update(f).digestInto(f);
      for (let v = 0; v < g.length; v++) g[v] ^= f[v];
    }
  }
  return bH(a, u, o, l, f);
}
function wH(e, t, n, r) {
  if (typeof e.setBigUint64 == "function") return e.setBigUint64(t, n, r);
  const i = BigInt(32),
    s = BigInt(4294967295),
    o = Number((n >> i) & s),
    a = Number(n & s),
    u = r ? 4 : 0,
    l = r ? 0 : 4;
  e.setUint32(t + u, o, r), e.setUint32(t + l, a, r);
}
class wT extends Db {
  constructor(t, n, r, i) {
    super(),
      (this.blockLen = t),
      (this.outputLen = n),
      (this.padOffset = r),
      (this.isLE = i),
      (this.finished = !1),
      (this.length = 0),
      (this.pos = 0),
      (this.destroyed = !1),
      (this.buffer = new Uint8Array(t)),
      (this.view = kd(this.buffer));
  }
  update(t) {
    qe.exists(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = no(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const a = Math.min(i - this.pos, s - o);
      if (a === i) {
        const u = kd(t);
        for (; i <= s - o; o += i) this.process(u, o);
        continue;
      }
      r.set(t.subarray(o, o + a), this.pos),
        (this.pos += a),
        (o += a),
        this.pos === i && (this.process(n, 0), (this.pos = 0));
    }
    return (this.length += t.length), this.roundClean(), this;
  }
  digestInto(t) {
    qe.exists(this), qe.output(t, this), (this.finished = !0);
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    (n[o++] = 128),
      this.buffer.subarray(o).fill(0),
      this.padOffset > i - o && (this.process(r, 0), (o = 0));
    for (let d = o; d < i; d++) n[d] = 0;
    wH(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const a = kd(t),
      u = this.outputLen;
    if (u % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const l = u / 4,
      c = this.get();
    if (l > c.length) throw new Error("_sha2: outputLen bigger than state");
    for (let d = 0; d < l; d++) a.setUint32(4 * d, c[d], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const {
      blockLen: n,
      buffer: r,
      length: i,
      finished: s,
      destroyed: o,
      pos: a,
    } = this;
    return (
      (t.length = i),
      (t.pos = a),
      (t.finished = s),
      (t.destroyed = o),
      i % n && t.buffer.set(r),
      t
    );
  }
}
const EH = (e, t, n) => (e & t) ^ (~e & n),
  _H = (e, t, n) => (e & t) ^ (e & n) ^ (t & n),
  AH = new Uint32Array([
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993,
    2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987,
    1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
    264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986,
    2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711,
    113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
    1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
    3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
    1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424,
    2428436474, 2756734187, 3204031479, 3329325298,
  ]),
  Si = new Uint32Array([
    1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924,
    528734635, 1541459225,
  ]),
  Ci = new Uint32Array(64);
class ET extends wT {
  constructor() {
    super(64, 32, 8, !1),
      (this.A = Si[0] | 0),
      (this.B = Si[1] | 0),
      (this.C = Si[2] | 0),
      (this.D = Si[3] | 0),
      (this.E = Si[4] | 0),
      (this.F = Si[5] | 0),
      (this.G = Si[6] | 0),
      (this.H = Si[7] | 0);
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: a, H: u } = this;
    return [t, n, r, i, s, o, a, u];
  }
  set(t, n, r, i, s, o, a, u) {
    (this.A = t | 0),
      (this.B = n | 0),
      (this.C = r | 0),
      (this.D = i | 0),
      (this.E = s | 0),
      (this.F = o | 0),
      (this.G = a | 0),
      (this.H = u | 0);
  }
  process(t, n) {
    for (let d = 0; d < 16; d++, n += 4) Ci[d] = t.getUint32(n, !1);
    for (let d = 16; d < 64; d++) {
      const f = Ci[d - 15],
        p = Ci[d - 2],
        m = Er(f, 7) ^ Er(f, 18) ^ (f >>> 3),
        g = Er(p, 17) ^ Er(p, 19) ^ (p >>> 10);
      Ci[d] = (g + Ci[d - 7] + m + Ci[d - 16]) | 0;
    }
    let { A: r, B: i, C: s, D: o, E: a, F: u, G: l, H: c } = this;
    for (let d = 0; d < 64; d++) {
      const f = Er(a, 6) ^ Er(a, 11) ^ Er(a, 25),
        p = (c + f + EH(a, u, l) + AH[d] + Ci[d]) | 0,
        g = ((Er(r, 2) ^ Er(r, 13) ^ Er(r, 22)) + _H(r, i, s)) | 0;
      (c = l),
        (l = u),
        (u = a),
        (a = (o + p) | 0),
        (o = s),
        (s = i),
        (i = r),
        (r = (p + g) | 0);
    }
    (r = (r + this.A) | 0),
      (i = (i + this.B) | 0),
      (s = (s + this.C) | 0),
      (o = (o + this.D) | 0),
      (a = (a + this.E) | 0),
      (u = (u + this.F) | 0),
      (l = (l + this.G) | 0),
      (c = (c + this.H) | 0),
      this.set(r, i, s, o, a, u, l, c);
  }
  roundClean() {
    Ci.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
class xH extends ET {
  constructor() {
    super(),
      (this.A = -1056596264),
      (this.B = 914150663),
      (this.C = 812702999),
      (this.D = -150054599),
      (this.E = -4191439),
      (this.F = 1750603025),
      (this.G = 1694076839),
      (this.H = -1090891868),
      (this.outputLen = 28);
  }
}
const Ep = yo(() => new ET());
yo(() => new xH());
const [SH, CH] = oe.split(
    [
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817",
    ].map((e) => BigInt(e))
  ),
  Ti = new Uint32Array(80),
  Ii = new Uint32Array(80);
class _p extends wT {
  constructor() {
    super(128, 64, 16, !1),
      (this.Ah = 1779033703),
      (this.Al = -205731576),
      (this.Bh = -1150833019),
      (this.Bl = -2067093701),
      (this.Ch = 1013904242),
      (this.Cl = -23791573),
      (this.Dh = -1521486534),
      (this.Dl = 1595750129),
      (this.Eh = 1359893119),
      (this.El = -1377402159),
      (this.Fh = -1694144372),
      (this.Fl = 725511199),
      (this.Gh = 528734635),
      (this.Gl = -79577749),
      (this.Hh = 1541459225),
      (this.Hl = 327033209);
  }
  get() {
    const {
      Ah: t,
      Al: n,
      Bh: r,
      Bl: i,
      Ch: s,
      Cl: o,
      Dh: a,
      Dl: u,
      Eh: l,
      El: c,
      Fh: d,
      Fl: f,
      Gh: p,
      Gl: m,
      Hh: g,
      Hl: w,
    } = this;
    return [t, n, r, i, s, o, a, u, l, c, d, f, p, m, g, w];
  }
  set(t, n, r, i, s, o, a, u, l, c, d, f, p, m, g, w) {
    (this.Ah = t | 0),
      (this.Al = n | 0),
      (this.Bh = r | 0),
      (this.Bl = i | 0),
      (this.Ch = s | 0),
      (this.Cl = o | 0),
      (this.Dh = a | 0),
      (this.Dl = u | 0),
      (this.Eh = l | 0),
      (this.El = c | 0),
      (this.Fh = d | 0),
      (this.Fl = f | 0),
      (this.Gh = p | 0),
      (this.Gl = m | 0),
      (this.Hh = g | 0),
      (this.Hl = w | 0);
  }
  process(t, n) {
    for (let b = 0; b < 16; b++, n += 4)
      (Ti[b] = t.getUint32(n)), (Ii[b] = t.getUint32((n += 4)));
    for (let b = 16; b < 80; b++) {
      const _ = Ti[b - 15] | 0,
        A = Ii[b - 15] | 0,
        x = oe.rotrSH(_, A, 1) ^ oe.rotrSH(_, A, 8) ^ oe.shrSH(_, A, 7),
        h = oe.rotrSL(_, A, 1) ^ oe.rotrSL(_, A, 8) ^ oe.shrSL(_, A, 7),
        E = Ti[b - 2] | 0,
        I = Ii[b - 2] | 0,
        C = oe.rotrSH(E, I, 19) ^ oe.rotrBH(E, I, 61) ^ oe.shrSH(E, I, 6),
        k = oe.rotrSL(E, I, 19) ^ oe.rotrBL(E, I, 61) ^ oe.shrSL(E, I, 6),
        O = oe.add4L(h, k, Ii[b - 7], Ii[b - 16]),
        R = oe.add4H(O, x, C, Ti[b - 7], Ti[b - 16]);
      (Ti[b] = R | 0), (Ii[b] = O | 0);
    }
    let {
      Ah: r,
      Al: i,
      Bh: s,
      Bl: o,
      Ch: a,
      Cl: u,
      Dh: l,
      Dl: c,
      Eh: d,
      El: f,
      Fh: p,
      Fl: m,
      Gh: g,
      Gl: w,
      Hh: v,
      Hl: y,
    } = this;
    for (let b = 0; b < 80; b++) {
      const _ = oe.rotrSH(d, f, 14) ^ oe.rotrSH(d, f, 18) ^ oe.rotrBH(d, f, 41),
        A = oe.rotrSL(d, f, 14) ^ oe.rotrSL(d, f, 18) ^ oe.rotrBL(d, f, 41),
        x = (d & p) ^ (~d & g),
        h = (f & m) ^ (~f & w),
        E = oe.add5L(y, A, h, CH[b], Ii[b]),
        I = oe.add5H(E, v, _, x, SH[b], Ti[b]),
        C = E | 0,
        k = oe.rotrSH(r, i, 28) ^ oe.rotrBH(r, i, 34) ^ oe.rotrBH(r, i, 39),
        O = oe.rotrSL(r, i, 28) ^ oe.rotrBL(r, i, 34) ^ oe.rotrBL(r, i, 39),
        R = (r & s) ^ (r & a) ^ (s & a),
        N = (i & o) ^ (i & u) ^ (o & u);
      (v = g | 0),
        (y = w | 0),
        (g = p | 0),
        (w = m | 0),
        (p = d | 0),
        (m = f | 0),
        ({ h: d, l: f } = oe.add(l | 0, c | 0, I | 0, C | 0)),
        (l = a | 0),
        (c = u | 0),
        (a = s | 0),
        (u = o | 0),
        (s = r | 0),
        (o = i | 0);
      const S = oe.add3L(C, O, N);
      (r = oe.add3H(S, I, k, R)), (i = S | 0);
    }
    ({ h: r, l: i } = oe.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)),
      ({ h: s, l: o } = oe.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0)),
      ({ h: a, l: u } = oe.add(this.Ch | 0, this.Cl | 0, a | 0, u | 0)),
      ({ h: l, l: c } = oe.add(this.Dh | 0, this.Dl | 0, l | 0, c | 0)),
      ({ h: d, l: f } = oe.add(this.Eh | 0, this.El | 0, d | 0, f | 0)),
      ({ h: p, l: m } = oe.add(this.Fh | 0, this.Fl | 0, p | 0, m | 0)),
      ({ h: g, l: w } = oe.add(this.Gh | 0, this.Gl | 0, g | 0, w | 0)),
      ({ h: v, l: y } = oe.add(this.Hh | 0, this.Hl | 0, v | 0, y | 0)),
      this.set(r, i, s, o, a, u, l, c, d, f, p, m, g, w, v, y);
  }
  roundClean() {
    Ti.fill(0), Ii.fill(0);
  }
  destroy() {
    this.buffer.fill(0),
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
class TH extends _p {
  constructor() {
    super(),
      (this.Ah = -1942145080),
      (this.Al = 424955298),
      (this.Bh = 1944164710),
      (this.Bl = -1982016298),
      (this.Ch = 502970286),
      (this.Cl = 855612546),
      (this.Dh = 1738396948),
      (this.Dl = 1479516111),
      (this.Eh = 258812777),
      (this.El = 2077511080),
      (this.Fh = 2011393907),
      (this.Fl = 79989058),
      (this.Gh = 1067287976),
      (this.Gl = 1780299464),
      (this.Hh = 286451373),
      (this.Hl = -1848208735),
      (this.outputLen = 28);
  }
}
class IH extends _p {
  constructor() {
    super(),
      (this.Ah = 573645204),
      (this.Al = -64227540),
      (this.Bh = -1621794909),
      (this.Bl = -934517566),
      (this.Ch = 596883563),
      (this.Cl = 1867755857),
      (this.Dh = -1774684391),
      (this.Dl = 1497426621),
      (this.Eh = -1775747358),
      (this.El = -1467023389),
      (this.Fh = -1101128155),
      (this.Fl = 1401305490),
      (this.Gh = 721525244),
      (this.Gl = 746961066),
      (this.Hh = 246885852),
      (this.Hl = -2117784414),
      (this.outputLen = 32);
  }
}
class kH extends _p {
  constructor() {
    super(),
      (this.Ah = -876896931),
      (this.Al = -1056596264),
      (this.Bh = 1654270250),
      (this.Bl = 914150663),
      (this.Ch = -1856437926),
      (this.Cl = 812702999),
      (this.Dh = 355462360),
      (this.Dl = -150054599),
      (this.Eh = 1731405415),
      (this.El = -4191439),
      (this.Fh = -1900787065),
      (this.Fl = 1750603025),
      (this.Gh = -619958771),
      (this.Gl = 1694076839),
      (this.Hh = 1203062813),
      (this.Hl = -1090891868),
      (this.outputLen = 48);
  }
}
const PH = yo(() => new _p());
yo(() => new TH());
yo(() => new IH());
yo(() => new kH());
function _T(e, t, n, r, i) {
  if (!["sha256", "sha512"].includes(i))
    throw new Error("Only sha256 and sha512 are supported");
  return $f(e), $f(t), ew(i === "sha256" ? Ep : PH, e, t, { c: n, dkLen: r });
}
const ke = (e, t) => (e << t) | (e >>> (32 - t));
function U_(e, t, n, r, i, s) {
  let o = e[t++] ^ n[r++],
    a = e[t++] ^ n[r++],
    u = e[t++] ^ n[r++],
    l = e[t++] ^ n[r++],
    c = e[t++] ^ n[r++],
    d = e[t++] ^ n[r++],
    f = e[t++] ^ n[r++],
    p = e[t++] ^ n[r++],
    m = e[t++] ^ n[r++],
    g = e[t++] ^ n[r++],
    w = e[t++] ^ n[r++],
    v = e[t++] ^ n[r++],
    y = e[t++] ^ n[r++],
    b = e[t++] ^ n[r++],
    _ = e[t++] ^ n[r++],
    A = e[t++] ^ n[r++],
    x = o,
    h = a,
    E = u,
    I = l,
    C = c,
    k = d,
    O = f,
    R = p,
    N = m,
    S = g,
    T = w,
    D = v,
    P = y,
    B = b,
    L = _,
    Q = A;
  for (let z = 0; z < 8; z += 2)
    (C ^= ke((x + P) | 0, 7)),
      (N ^= ke((C + x) | 0, 9)),
      (P ^= ke((N + C) | 0, 13)),
      (x ^= ke((P + N) | 0, 18)),
      (S ^= ke((k + h) | 0, 7)),
      (B ^= ke((S + k) | 0, 9)),
      (h ^= ke((B + S) | 0, 13)),
      (k ^= ke((h + B) | 0, 18)),
      (L ^= ke((T + O) | 0, 7)),
      (E ^= ke((L + T) | 0, 9)),
      (O ^= ke((E + L) | 0, 13)),
      (T ^= ke((O + E) | 0, 18)),
      (I ^= ke((Q + D) | 0, 7)),
      (R ^= ke((I + Q) | 0, 9)),
      (D ^= ke((R + I) | 0, 13)),
      (Q ^= ke((D + R) | 0, 18)),
      (h ^= ke((x + I) | 0, 7)),
      (E ^= ke((h + x) | 0, 9)),
      (I ^= ke((E + h) | 0, 13)),
      (x ^= ke((I + E) | 0, 18)),
      (O ^= ke((k + C) | 0, 7)),
      (R ^= ke((O + k) | 0, 9)),
      (C ^= ke((R + O) | 0, 13)),
      (k ^= ke((C + R) | 0, 18)),
      (D ^= ke((T + S) | 0, 7)),
      (N ^= ke((D + T) | 0, 9)),
      (S ^= ke((N + D) | 0, 13)),
      (T ^= ke((S + N) | 0, 18)),
      (P ^= ke((Q + L) | 0, 7)),
      (B ^= ke((P + Q) | 0, 9)),
      (L ^= ke((B + P) | 0, 13)),
      (Q ^= ke((L + B) | 0, 18));
  (i[s++] = (o + x) | 0),
    (i[s++] = (a + h) | 0),
    (i[s++] = (u + E) | 0),
    (i[s++] = (l + I) | 0),
    (i[s++] = (c + C) | 0),
    (i[s++] = (d + k) | 0),
    (i[s++] = (f + O) | 0),
    (i[s++] = (p + R) | 0),
    (i[s++] = (m + N) | 0),
    (i[s++] = (g + S) | 0),
    (i[s++] = (w + T) | 0),
    (i[s++] = (v + D) | 0),
    (i[s++] = (y + P) | 0),
    (i[s++] = (b + B) | 0),
    (i[s++] = (_ + L) | 0),
    (i[s++] = (A + Q) | 0);
}
function qm(e, t, n, r, i) {
  let s = r + 0,
    o = r + 16 * i;
  for (let a = 0; a < 16; a++) n[o + a] = e[t + (2 * i - 1) * 16 + a];
  for (let a = 0; a < i; a++, s += 16, t += 16)
    U_(n, o, e, t, n, s), a > 0 && (o += 16), U_(n, s, e, (t += 16), n, o);
}
function DH(e, t, n) {
  const r = g3({ dkLen: 32, asyncTick: 10, maxmem: 1073742848 }, n),
    { N: i, r: s, p: o, dkLen: a, asyncTick: u, maxmem: l, onProgress: c } = r;
  if (
    (qe.number(i),
    qe.number(s),
    qe.number(o),
    qe.number(a),
    qe.number(u),
    qe.number(l),
    c !== void 0 && typeof c != "function")
  )
    throw new Error("progressCb should be function");
  const d = 128 * s,
    f = d / 4;
  if (i <= 1 || i & (i - 1) || i >= 2 ** (d / 8) || i > 2 ** 32)
    throw new Error(
      "Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32"
    );
  if (o < 0 || o > ((2 ** 32 - 1) * 32) / d)
    throw new Error(
      "Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)"
    );
  if (a < 0 || a > (2 ** 32 - 1) * 32)
    throw new Error(
      "Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32"
    );
  const p = d * (i + o);
  if (p > l)
    throw new Error(
      `Scrypt: parameters too large, ${p} (128 * r * (N + p)) > ${l} (maxmem)`
    );
  const m = ew(Ep, e, t, { c: 1, dkLen: d * o }),
    g = Id(m),
    w = Id(new Uint8Array(d * i)),
    v = Id(new Uint8Array(d));
  let y = () => {};
  if (c) {
    const b = 2 * i * o,
      _ = Math.max(Math.floor(b / 1e4), 1);
    let A = 0;
    y = () => {
      A++, c && (!(A % _) || A === b) && c(A / b);
    };
  }
  return {
    N: i,
    r: s,
    p: o,
    dkLen: a,
    blockSize32: f,
    V: w,
    B32: g,
    B: m,
    tmp: v,
    blockMixCb: y,
    asyncTick: u,
  };
}
function OH(e, t, n, r, i) {
  const s = ew(Ep, e, n, { c: 1, dkLen: t });
  return n.fill(0), r.fill(0), i.fill(0), s;
}
function RH(e, t, n) {
  const {
    N: r,
    r: i,
    p: s,
    dkLen: o,
    blockSize32: a,
    V: u,
    B32: l,
    B: c,
    tmp: d,
    blockMixCb: f,
  } = DH(e, t, n);
  for (let p = 0; p < s; p++) {
    const m = a * p;
    for (let g = 0; g < a; g++) u[g] = l[m + g];
    for (let g = 0, w = 0; g < r - 1; g++) qm(u, w, u, (w += a), i), f();
    qm(u, (r - 1) * a, l, m, i), f();
    for (let g = 0; g < r; g++) {
      const w = l[m + a - 16] % r;
      for (let v = 0; v < a; v++) d[v] = l[m + v] ^ u[w * a + v];
      qm(d, 0, l, m, i), f();
    }
  }
  return OH(e, o, c, u, d);
}
function AT(e, t, n, r, i, s, o) {
  return $f(e), $f(t), RH(e, t, { N: n, r: i, p: r, dkLen: s, onProgress: o });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const xT =
    BigInt(0),
  Ap = BigInt(1),
  BH = BigInt(2),
  xp = (e) => e instanceof Uint8Array,
  NH = Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ca(e) {
  if (!xp(e)) throw new Error("Uint8Array expected");
  let t = "";
  for (let n = 0; n < e.length; n++) t += NH[e[n]];
  return t;
}
function ST(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function tw(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
function Ta(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length;
  if (t % 2)
    throw new Error(
      "padded hex string expected, got unpadded hex of length " + t
    );
  const n = new Uint8Array(t / 2);
  for (let r = 0; r < n.length; r++) {
    const i = r * 2,
      s = e.slice(i, i + 2),
      o = Number.parseInt(s, 16);
    if (Number.isNaN(o) || o < 0) throw new Error("Invalid byte sequence");
    n[r] = o;
  }
  return n;
}
function Ws(e) {
  return tw(Ca(e));
}
function nw(e) {
  if (!xp(e)) throw new Error("Uint8Array expected");
  return tw(Ca(Uint8Array.from(e).reverse()));
}
function aa(e, t) {
  return Ta(e.toString(16).padStart(t * 2, "0"));
}
function CT(e, t) {
  return aa(e, t).reverse();
}
function MH(e) {
  return Ta(ST(e));
}
function $n(e, t, n) {
  let r;
  if (typeof t == "string")
    try {
      r = Ta(t);
    } catch (s) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`);
    }
  else if (xp(t)) r = Uint8Array.from(t);
  else throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r;
}
function Wc(...e) {
  const t = new Uint8Array(e.reduce((r, i) => r + i.length, 0));
  let n = 0;
  return (
    e.forEach((r) => {
      if (!xp(r)) throw new Error("Uint8Array expected");
      t.set(r, n), (n += r.length);
    }),
    t
  );
}
function LH(e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++) if (e[n] !== t[n]) return !1;
  return !0;
}
function FH(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function jH(e) {
  let t;
  for (t = 0; e > xT; e >>= Ap, t += 1);
  return t;
}
function UH(e, t) {
  return (e >> BigInt(t)) & Ap;
}
const $H = (e, t, n) => e | ((n ? Ap : xT) << BigInt(t)),
  rw = (e) => (BH << BigInt(e - 1)) - Ap,
  Wm = (e) => new Uint8Array(e),
  $_ = (e) => Uint8Array.from(e);
function TT(e, t, n) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function") throw new Error("hmacFn must be a function");
  let r = Wm(e),
    i = Wm(e),
    s = 0;
  const o = () => {
      r.fill(1), i.fill(0), (s = 0);
    },
    a = (...d) => n(i, r, ...d),
    u = (d = Wm()) => {
      (i = a($_([0]), d)),
        (r = a()),
        d.length !== 0 && ((i = a($_([1]), d)), (r = a()));
    },
    l = () => {
      if (s++ >= 1e3) throw new Error("drbg: tried 1000 values");
      let d = 0;
      const f = [];
      for (; d < t; ) {
        r = a();
        const p = r.slice();
        f.push(p), (d += r.length);
      }
      return Wc(...f);
    };
  return (d, f) => {
    o(), u(d);
    let p;
    for (; !(p = f(l())); ) u();
    return o(), p;
  };
}
const HH = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen),
};
function _l(e, t, n = {}) {
  const r = (i, s, o) => {
    const a = HH[s];
    if (typeof a != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const u = e[i];
    if (!(o && u === void 0) && !a(u, e))
      throw new Error(
        `Invalid param ${String(i)}=${u} (${typeof u}), expected ${s}`
      );
  };
  for (const [i, s] of Object.entries(t)) r(i, s, !1);
  for (const [i, s] of Object.entries(n)) r(i, s, !0);
  return e;
}
const zH = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      bitGet: UH,
      bitLen: jH,
      bitMask: rw,
      bitSet: $H,
      bytesToHex: Ca,
      bytesToNumberBE: Ws,
      bytesToNumberLE: nw,
      concatBytes: Wc,
      createHmacDrbg: TT,
      ensureBytes: $n,
      equalBytes: LH,
      hexToBytes: Ta,
      hexToNumber: tw,
      numberToBytesBE: aa,
      numberToBytesLE: CT,
      numberToHexUnpadded: ST,
      numberToVarBytesBE: MH,
      utf8ToBytes: FH,
      validateObject: _l,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const wt =
    BigInt(0),
  ot = BigInt(1),
  ks = BigInt(2),
  GH = BigInt(3),
  fg = BigInt(4),
  H_ = BigInt(5),
  z_ = BigInt(8);
BigInt(9);
BigInt(16);
function dn(e, t) {
  const n = e % t;
  return n >= wt ? n : t + n;
}
function qH(e, t, n) {
  if (n <= wt || t < wt) throw new Error("Expected power/modulo > 0");
  if (n === ot) return wt;
  let r = ot;
  for (; t > wt; ) t & ot && (r = (r * e) % n), (e = (e * e) % n), (t >>= ot);
  return r;
}
function Fn(e, t, n) {
  let r = e;
  for (; t-- > wt; ) (r *= r), (r %= n);
  return r;
}
function hg(e, t) {
  if (e === wt || t <= wt)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = dn(e, t),
    r = t,
    i = wt,
    s = ot;
  for (; n !== wt; ) {
    const a = r / n,
      u = r % n,
      l = i - s * a;
    (r = n), (n = u), (i = s), (s = l);
  }
  if (r !== ot) throw new Error("invert: does not exist");
  return dn(i, t);
}
function WH(e) {
  const t = (e - ot) / ks;
  let n, r, i;
  for (n = e - ot, r = 0; n % ks === wt; n /= ks, r++);
  for (i = ks; i < e && qH(i, t, e) !== e - ot; i++);
  if (r === 1) {
    const o = (e + ot) / fg;
    return function (u, l) {
      const c = u.pow(l, o);
      if (!u.eql(u.sqr(c), l)) throw new Error("Cannot find square root");
      return c;
    };
  }
  const s = (n + ot) / ks;
  return function (a, u) {
    if (a.pow(u, t) === a.neg(a.ONE))
      throw new Error("Cannot find square root");
    let l = r,
      c = a.pow(a.mul(a.ONE, i), n),
      d = a.pow(u, s),
      f = a.pow(u, n);
    for (; !a.eql(f, a.ONE); ) {
      if (a.eql(f, a.ZERO)) return a.ZERO;
      let p = 1;
      for (let g = a.sqr(f); p < l && !a.eql(g, a.ONE); p++) g = a.sqr(g);
      const m = a.pow(c, ot << BigInt(l - p - 1));
      (c = a.sqr(m)), (d = a.mul(d, m)), (f = a.mul(f, c)), (l = p);
    }
    return d;
  };
}
function QH(e) {
  if (e % fg === GH) {
    const t = (e + ot) / fg;
    return function (r, i) {
      const s = r.pow(i, t);
      if (!r.eql(r.sqr(s), i)) throw new Error("Cannot find square root");
      return s;
    };
  }
  if (e % z_ === H_) {
    const t = (e - H_) / z_;
    return function (r, i) {
      const s = r.mul(i, ks),
        o = r.pow(s, t),
        a = r.mul(i, o),
        u = r.mul(r.mul(a, ks), o),
        l = r.mul(a, r.sub(u, r.ONE));
      if (!r.eql(r.sqr(l), i)) throw new Error("Cannot find square root");
      return l;
    };
  }
  return WH(e);
}
const VH = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN",
];
function KH(e) {
  const t = {
      ORDER: "bigint",
      MASK: "bigint",
      BYTES: "isSafeInteger",
      BITS: "isSafeInteger",
    },
    n = VH.reduce((r, i) => ((r[i] = "function"), r), t);
  return _l(e, n);
}
function ZH(e, t, n) {
  if (n < wt) throw new Error("Expected power > 0");
  if (n === wt) return e.ONE;
  if (n === ot) return t;
  let r = e.ONE,
    i = t;
  for (; n > wt; ) n & ot && (r = e.mul(r, i)), (i = e.sqr(i)), (n >>= ot);
  return r;
}
function JH(e, t) {
  const n = new Array(t.length),
    r = t.reduce(
      (s, o, a) => (e.is0(o) ? s : ((n[a] = s), e.mul(s, o))),
      e.ONE
    ),
    i = e.inv(r);
  return (
    t.reduceRight(
      (s, o, a) => (e.is0(o) ? s : ((n[a] = e.mul(s, n[a])), e.mul(s, o))),
      i
    ),
    n
  );
}
function iw(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length,
    r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function YH(e, t, n = !1, r = {}) {
  if (e <= wt) throw new Error(`Expected Fp ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: s } = iw(e, t);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = QH(e),
    a = Object.freeze({
      ORDER: e,
      BITS: i,
      BYTES: s,
      MASK: rw(i),
      ZERO: wt,
      ONE: ot,
      create: (u) => dn(u, e),
      isValid: (u) => {
        if (typeof u != "bigint")
          throw new Error(
            `Invalid field element: expected bigint, got ${typeof u}`
          );
        return wt <= u && u < e;
      },
      is0: (u) => u === wt,
      isOdd: (u) => (u & ot) === ot,
      neg: (u) => dn(-u, e),
      eql: (u, l) => u === l,
      sqr: (u) => dn(u * u, e),
      add: (u, l) => dn(u + l, e),
      sub: (u, l) => dn(u - l, e),
      mul: (u, l) => dn(u * l, e),
      pow: (u, l) => ZH(a, u, l),
      div: (u, l) => dn(u * hg(l, e), e),
      sqrN: (u) => u * u,
      addN: (u, l) => u + l,
      subN: (u, l) => u - l,
      mulN: (u, l) => u * l,
      inv: (u) => hg(u, e),
      sqrt: r.sqrt || ((u) => o(a, u)),
      invertBatch: (u) => JH(a, u),
      cmov: (u, l, c) => (c ? l : u),
      toBytes: (u) => (n ? CT(u, s) : aa(u, s)),
      fromBytes: (u) => {
        if (u.length !== s)
          throw new Error(`Fp.fromBytes: expected ${s}, got ${u.length}`);
        return n ? nw(u) : Ws(u);
      },
    });
  return Object.freeze(a);
}
function XH(e, t, n = !1) {
  e = $n("privateHash", e);
  const r = e.length,
    i = iw(t).nByteLength + 8;
  if (i < 24 || r < i || r > 1024)
    throw new Error(
      `hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${r}`
    );
  const s = n ? nw(e) : Ws(e);
  return dn(s, t - ot) + ot;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const e7 =
    BigInt(0),
  Qm = BigInt(1);
function t7(e, t) {
  const n = (i, s) => {
      const o = s.negate();
      return i ? o : s;
    },
    r = (i) => {
      const s = Math.ceil(t / i) + 1,
        o = 2 ** (i - 1);
      return { windows: s, windowSize: o };
    };
  return {
    constTimeNegate: n,
    unsafeLadder(i, s) {
      let o = e.ZERO,
        a = i;
      for (; s > e7; ) s & Qm && (o = o.add(a)), (a = a.double()), (s >>= Qm);
      return o;
    },
    precomputeWindow(i, s) {
      const { windows: o, windowSize: a } = r(s),
        u = [];
      let l = i,
        c = l;
      for (let d = 0; d < o; d++) {
        (c = l), u.push(c);
        for (let f = 1; f < a; f++) (c = c.add(l)), u.push(c);
        l = c.double();
      }
      return u;
    },
    wNAF(i, s, o) {
      const { windows: a, windowSize: u } = r(i);
      let l = e.ZERO,
        c = e.BASE;
      const d = BigInt(2 ** i - 1),
        f = 2 ** i,
        p = BigInt(i);
      for (let m = 0; m < a; m++) {
        const g = m * u;
        let w = Number(o & d);
        (o >>= p), w > u && ((w -= f), (o += Qm));
        const v = g,
          y = g + Math.abs(w) - 1,
          b = m % 2 !== 0,
          _ = w < 0;
        w === 0 ? (c = c.add(n(b, s[v]))) : (l = l.add(n(_, s[y])));
      }
      return { p: l, f: c };
    },
    wNAFCached(i, s, o, a) {
      const u = i._WINDOW_SIZE || 1;
      let l = s.get(i);
      return (
        l || ((l = this.precomputeWindow(i, u)), u !== 1 && s.set(i, a(l))),
        this.wNAF(u, l, o)
      );
    },
  };
}
function IT(e) {
  return (
    KH(e.Fp),
    _l(
      e,
      { n: "bigint", h: "bigint", Gx: "field", Gy: "field" },
      { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }
    ),
    Object.freeze({ ...iw(e.n, e.nBitLength), ...e, p: e.Fp.ORDER })
  );
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function n7(
  e
) {
  const t = IT(e);
  _l(
    t,
    { a: "field", b: "field" },
    {
      allowedPrivateKeyLengths: "array",
      wrapPrivateKey: "boolean",
      isTorsionFree: "function",
      clearCofactor: "function",
      allowInfinityPoint: "boolean",
      fromBytes: "function",
      toBytes: "function",
    }
  );
  const { endo: n, Fp: r, a: i } = t;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error(
        "Endomorphism can only be defined for Koblitz curves that have a=0"
      );
    if (
      typeof n != "object" ||
      typeof n.beta != "bigint" ||
      typeof n.splitScalar != "function"
    )
      throw new Error(
        "Expected endomorphism with beta: bigint and splitScalar: function"
      );
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: r7, hexToBytes: i7 } = zH,
  Ns = {
    Err: class extends Error {
      constructor(t = "") {
        super(t);
      }
    },
    _parseInt(e) {
      const { Err: t } = Ns;
      if (e.length < 2 || e[0] !== 2)
        throw new t("Invalid signature integer tag");
      const n = e[1],
        r = e.subarray(2, n + 2);
      if (!n || r.length !== n)
        throw new t("Invalid signature integer: wrong length");
      if (r[0] & 128) throw new t("Invalid signature integer: negative");
      if (r[0] === 0 && !(r[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return { d: r7(r), l: e.subarray(n + 2) };
    },
    toSig(e) {
      const { Err: t } = Ns,
        n = typeof e == "string" ? i7(e) : e;
      if (!(n instanceof Uint8Array)) throw new Error("ui8a expected");
      let r = n.length;
      if (r < 2 || n[0] != 48) throw new t("Invalid signature tag");
      if (n[1] !== r - 2) throw new t("Invalid signature: incorrect length");
      const { d: i, l: s } = Ns._parseInt(n.subarray(2)),
        { d: o, l: a } = Ns._parseInt(s);
      if (a.length) throw new t("Invalid signature: left bytes after parsing");
      return { r: i, s: o };
    },
    hexFromSig(e) {
      const t = (l) => (Number.parseInt(l[0], 16) & 8 ? "00" + l : l),
        n = (l) => {
          const c = l.toString(16);
          return c.length & 1 ? `0${c}` : c;
        },
        r = t(n(e.s)),
        i = t(n(e.r)),
        s = r.length / 2,
        o = i.length / 2,
        a = n(s),
        u = n(o);
      return `30${n(o + s + 4)}02${u}${i}02${a}${r}`;
    },
  },
  Jr = BigInt(0),
  Hn = BigInt(1);
BigInt(2);
const G_ = BigInt(3);
BigInt(4);
function s7(e) {
  const t = n7(e),
    { Fp: n } = t,
    r =
      t.toBytes ||
      ((m, g, w) => {
        const v = g.toAffine();
        return Wc(Uint8Array.from([4]), n.toBytes(v.x), n.toBytes(v.y));
      }),
    i =
      t.fromBytes ||
      ((m) => {
        const g = m.subarray(1),
          w = n.fromBytes(g.subarray(0, n.BYTES)),
          v = n.fromBytes(g.subarray(n.BYTES, 2 * n.BYTES));
        return { x: w, y: v };
      });
  function s(m) {
    const { a: g, b: w } = t,
      v = n.sqr(m),
      y = n.mul(v, m);
    return n.add(n.add(y, n.mul(m, g)), w);
  }
  if (!n.eql(n.sqr(t.Gy), s(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function o(m) {
    return typeof m == "bigint" && Jr < m && m < t.n;
  }
  function a(m) {
    if (!o(m)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function u(m) {
    const {
      allowedPrivateKeyLengths: g,
      nByteLength: w,
      wrapPrivateKey: v,
      n: y,
    } = t;
    if (g && typeof m != "bigint") {
      if (
        (m instanceof Uint8Array && (m = Ca(m)),
        typeof m != "string" || !g.includes(m.length))
      )
        throw new Error("Invalid key");
      m = m.padStart(w * 2, "0");
    }
    let b;
    try {
      b = typeof m == "bigint" ? m : Ws($n("private key", m, w));
    } catch {
      throw new Error(
        `private key must be ${w} bytes, hex or bigint, not ${typeof m}`
      );
    }
    return v && (b = dn(b, y)), a(b), b;
  }
  const l = new Map();
  function c(m) {
    if (!(m instanceof d)) throw new Error("ProjectivePoint expected");
  }
  class d {
    constructor(g, w, v) {
      if (
        ((this.px = g),
        (this.py = w),
        (this.pz = v),
        g == null || !n.isValid(g))
      )
        throw new Error("x required");
      if (w == null || !n.isValid(w)) throw new Error("y required");
      if (v == null || !n.isValid(v)) throw new Error("z required");
    }
    static fromAffine(g) {
      const { x: w, y: v } = g || {};
      if (!g || !n.isValid(w) || !n.isValid(v))
        throw new Error("invalid affine point");
      if (g instanceof d) throw new Error("projective point not allowed");
      const y = (b) => n.eql(b, n.ZERO);
      return y(w) && y(v) ? d.ZERO : new d(w, v, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(g) {
      const w = n.invertBatch(g.map((v) => v.pz));
      return g.map((v, y) => v.toAffine(w[y])).map(d.fromAffine);
    }
    static fromHex(g) {
      const w = d.fromAffine(i($n("pointHex", g)));
      return w.assertValidity(), w;
    }
    static fromPrivateKey(g) {
      return d.BASE.multiply(u(g));
    }
    _setWindowSize(g) {
      (this._WINDOW_SIZE = g), l.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (t.allowInfinityPoint) return;
        throw new Error("bad point: ZERO");
      }
      const { x: g, y: w } = this.toAffine();
      if (!n.isValid(g) || !n.isValid(w))
        throw new Error("bad point: x or y not FE");
      const v = n.sqr(w),
        y = s(g);
      if (!n.eql(v, y)) throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: g } = this.toAffine();
      if (n.isOdd) return !n.isOdd(g);
      throw new Error("Field doesn't support isOdd");
    }
    equals(g) {
      c(g);
      const { px: w, py: v, pz: y } = this,
        { px: b, py: _, pz: A } = g,
        x = n.eql(n.mul(w, A), n.mul(b, y)),
        h = n.eql(n.mul(v, A), n.mul(_, y));
      return x && h;
    }
    negate() {
      return new d(this.px, n.neg(this.py), this.pz);
    }
    double() {
      const { a: g, b: w } = t,
        v = n.mul(w, G_),
        { px: y, py: b, pz: _ } = this;
      let A = n.ZERO,
        x = n.ZERO,
        h = n.ZERO,
        E = n.mul(y, y),
        I = n.mul(b, b),
        C = n.mul(_, _),
        k = n.mul(y, b);
      return (
        (k = n.add(k, k)),
        (h = n.mul(y, _)),
        (h = n.add(h, h)),
        (A = n.mul(g, h)),
        (x = n.mul(v, C)),
        (x = n.add(A, x)),
        (A = n.sub(I, x)),
        (x = n.add(I, x)),
        (x = n.mul(A, x)),
        (A = n.mul(k, A)),
        (h = n.mul(v, h)),
        (C = n.mul(g, C)),
        (k = n.sub(E, C)),
        (k = n.mul(g, k)),
        (k = n.add(k, h)),
        (h = n.add(E, E)),
        (E = n.add(h, E)),
        (E = n.add(E, C)),
        (E = n.mul(E, k)),
        (x = n.add(x, E)),
        (C = n.mul(b, _)),
        (C = n.add(C, C)),
        (E = n.mul(C, k)),
        (A = n.sub(A, E)),
        (h = n.mul(C, I)),
        (h = n.add(h, h)),
        (h = n.add(h, h)),
        new d(A, x, h)
      );
    }
    add(g) {
      c(g);
      const { px: w, py: v, pz: y } = this,
        { px: b, py: _, pz: A } = g;
      let x = n.ZERO,
        h = n.ZERO,
        E = n.ZERO;
      const I = t.a,
        C = n.mul(t.b, G_);
      let k = n.mul(w, b),
        O = n.mul(v, _),
        R = n.mul(y, A),
        N = n.add(w, v),
        S = n.add(b, _);
      (N = n.mul(N, S)),
        (S = n.add(k, O)),
        (N = n.sub(N, S)),
        (S = n.add(w, y));
      let T = n.add(b, A);
      return (
        (S = n.mul(S, T)),
        (T = n.add(k, R)),
        (S = n.sub(S, T)),
        (T = n.add(v, y)),
        (x = n.add(_, A)),
        (T = n.mul(T, x)),
        (x = n.add(O, R)),
        (T = n.sub(T, x)),
        (E = n.mul(I, S)),
        (x = n.mul(C, R)),
        (E = n.add(x, E)),
        (x = n.sub(O, E)),
        (E = n.add(O, E)),
        (h = n.mul(x, E)),
        (O = n.add(k, k)),
        (O = n.add(O, k)),
        (R = n.mul(I, R)),
        (S = n.mul(C, S)),
        (O = n.add(O, R)),
        (R = n.sub(k, R)),
        (R = n.mul(I, R)),
        (S = n.add(S, R)),
        (k = n.mul(O, S)),
        (h = n.add(h, k)),
        (k = n.mul(T, S)),
        (x = n.mul(N, x)),
        (x = n.sub(x, k)),
        (k = n.mul(N, O)),
        (E = n.mul(T, E)),
        (E = n.add(E, k)),
        new d(x, h, E)
      );
    }
    subtract(g) {
      return this.add(g.negate());
    }
    is0() {
      return this.equals(d.ZERO);
    }
    wNAF(g) {
      return p.wNAFCached(this, l, g, (w) => {
        const v = n.invertBatch(w.map((y) => y.pz));
        return w.map((y, b) => y.toAffine(v[b])).map(d.fromAffine);
      });
    }
    multiplyUnsafe(g) {
      const w = d.ZERO;
      if (g === Jr) return w;
      if ((a(g), g === Hn)) return this;
      const { endo: v } = t;
      if (!v) return p.unsafeLadder(this, g);
      let { k1neg: y, k1: b, k2neg: _, k2: A } = v.splitScalar(g),
        x = w,
        h = w,
        E = this;
      for (; b > Jr || A > Jr; )
        b & Hn && (x = x.add(E)),
          A & Hn && (h = h.add(E)),
          (E = E.double()),
          (b >>= Hn),
          (A >>= Hn);
      return (
        y && (x = x.negate()),
        _ && (h = h.negate()),
        (h = new d(n.mul(h.px, v.beta), h.py, h.pz)),
        x.add(h)
      );
    }
    multiply(g) {
      a(g);
      let w = g,
        v,
        y;
      const { endo: b } = t;
      if (b) {
        const { k1neg: _, k1: A, k2neg: x, k2: h } = b.splitScalar(w);
        let { p: E, f: I } = this.wNAF(A),
          { p: C, f: k } = this.wNAF(h);
        (E = p.constTimeNegate(_, E)),
          (C = p.constTimeNegate(x, C)),
          (C = new d(n.mul(C.px, b.beta), C.py, C.pz)),
          (v = E.add(C)),
          (y = I.add(k));
      } else {
        const { p: _, f: A } = this.wNAF(w);
        (v = _), (y = A);
      }
      return d.normalizeZ([v, y])[0];
    }
    multiplyAndAddUnsafe(g, w, v) {
      const y = d.BASE,
        b = (A, x) =>
          x === Jr || x === Hn || !A.equals(y)
            ? A.multiplyUnsafe(x)
            : A.multiply(x),
        _ = b(this, w).add(b(g, v));
      return _.is0() ? void 0 : _;
    }
    toAffine(g) {
      const { px: w, py: v, pz: y } = this,
        b = this.is0();
      g == null && (g = b ? n.ONE : n.inv(y));
      const _ = n.mul(w, g),
        A = n.mul(v, g),
        x = n.mul(y, g);
      if (b) return { x: n.ZERO, y: n.ZERO };
      if (!n.eql(x, n.ONE)) throw new Error("invZ was invalid");
      return { x: _, y: A };
    }
    isTorsionFree() {
      const { h: g, isTorsionFree: w } = t;
      if (g === Hn) return !0;
      if (w) return w(d, this);
      throw new Error(
        "isTorsionFree() has not been declared for the elliptic curve"
      );
    }
    clearCofactor() {
      const { h: g, clearCofactor: w } = t;
      return g === Hn ? this : w ? w(d, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(g = !0) {
      return this.assertValidity(), r(d, this, g);
    }
    toHex(g = !0) {
      return Ca(this.toRawBytes(g));
    }
  }
  (d.BASE = new d(t.Gx, t.Gy, n.ONE)), (d.ZERO = new d(n.ZERO, n.ONE, n.ZERO));
  const f = t.nBitLength,
    p = t7(d, t.endo ? Math.ceil(f / 2) : f);
  return {
    CURVE: t,
    ProjectivePoint: d,
    normPrivateKeyToScalar: u,
    weierstrassEquation: s,
    isWithinCurveOrder: o,
  };
}
function o7(e) {
  const t = IT(e);
  return (
    _l(
      t,
      { hash: "hash", hmac: "function", randomBytes: "function" },
      { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }
    ),
    Object.freeze({ lowS: !0, ...t })
  );
}
function a7(e) {
  const t = o7(e),
    { Fp: n, n: r } = t,
    i = n.BYTES + 1,
    s = 2 * n.BYTES + 1;
  function o(S) {
    return Jr < S && S < n.ORDER;
  }
  function a(S) {
    return dn(S, r);
  }
  function u(S) {
    return hg(S, r);
  }
  const {
      ProjectivePoint: l,
      normPrivateKeyToScalar: c,
      weierstrassEquation: d,
      isWithinCurveOrder: f,
    } = s7({
      ...t,
      toBytes(S, T, D) {
        const P = T.toAffine(),
          B = n.toBytes(P.x),
          L = Wc;
        return D
          ? L(Uint8Array.from([T.hasEvenY() ? 2 : 3]), B)
          : L(Uint8Array.from([4]), B, n.toBytes(P.y));
      },
      fromBytes(S) {
        const T = S.length,
          D = S[0],
          P = S.subarray(1);
        if (T === i && (D === 2 || D === 3)) {
          const B = Ws(P);
          if (!o(B)) throw new Error("Point is not on curve");
          const L = d(B);
          let Q = n.sqrt(L);
          const z = (Q & Hn) === Hn;
          return ((D & 1) === 1) !== z && (Q = n.neg(Q)), { x: B, y: Q };
        } else if (T === s && D === 4) {
          const B = n.fromBytes(P.subarray(0, n.BYTES)),
            L = n.fromBytes(P.subarray(n.BYTES, 2 * n.BYTES));
          return { x: B, y: L };
        } else
          throw new Error(
            `Point of length ${T} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`
          );
      },
    }),
    p = (S) => Ca(aa(S, t.nByteLength));
  function m(S) {
    const T = r >> Hn;
    return S > T;
  }
  function g(S) {
    return m(S) ? a(-S) : S;
  }
  const w = (S, T, D) => Ws(S.slice(T, D));
  class v {
    constructor(T, D, P) {
      (this.r = T), (this.s = D), (this.recovery = P), this.assertValidity();
    }
    static fromCompact(T) {
      const D = t.nByteLength;
      return (
        (T = $n("compactSignature", T, D * 2)),
        new v(w(T, 0, D), w(T, D, 2 * D))
      );
    }
    static fromDER(T) {
      const { r: D, s: P } = Ns.toSig($n("DER", T));
      return new v(D, P);
    }
    assertValidity() {
      if (!f(this.r)) throw new Error("r must be 0 < r < CURVE.n");
      if (!f(this.s)) throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(T) {
      return new v(this.r, this.s, T);
    }
    recoverPublicKey(T) {
      const { r: D, s: P, recovery: B } = this,
        L = h($n("msgHash", T));
      if (B == null || ![0, 1, 2, 3].includes(B))
        throw new Error("recovery id invalid");
      const Q = B === 2 || B === 3 ? D + t.n : D;
      if (Q >= n.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const z = B & 1 ? "03" : "02",
        j = l.fromHex(z + p(Q)),
        W = u(Q),
        ee = a(-L * W),
        Z = a(P * W),
        ne = l.BASE.multiplyAndAddUnsafe(j, ee, Z);
      if (!ne) throw new Error("point at infinify");
      return ne.assertValidity(), ne;
    }
    hasHighS() {
      return m(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new v(this.r, a(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return Ta(this.toDERHex());
    }
    toDERHex() {
      return Ns.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return Ta(this.toCompactHex());
    }
    toCompactHex() {
      return p(this.r) + p(this.s);
    }
  }
  const y = {
    isValidPrivateKey(S) {
      try {
        return c(S), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: c,
    randomPrivateKey: () => {
      const S = t.randomBytes(n.BYTES + 8),
        T = XH(S, r);
      return aa(T, t.nByteLength);
    },
    precompute(S = 8, T = l.BASE) {
      return T._setWindowSize(S), T.multiply(BigInt(3)), T;
    },
  };
  function b(S, T = !0) {
    return l.fromPrivateKey(S).toRawBytes(T);
  }
  function _(S) {
    const T = S instanceof Uint8Array,
      D = typeof S == "string",
      P = (T || D) && S.length;
    return T
      ? P === i || P === s
      : D
      ? P === 2 * i || P === 2 * s
      : S instanceof l;
  }
  function A(S, T, D = !0) {
    if (_(S)) throw new Error("first arg must be private key");
    if (!_(T)) throw new Error("second arg must be public key");
    return l.fromHex(T).multiply(c(S)).toRawBytes(D);
  }
  const x =
      t.bits2int ||
      function (S) {
        const T = Ws(S),
          D = S.length * 8 - t.nBitLength;
        return D > 0 ? T >> BigInt(D) : T;
      },
    h =
      t.bits2int_modN ||
      function (S) {
        return a(x(S));
      },
    E = rw(t.nBitLength);
  function I(S) {
    if (typeof S != "bigint") throw new Error("bigint expected");
    if (!(Jr <= S && S < E))
      throw new Error(`bigint expected < 2^${t.nBitLength}`);
    return aa(S, t.nByteLength);
  }
  function C(S, T, D = k) {
    if (["recovered", "canonical"].some((de) => de in D))
      throw new Error("sign() legacy options not supported");
    const { hash: P, randomBytes: B } = t;
    let { lowS: L, prehash: Q, extraEntropy: z } = D;
    L == null && (L = !0),
      (S = $n("msgHash", S)),
      Q && (S = $n("prehashed msgHash", P(S)));
    const j = h(S),
      W = c(T),
      ee = [I(W), I(j)];
    if (z != null) {
      const de = z === !0 ? B(n.BYTES) : z;
      ee.push($n("extraEntropy", de, n.BYTES));
    }
    const Z = Wc(...ee),
      ne = j;
    function Ae(de) {
      const ge = x(de);
      if (!f(ge)) return;
      const Oe = u(ge),
        Ie = l.BASE.multiply(ge).toAffine(),
        we = a(Ie.x);
      if (we === Jr) return;
      const ln = a(Oe * a(ne + we * W));
      if (ln === Jr) return;
      let jr = (Ie.x === we ? 0 : 2) | Number(Ie.y & Hn),
        _i = ln;
      return L && m(ln) && ((_i = g(ln)), (jr ^= 1)), new v(we, _i, jr);
    }
    return { seed: Z, k2sig: Ae };
  }
  const k = { lowS: t.lowS, prehash: !1 },
    O = { lowS: t.lowS, prehash: !1 };
  function R(S, T, D = k) {
    const { seed: P, k2sig: B } = C(S, T, D),
      L = t;
    return TT(L.hash.outputLen, L.nByteLength, L.hmac)(P, B);
  }
  l.BASE._setWindowSize(8);
  function N(S, T, D, P = O) {
    var Ie;
    const B = S;
    if (((T = $n("msgHash", T)), (D = $n("publicKey", D)), "strict" in P))
      throw new Error("options.strict was renamed to lowS");
    const { lowS: L, prehash: Q } = P;
    let z, j;
    try {
      if (typeof B == "string" || B instanceof Uint8Array)
        try {
          z = v.fromDER(B);
        } catch (we) {
          if (!(we instanceof Ns.Err)) throw we;
          z = v.fromCompact(B);
        }
      else if (
        typeof B == "object" &&
        typeof B.r == "bigint" &&
        typeof B.s == "bigint"
      ) {
        const { r: we, s: ln } = B;
        z = new v(we, ln);
      } else throw new Error("PARSE");
      j = l.fromHex(D);
    } catch (we) {
      if (we.message === "PARSE")
        throw new Error(
          "signature must be Signature instance, Uint8Array or hex string"
        );
      return !1;
    }
    if (L && z.hasHighS()) return !1;
    Q && (T = t.hash(T));
    const { r: W, s: ee } = z,
      Z = h(T),
      ne = u(ee),
      Ae = a(Z * ne),
      de = a(W * ne),
      ge =
        (Ie = l.BASE.multiplyAndAddUnsafe(j, Ae, de)) == null
          ? void 0
          : Ie.toAffine();
    return ge ? a(ge.x) === W : !1;
  }
  return {
    CURVE: t,
    getPublicKey: b,
    getSharedSecret: A,
    sign: R,
    verify: N,
    ProjectivePoint: l,
    Signature: v,
    utils: y,
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ function u7(
  e
) {
  return { hash: e, hmac: (t, ...n) => Xb(e, t, Uf(...n)), randomBytes: v3 };
}
function c7(e, t) {
  const n = (r) => a7({ ...e, ...u7(r) });
  return Object.freeze({ ...n(t), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ const kT =
    BigInt(
      "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"
    ),
  q_ = BigInt(
    "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"
  ),
  l7 = BigInt(1),
  pg = BigInt(2),
  W_ = (e, t) => (e + t / pg) / t;
function d7(e) {
  const t = kT,
    n = BigInt(3),
    r = BigInt(6),
    i = BigInt(11),
    s = BigInt(22),
    o = BigInt(23),
    a = BigInt(44),
    u = BigInt(88),
    l = (e * e * e) % t,
    c = (l * l * e) % t,
    d = (Fn(c, n, t) * c) % t,
    f = (Fn(d, n, t) * c) % t,
    p = (Fn(f, pg, t) * l) % t,
    m = (Fn(p, i, t) * p) % t,
    g = (Fn(m, s, t) * m) % t,
    w = (Fn(g, a, t) * g) % t,
    v = (Fn(w, u, t) * w) % t,
    y = (Fn(v, a, t) * g) % t,
    b = (Fn(y, n, t) * c) % t,
    _ = (Fn(b, o, t) * m) % t,
    A = (Fn(_, r, t) * l) % t,
    x = Fn(A, pg, t);
  if (!mg.eql(mg.sqr(x), e)) throw new Error("Cannot find square root");
  return x;
}
const mg = YH(kT, void 0, void 0, { sqrt: d7 }),
  sw = c7(
    {
      a: BigInt(0),
      b: BigInt(7),
      Fp: mg,
      n: q_,
      Gx: BigInt(
        "55066263022277343669578718895168534326250603453777594175500187360389116729240"
      ),
      Gy: BigInt(
        "32670510020758816978083085130507043184471273380659243275938904335757337482424"
      ),
      h: BigInt(1),
      lowS: !0,
      endo: {
        beta: BigInt(
          "0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"
        ),
        splitScalar: (e) => {
          const t = q_,
            n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
            r = -l7 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
            i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
            s = n,
            o = BigInt("0x100000000000000000000000000000000"),
            a = W_(s * e, t),
            u = W_(-r * e, t);
          let l = dn(e - a * n - u * i, t),
            c = dn(-a * r - u * s, t);
          const d = l > o,
            f = c > o;
          if ((d && (l = t - l), f && (c = t - c), l > o || c > o))
            throw new Error("splitScalar: Endomorphism failed, k=" + e);
          return { k1neg: d, k1: l, k2neg: f, k2: c };
        },
      },
    },
    Ep
  );
BigInt(0);
sw.ProjectivePoint;
const f7 = Object.freeze(
  Object.defineProperty(
    { __proto__: null, secp256k1: sw },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var Vm;
const bi = (Vm = sw) !== null && Vm !== void 0 ? Vm : f7,
  Q_ = BigInt("0xffffffffffffffff"),
  Qc = BigInt(
    "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
  ),
  h7 = bi.CURVE.n,
  p7 = h7 / BigInt(2),
  m7 = {
    type: "object",
    required: ["crypto", "id", "version", "address"],
    properties: {
      crypto: {
        type: "object",
        required: [
          "cipher",
          "ciphertext",
          "cipherparams",
          "kdf",
          "kdfparams",
          "mac",
        ],
        properties: {
          cipher: { type: "string" },
          ciphertext: { type: "string" },
          cipherparams: { type: "object" },
          kdf: { type: "string" },
          kdfparams: { type: "object" },
          salt: { type: "string" },
          mac: { type: "string" },
        },
      },
      id: { type: "string" },
      version: { type: "number" },
      address: { type: "string" },
    },
  };
var sh;
(function (e) {
  (e[(e.Mainnet = 1)] = "Mainnet"),
    (e[(e.Goerli = 5)] = "Goerli"),
    (e[(e.Sepolia = 11155111)] = "Sepolia");
})(sh || (sh = {}));
var Ue;
(function (e) {
  (e.Chainstart = "chainstart"),
    (e.Homestead = "homestead"),
    (e.Dao = "dao"),
    (e.TangerineWhistle = "tangerineWhistle"),
    (e.SpuriousDragon = "spuriousDragon"),
    (e.Byzantium = "byzantium"),
    (e.Constantinople = "constantinople"),
    (e.Petersburg = "petersburg"),
    (e.Istanbul = "istanbul"),
    (e.MuirGlacier = "muirGlacier"),
    (e.Berlin = "berlin"),
    (e.London = "london"),
    (e.ArrowGlacier = "arrowGlacier"),
    (e.GrayGlacier = "grayGlacier"),
    (e.MergeForkIdTransition = "mergeForkIdTransition"),
    (e.Merge = "merge"),
    (e.Shanghai = "shanghai"),
    (e.ShardingForkDev = "shardingFork");
})(Ue || (Ue = {}));
var V_;
(function (e) {
  (e.ProofOfStake = "pos"),
    (e.ProofOfWork = "pow"),
    (e.ProofOfAuthority = "poa");
})(V_ || (V_ = {}));
var K_;
(function (e) {
  (e.Ethash = "ethash"), (e.Clique = "clique"), (e.Casper = "casper");
})(K_ || (K_ = {}));
var Qt;
(function (e) {
  (e.PolygonMainnet = "polygon-mainnet"),
    (e.PolygonMumbai = "polygon-mumbai"),
    (e.ArbitrumRinkebyTestnet = "arbitrum-rinkeby-testnet"),
    (e.ArbitrumOne = "arbitrum-one"),
    (e.xDaiChain = "x-dai-chain"),
    (e.OptimisticKovan = "optimistic-kovan"),
    (e.OptimisticEthereum = "optimistic-ethereum");
})(Qt || (Qt = {}));
var Wn;
(function (e) {
  (e[(e.Number = 0)] = "Number"),
    (e[(e.BigInt = 1)] = "BigInt"),
    (e[(e.Uint8Array = 2)] = "Uint8Array"),
    (e[(e.PrefixedHexString = 3)] = "PrefixedHexString");
})(Wn || (Wn = {}));
const PT = (e) => {
  if (typeof e != "string")
    throw new Error(
      `[stripHexPrefix] input must be type 'string', received ${typeof e}`
    );
  return Bb(e) ? e.slice(2) : e;
};
function y7(e) {
  return !e || e === "0x0"
    ? "0x0000000000000000"
    : Bb(e)
    ? `0x${PT(e).padStart(16, "0")}`
    : `0x${e.padStart(16, "0")}`;
}
const DT = function (e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`Received an invalid integer type: ${e}`);
  return `0x${e.toString(16)}`;
};
function g7(e, t = !0) {
  var n, r;
  const {
    name: i,
    config: s,
    difficulty: o,
    mixHash: a,
    gasLimit: u,
    coinbase: l,
    baseFeePerGas: c,
  } = e;
  let { extraData: d, timestamp: f, nonce: p } = e;
  const m = Number(f),
    { chainId: g } = s;
  if (
    (d === "" && (d = "0x"),
    Bb(f) || (f = DT(parseInt(f))),
    p.length !== 18 && (p = y7(p)),
    s.eip155Block !== s.eip158Block)
  )
    throw new Error(
      "EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork"
    );
  const w = {
      name: i,
      chainId: g,
      networkId: g,
      genesis: {
        timestamp: f,
        gasLimit: parseInt(u),
        difficulty: parseInt(o),
        nonce: p,
        extraData: d,
        mixHash: a,
        coinbase: l,
        baseFeePerGas: c,
      },
      hardfork: void 0,
      hardforks: [],
      bootstrapNodes: [],
      consensus:
        s.clique !== void 0
          ? {
              type: "poa",
              algorithm: "clique",
              clique: {
                period:
                  (n = s.clique.period) !== null && n !== void 0
                    ? n
                    : s.clique.blockperiodseconds,
                epoch:
                  (r = s.clique.epoch) !== null && r !== void 0
                    ? r
                    : s.clique.epochlength,
              },
            }
          : { type: "pow", algorithm: "ethash", ethash: {} },
    },
    v = {
      [Ue.Homestead]: { name: "homesteadBlock" },
      [Ue.Dao]: { name: "daoForkBlock" },
      [Ue.TangerineWhistle]: { name: "eip150Block" },
      [Ue.SpuriousDragon]: { name: "eip155Block" },
      [Ue.Byzantium]: { name: "byzantiumBlock" },
      [Ue.Constantinople]: { name: "constantinopleBlock" },
      [Ue.Petersburg]: { name: "petersburgBlock" },
      [Ue.Istanbul]: { name: "istanbulBlock" },
      [Ue.MuirGlacier]: { name: "muirGlacierBlock" },
      [Ue.Berlin]: { name: "berlinBlock" },
      [Ue.London]: { name: "londonBlock" },
      [Ue.MergeForkIdTransition]: { name: "mergeForkBlock", postMerge: t },
      [Ue.Shanghai]: { name: "shanghaiTime", postMerge: !0, isTimestamp: !0 },
      [Ue.ShardingForkDev]: {
        name: "shardingForkTime",
        postMerge: !0,
        isTimestamp: !0,
      },
    },
    y = Object.keys(v).reduce((A, x) => ((A[v[x].name] = x), A), {}),
    b = Object.keys(s).filter(
      (A) => y[A] !== void 0 && s[A] !== void 0 && s[A] !== null
    );
  if (
    ((w.hardforks = b
      .map((A) => ({
        name: y[A],
        block:
          v[y[A]].isTimestamp === !0 || typeof s[A] != "number" ? null : s[A],
        timestamp:
          v[y[A]].isTimestamp === !0 && typeof s[A] == "number" ? s[A] : void 0,
      }))
      .filter((A) => A.block !== null || A.timestamp !== void 0)),
    w.hardforks.sort((A, x) => {
      var h, E;
      return (
        ((h = A.block) !== null && h !== void 0 ? h : 1 / 0) -
        ((E = x.block) !== null && E !== void 0 ? E : 1 / 0)
      );
    }),
    w.hardforks.sort((A, x) => {
      var h, E;
      return (
        ((h = A.timestamp) !== null && h !== void 0 ? h : m) -
        ((E = x.timestamp) !== null && E !== void 0 ? E : m)
      );
    }),
    s.terminalTotalDifficulty !== void 0)
  ) {
    const A = { name: Ue.Merge, ttd: s.terminalTotalDifficulty, block: null },
      x = w.hardforks.findIndex((h) => {
        var E;
        return (
          ((E = v[h.name]) === null || E === void 0 ? void 0 : E.postMerge) ===
          !0
        );
      });
    x !== -1 ? w.hardforks.splice(x, 0, A) : w.hardforks.push(A);
  }
  const _ = w.hardforks.length > 0 ? w.hardforks.slice(-1)[0] : void 0;
  return (
    (w.hardfork = _ == null ? void 0 : _.name),
    w.hardforks.unshift({ name: Ue.Chainstart, block: 0 }),
    w
  );
}
function v7(e, t, n) {
  try {
    if (["config", "difficulty", "gasLimit", "alloc"].some((r) => !(r in e)))
      throw new Error("Invalid format, expected geth genesis fields missing");
    return t !== void 0 && (e.name = t), g7(e, n);
  } catch (r) {
    throw new Error(`Error parsing parameters file: ${r.message}`);
  }
}
function OT(e) {
  let t = e;
  if (typeof t != "string")
    throw new Error(
      `[padToEven] value must be type 'string', received ${typeof t}`
    );
  return t.length % 2 && (t = `0${t}`), t;
}
const b7 = function (e) {
    const t = DT(e);
    return He(`0x${OT(t.slice(2))}`);
  },
  Qe = function (e) {
    if (e == null) return new Uint8Array();
    if (e instanceof Uint8Array) return e;
    if (Array.isArray(e)) return Uint8Array.from(e);
    if (typeof e == "string") {
      if (!R3(e))
        throw new Error(
          `Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${e}`
        );
      return He(OT(PT(e)));
    }
    if (typeof e == "number") return Qe(kn(e));
    if (typeof e == "bigint") {
      if (e < BigInt(0))
        throw new Error(
          `Cannot convert negative bigint to Uint8Array. Given: ${e}`
        );
      let t = e.toString(16);
      return t.length % 2 && (t = `0${t}`), Qe(`0x${t}`);
    }
    if (e.toArray) return Uint8Array.from(e.toArray());
    throw new Error("invalid type");
  };
function je(e) {
  const t = ve(e);
  return BigInt(t === "0x" ? 0 : t);
}
function w7(e) {
  return Qe(`0x${e.toString(16)}`);
}
const RT = function (e) {
    return new Uint8Array(e).fill(0);
  },
  E7 = function (e, t, n) {
    const r = RT(t);
    return n
      ? e.length < t
        ? (r.set(e), r)
        : e.subarray(0, t)
      : e.length < t
      ? (r.set(e, t - e.length), r)
      : e.subarray(-t);
  };
function ow(e) {
  if (!(e instanceof Uint8Array)) {
    const t = `This method only supports Uint8Array but input was: ${e}`;
    throw new Error(t);
  }
}
const Z_ = function (e, t) {
  return ow(e), E7(e, t, !1);
};
function _7(e) {
  let t = e[0];
  for (; e.length > 0 && t.toString() === "0"; ) (e = e.slice(1)), (t = e[0]);
  return e;
}
const oh = function (e) {
    return ow(e), _7(e);
  },
  Ve = (e) => `0x${e.toString(16)}`;
function xe(e) {
  return oh(w7(e));
}
function A7(e, t) {
  return e === BigInt(0) || e === BigInt(1)
    ? e
    : t === void 0
    ? e - BigInt(27)
    : e - (t * BigInt(2) + BigInt(35));
}
function x7(e) {
  return e === BigInt(0) || e === BigInt(1);
}
const aw = function (e, t, n, r, i) {
  const s = A7(t, i);
  if (!x7(s)) throw new Error("Invalid signature v value");
  return new bi.Signature(je(n), je(r))
    .addRecoveryBit(Number(s))
    .recoverPublicKey(e)
    .toRawBytes(!1)
    .slice(1);
};
function xo(e, t) {
  if (e === null) return null;
  if (e === void 0) return;
  if (typeof e == "string" && !R3(e))
    throw new Error(`A string must be provided with a 0x-prefix, given: ${e}`);
  if (typeof e == "number" && !Number.isSafeInteger(e))
    throw new Error(
      "The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)"
    );
  const n = Qe(e);
  switch (t) {
    case Wn.Uint8Array:
      return n;
    case Wn.BigInt:
      return je(n);
    case Wn.Number: {
      const r = je(n);
      if (r > BigInt(Number.MAX_SAFE_INTEGER))
        throw new Error(
          "The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)"
        );
      return Number(r);
    }
    case Wn.PrefixedHexString:
      return ve(n);
    default:
      throw new Error("unknown outputType");
  }
}
var ni = {};
Object.defineProperty(ni, "__esModule", { value: !0 });
var Sn = (ni.RLP = ni.utils = ni.decode = ni.encode = void 0);
function uw(e) {
  if (Array.isArray(e)) {
    const n = [];
    let r = 0;
    for (let i = 0; i < e.length; i++) {
      const s = uw(e[i]);
      n.push(s), (r += s.length);
    }
    return gg(Y_(r, 192), ...n);
  }
  const t = jT(e);
  return t.length === 1 && t[0] < 128 ? t : gg(Y_(t.length, 128), t);
}
ni.encode = uw;
function So(e, t, n) {
  if (n > e.length)
    throw new Error(
      "invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds"
    );
  return e.slice(t, n);
}
function J_(e) {
  if (e[0] === 0) throw new Error("invalid RLP: extra zeros");
  return MT(NT(e));
}
function Y_(e, t) {
  if (e < 56) return Uint8Array.from([e + t]);
  const n = vg(e),
    r = n.length / 2,
    i = vg(t + 55 + r);
  return Uint8Array.from(ah(i + n));
}
function BT(e, t = !1) {
  if (typeof e > "u" || e === null || e.length === 0)
    return Uint8Array.from([]);
  const n = jT(e),
    r = yg(n);
  if (t) return r;
  if (r.remainder.length !== 0)
    throw new Error("invalid RLP: remainder must be zero");
  return r.data;
}
ni.decode = BT;
function yg(e) {
  let t, n, r, i, s;
  const o = [],
    a = e[0];
  if (a <= 127) return { data: e.slice(0, 1), remainder: e.slice(1) };
  if (a <= 183) {
    if (
      ((t = a - 127),
      a === 128 ? (r = Uint8Array.from([])) : (r = So(e, 1, t)),
      t === 2 && r[0] < 128)
    )
      throw new Error(
        "invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed"
      );
    return { data: r, remainder: e.slice(t) };
  } else if (a <= 191) {
    if (((n = a - 182), e.length - 1 < n))
      throw new Error("invalid RLP: not enough bytes for string length");
    if (((t = J_(So(e, 1, n))), t <= 55))
      throw new Error(
        "invalid RLP: expected string length to be greater than 55"
      );
    return (r = So(e, n, t + n)), { data: r, remainder: e.slice(t + n) };
  } else if (a <= 247) {
    for (t = a - 191, i = So(e, 1, t); i.length; )
      (s = yg(i)), o.push(s.data), (i = s.remainder);
    return { data: o, remainder: e.slice(t) };
  } else {
    if (((n = a - 246), (t = J_(So(e, 1, n))), t < 56))
      throw new Error("invalid RLP: encoded list too short");
    const u = n + t;
    if (u > e.length)
      throw new Error("invalid RLP: total length is larger than the data");
    for (i = So(e, n, u); i.length; )
      (s = yg(i)), o.push(s.data), (i = s.remainder);
    return { data: o, remainder: e.slice(u) };
  }
}
const S7 = Array.from({ length: 256 }, (e, t) =>
  t.toString(16).padStart(2, "0")
);
function NT(e) {
  let t = "";
  for (let n = 0; n < e.length; n++) t += S7[e[n]];
  return t;
}
function MT(e) {
  const t = Number.parseInt(e, 16);
  if (Number.isNaN(t)) throw new Error("Invalid byte sequence");
  return t;
}
function ah(e) {
  if (typeof e != "string")
    throw new TypeError("hexToBytes: expected string, got " + typeof e);
  if (e.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const t = new Uint8Array(e.length / 2);
  for (let n = 0; n < t.length; n++) {
    const r = n * 2;
    t[n] = MT(e.slice(r, r + 2));
  }
  return t;
}
function gg(...e) {
  if (e.length === 1) return e[0];
  const t = e.reduce((r, i) => r + i.length, 0),
    n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), (i += s.length);
  }
  return n;
}
function LT(e) {
  return new TextEncoder().encode(e);
}
function vg(e) {
  if (e < 0) throw new Error("Invalid integer as argument, must be unsigned!");
  const t = e.toString(16);
  return t.length % 2 ? `0${t}` : t;
}
function C7(e) {
  return e.length % 2 ? `0${e}` : e;
}
function FT(e) {
  return e.length >= 2 && e[0] === "0" && e[1] === "x";
}
function T7(e) {
  return typeof e != "string" ? e : FT(e) ? e.slice(2) : e;
}
function jT(e) {
  if (e instanceof Uint8Array) return e;
  if (typeof e == "string") return FT(e) ? ah(C7(T7(e))) : LT(e);
  if (typeof e == "number" || typeof e == "bigint")
    return e ? ah(vg(e)) : Uint8Array.from([]);
  if (e == null) return Uint8Array.from([]);
  throw new Error("toBytes: received unsupported type " + typeof e);
}
ni.utils = { bytesToHex: NT, concatBytes: gg, hexToBytes: ah, utf8ToBytes: LT };
Sn = ni.RLP = { encode: uw, decode: BT };
var UT = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */ (function (e) {
  (function (t) {
    t(typeof DO_NOT_EXPORT_CRC > "u" ? e : {});
  })(function (t) {
    t.version = "1.2.2";
    function n() {
      for (var E = 0, I = new Array(256), C = 0; C != 256; ++C)
        (E = C),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (E = E & 1 ? -306674912 ^ (E >>> 1) : E >>> 1),
          (I[C] = E);
      return typeof Int32Array < "u" ? new Int32Array(I) : I;
    }
    var r = n();
    function i(E) {
      var I = 0,
        C = 0,
        k = 0,
        O = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
      for (k = 0; k != 256; ++k) O[k] = E[k];
      for (k = 0; k != 256; ++k)
        for (C = E[k], I = 256 + k; I < 4096; I += 256)
          C = O[I] = (C >>> 8) ^ E[C & 255];
      var R = [];
      for (k = 1; k != 16; ++k)
        R[k - 1] =
          typeof Int32Array < "u"
            ? O.subarray(k * 256, k * 256 + 256)
            : O.slice(k * 256, k * 256 + 256);
      return R;
    }
    var s = i(r),
      o = s[0],
      a = s[1],
      u = s[2],
      l = s[3],
      c = s[4],
      d = s[5],
      f = s[6],
      p = s[7],
      m = s[8],
      g = s[9],
      w = s[10],
      v = s[11],
      y = s[12],
      b = s[13],
      _ = s[14];
    function A(E, I) {
      for (var C = I ^ -1, k = 0, O = E.length; k < O; )
        C = (C >>> 8) ^ r[(C ^ E.charCodeAt(k++)) & 255];
      return ~C;
    }
    function x(E, I) {
      for (var C = I ^ -1, k = E.length - 15, O = 0; O < k; )
        C =
          _[E[O++] ^ (C & 255)] ^
          b[E[O++] ^ ((C >> 8) & 255)] ^
          y[E[O++] ^ ((C >> 16) & 255)] ^
          v[E[O++] ^ (C >>> 24)] ^
          w[E[O++]] ^
          g[E[O++]] ^
          m[E[O++]] ^
          p[E[O++]] ^
          f[E[O++]] ^
          d[E[O++]] ^
          c[E[O++]] ^
          l[E[O++]] ^
          u[E[O++]] ^
          a[E[O++]] ^
          o[E[O++]] ^
          r[E[O++]];
      for (k += 15; O < k; ) C = (C >>> 8) ^ r[(C ^ E[O++]) & 255];
      return ~C;
    }
    function h(E, I) {
      for (var C = I ^ -1, k = 0, O = E.length, R = 0, N = 0; k < O; )
        (R = E.charCodeAt(k++)),
          R < 128
            ? (C = (C >>> 8) ^ r[(C ^ R) & 255])
            : R < 2048
            ? ((C = (C >>> 8) ^ r[(C ^ (192 | ((R >> 6) & 31))) & 255]),
              (C = (C >>> 8) ^ r[(C ^ (128 | (R & 63))) & 255]))
            : R >= 55296 && R < 57344
            ? ((R = (R & 1023) + 64),
              (N = E.charCodeAt(k++) & 1023),
              (C = (C >>> 8) ^ r[(C ^ (240 | ((R >> 8) & 7))) & 255]),
              (C = (C >>> 8) ^ r[(C ^ (128 | ((R >> 2) & 63))) & 255]),
              (C =
                (C >>> 8) ^
                r[(C ^ (128 | ((N >> 6) & 15) | ((R & 3) << 4))) & 255]),
              (C = (C >>> 8) ^ r[(C ^ (128 | (N & 63))) & 255]))
            : ((C = (C >>> 8) ^ r[(C ^ (224 | ((R >> 12) & 15))) & 255]),
              (C = (C >>> 8) ^ r[(C ^ (128 | ((R >> 6) & 63))) & 255]),
              (C = (C >>> 8) ^ r[(C ^ (128 | (R & 63))) & 255]));
      return ~C;
    }
    (t.table = r), (t.bstr = A), (t.buf = x), (t.str = h);
  });
})(UT);
const I7 = Xc(UT),
  k7 = {
    name: "goerli",
    chainId: 5,
    networkId: 5,
    defaultHardfork: "merge",
    consensus: {
      type: "poa",
      algorithm: "clique",
      clique: { period: 15, epoch: 3e4 },
    },
    comment: "Cross-client PoA test network",
    url: "https://github.com/goerli/testnet",
    genesis: {
      timestamp: "0x5c51a607",
      gasLimit: 10485760,
      difficulty: 1,
      nonce: "0x0000000000000000",
      extraData:
        "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    },
    hardforks: [
      { name: "chainstart", block: 0, forkHash: "0xa3f5ab08" },
      { name: "homestead", block: 0, forkHash: "0xa3f5ab08" },
      { name: "tangerineWhistle", block: 0, forkHash: "0xa3f5ab08" },
      { name: "spuriousDragon", block: 0, forkHash: "0xa3f5ab08" },
      { name: "byzantium", block: 0, forkHash: "0xa3f5ab08" },
      { name: "constantinople", block: 0, forkHash: "0xa3f5ab08" },
      { name: "petersburg", block: 0, forkHash: "0xa3f5ab08" },
      { name: "istanbul", block: 1561651, forkHash: "0xc25efa5c" },
      { name: "berlin", block: 4460644, forkHash: "0x757a1c47" },
      { name: "london", block: 5062605, forkHash: "0xb8c6299d" },
      {
        "//_comment":
          "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
        name: "merge",
        ttd: "10790000",
        block: 7382819,
        forkHash: "0xb8c6299d",
      },
      { name: "mergeForkIdTransition", block: null, forkHash: null },
      { name: "shanghai", block: null, forkHash: null },
    ],
    bootstrapNodes: [],
    dnsNetworks: [
      "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net",
    ],
  },
  P7 = {
    name: "mainnet",
    chainId: 1,
    networkId: 1,
    defaultHardfork: "merge",
    consensus: { type: "pow", algorithm: "ethash", ethash: {} },
    comment: "The Ethereum main chain",
    url: "https://ethstats.net/",
    genesis: {
      gasLimit: 5e3,
      difficulty: 17179869184,
      nonce: "0x0000000000000042",
      extraData:
        "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
    },
    hardforks: [
      { name: "chainstart", block: 0, forkHash: "0xfc64ec04" },
      { name: "homestead", block: 115e4, forkHash: "0x97c2c34c" },
      { name: "dao", block: 192e4, forkHash: "0x91d1f948" },
      { name: "tangerineWhistle", block: 2463e3, forkHash: "0x7a64da13" },
      { name: "spuriousDragon", block: 2675e3, forkHash: "0x3edd5b10" },
      { name: "byzantium", block: 437e4, forkHash: "0xa00bc324" },
      { name: "constantinople", block: 728e4, forkHash: "0x668db0af" },
      { name: "petersburg", block: 728e4, forkHash: "0x668db0af" },
      { name: "istanbul", block: 9069e3, forkHash: "0x879d6e30" },
      { name: "muirGlacier", block: 92e5, forkHash: "0xe029e991" },
      { name: "berlin", block: 12244e3, forkHash: "0x0eb440f6" },
      { name: "london", block: 12965e3, forkHash: "0xb715077d" },
      { name: "arrowGlacier", block: 13773e3, forkHash: "0x20c327fc" },
      { name: "grayGlacier", block: 1505e4, forkHash: "0xf0afd0e3" },
      {
        "//_comment":
          "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
        name: "merge",
        ttd: "58750000000000000000000",
        block: 15537394,
        forkHash: "0xf0afd0e3",
      },
      { name: "mergeForkIdTransition", block: null, forkHash: null },
      { name: "shanghai", block: null, forkHash: null },
    ],
    bootstrapNodes: [],
    dnsNetworks: [
      "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net",
    ],
  },
  D7 = {
    name: "sepolia",
    chainId: 11155111,
    networkId: 11155111,
    defaultHardfork: "merge",
    consensus: { type: "pow", algorithm: "ethash", ethash: {} },
    comment: "PoW test network to replace Ropsten",
    url: "https://github.com/ethereum/go-ethereum/pull/23730",
    genesis: {
      timestamp: "0x6159af19",
      gasLimit: 3e7,
      difficulty: 131072,
      nonce: "0x0000000000000000",
      extraData:
        "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521",
    },
    hardforks: [
      { name: "chainstart", block: 0, forkHash: "0xfe3366e7" },
      { name: "homestead", block: 0, forkHash: "0xfe3366e7" },
      { name: "tangerineWhistle", block: 0, forkHash: "0xfe3366e7" },
      { name: "spuriousDragon", block: 0, forkHash: "0xfe3366e7" },
      { name: "byzantium", block: 0, forkHash: "0xfe3366e7" },
      { name: "constantinople", block: 0, forkHash: "0xfe3366e7" },
      { name: "petersburg", block: 0, forkHash: "0xfe3366e7" },
      { name: "istanbul", block: 0, forkHash: "0xfe3366e7" },
      { name: "muirGlacier", block: 0, forkHash: "0xfe3366e7" },
      { name: "berlin", block: 0, forkHash: "0xfe3366e7" },
      { name: "london", block: 0, forkHash: "0xfe3366e7" },
      {
        "//_comment":
          "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
        name: "merge",
        ttd: "17000000000000000",
        block: 1450409,
        forkHash: "0xfe3366e7",
      },
      { name: "mergeForkIdTransition", block: 1735371, forkHash: "0xb96cbd13" },
      {
        name: "shanghai",
        block: null,
        timestamp: "1677557088",
        forkHash: "0xf7f9bc08",
      },
    ],
    bootstrapNodes: [],
    dnsNetworks: [
      "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net",
    ],
  },
  O7 = {
    name: "EIP-1153",
    number: 1153,
    comment: "Transient Storage",
    url: "https://eips.ethereum.org/EIPS/eip-1153",
    status: "Review",
    minimumHardfork: "chainstart",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: {
      tstore: { v: 100, d: "Base fee of the TSTORE opcode" },
      tload: { v: 100, d: "Base fee of the TLOAD opcode" },
    },
    vm: {},
    pow: {},
  },
  R7 = {
    name: "EIP-1559",
    number: 1559,
    comment: "Fee market change for ETH 1.0 chain",
    url: "https://eips.ethereum.org/EIPS/eip-1559",
    status: "Final",
    minimumHardfork: "berlin",
    requiredEIPs: [2930],
    gasConfig: {
      baseFeeMaxChangeDenominator: {
        v: 8,
        d: "Maximum base fee change denominator",
      },
      elasticityMultiplier: { v: 2, d: "Maximum block gas target elasticity" },
      initialBaseFee: { v: 1e9, d: "Initial base fee on first EIP1559 block" },
    },
    gasPrices: {},
    vm: {},
    pow: {},
  },
  B7 = {
    name: "EIP-2315",
    number: 2315,
    comment: "Simple subroutines for the EVM",
    url: "https://eips.ethereum.org/EIPS/eip-2315",
    status: "Draft",
    minimumHardfork: "istanbul",
    gasConfig: {},
    gasPrices: {
      beginsub: { v: 2, d: "Base fee of the BEGINSUB opcode" },
      returnsub: { v: 5, d: "Base fee of the RETURNSUB opcode" },
      jumpsub: { v: 10, d: "Base fee of the JUMPSUB opcode" },
    },
    vm: {},
    pow: {},
  },
  N7 = {
    name: "EIP-2537",
    number: 2537,
    comment: "BLS12-381 precompiles",
    url: "https://eips.ethereum.org/EIPS/eip-2537",
    status: "Draft",
    minimumHardfork: "chainstart",
    gasConfig: {},
    gasPrices: {
      Bls12381G1AddGas: {
        v: 600,
        d: "Gas cost of a single BLS12-381 G1 addition precompile-call",
      },
      Bls12381G1MulGas: {
        v: 12e3,
        d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call",
      },
      Bls12381G2AddGas: {
        v: 4500,
        d: "Gas cost of a single BLS12-381 G2 addition precompile-call",
      },
      Bls12381G2MulGas: {
        v: 55e3,
        d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call",
      },
      Bls12381PairingBaseGas: {
        v: 115e3,
        d: "Base gas cost of BLS12-381 pairing check",
      },
      Bls12381PairingPerPairGas: {
        v: 23e3,
        d: "Per-pair gas cost of BLS12-381 pairing check",
      },
      Bls12381MapG1Gas: {
        v: 5500,
        d: "Gas cost of BLS12-381 map field element to G1",
      },
      Bls12381MapG2Gas: {
        v: 11e4,
        d: "Gas cost of BLS12-381 map field element to G2",
      },
      Bls12381MultiExpGasDiscount: {
        v: [
          [1, 1200],
          [2, 888],
          [3, 764],
          [4, 641],
          [5, 594],
          [6, 547],
          [7, 500],
          [8, 453],
          [9, 438],
          [10, 423],
          [11, 408],
          [12, 394],
          [13, 379],
          [14, 364],
          [15, 349],
          [16, 334],
          [17, 330],
          [18, 326],
          [19, 322],
          [20, 318],
          [21, 314],
          [22, 310],
          [23, 306],
          [24, 302],
          [25, 298],
          [26, 294],
          [27, 289],
          [28, 285],
          [29, 281],
          [30, 277],
          [31, 273],
          [32, 269],
          [33, 268],
          [34, 266],
          [35, 265],
          [36, 263],
          [37, 262],
          [38, 260],
          [39, 259],
          [40, 257],
          [41, 256],
          [42, 254],
          [43, 253],
          [44, 251],
          [45, 250],
          [46, 248],
          [47, 247],
          [48, 245],
          [49, 244],
          [50, 242],
          [51, 241],
          [52, 239],
          [53, 238],
          [54, 236],
          [55, 235],
          [56, 233],
          [57, 232],
          [58, 231],
          [59, 229],
          [60, 228],
          [61, 226],
          [62, 225],
          [63, 223],
          [64, 222],
          [65, 221],
          [66, 220],
          [67, 219],
          [68, 219],
          [69, 218],
          [70, 217],
          [71, 216],
          [72, 216],
          [73, 215],
          [74, 214],
          [75, 213],
          [76, 213],
          [77, 212],
          [78, 211],
          [79, 211],
          [80, 210],
          [81, 209],
          [82, 208],
          [83, 208],
          [84, 207],
          [85, 206],
          [86, 205],
          [87, 205],
          [88, 204],
          [89, 203],
          [90, 202],
          [91, 202],
          [92, 201],
          [93, 200],
          [94, 199],
          [95, 199],
          [96, 198],
          [97, 197],
          [98, 196],
          [99, 196],
          [100, 195],
          [101, 194],
          [102, 193],
          [103, 193],
          [104, 192],
          [105, 191],
          [106, 191],
          [107, 190],
          [108, 189],
          [109, 188],
          [110, 188],
          [111, 187],
          [112, 186],
          [113, 185],
          [114, 185],
          [115, 184],
          [116, 183],
          [117, 182],
          [118, 182],
          [119, 181],
          [120, 180],
          [121, 179],
          [122, 179],
          [123, 178],
          [124, 177],
          [125, 176],
          [126, 176],
          [127, 175],
          [128, 174],
        ],
        d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair",
      },
    },
    vm: {},
    pow: {},
  },
  M7 = {
    name: "EIP-2565",
    number: 2565,
    comment: "ModExp gas cost",
    url: "https://eips.ethereum.org/EIPS/eip-2565",
    status: "Final",
    minimumHardfork: "byzantium",
    gasConfig: {},
    gasPrices: {
      modexpGquaddivisor: {
        v: 3,
        d: "Gquaddivisor from modexp precompile for gas calculation",
      },
    },
    vm: {},
    pow: {},
  },
  L7 = {
    name: "EIP-2718",
    comment: "Typed Transaction Envelope",
    url: "https://eips.ethereum.org/EIPS/eip-2718",
    status: "Final",
    minimumHardfork: "chainstart",
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  F7 = {
    name: "EIP-2929",
    comment: "Gas cost increases for state access opcodes",
    url: "https://eips.ethereum.org/EIPS/eip-2929",
    status: "Final",
    minimumHardfork: "chainstart",
    gasConfig: {},
    gasPrices: {
      coldsload: {
        v: 2100,
        d: "Gas cost of the first read of storage from a given location (per transaction)",
      },
      coldaccountaccess: {
        v: 2600,
        d: "Gas cost of the first read of a given address (per transaction)",
      },
      warmstorageread: {
        v: 100,
        d: "Gas cost of reading storage locations which have already loaded 'cold'",
      },
      sstoreCleanGasEIP2200: {
        v: 2900,
        d: "Once per SSTORE operation from clean non-zero to something else",
      },
      sstoreNoopGasEIP2200: {
        v: 100,
        d: "Once per SSTORE operation if the value doesn't change",
      },
      sstoreDirtyGasEIP2200: {
        v: 100,
        d: "Once per SSTORE operation if a dirty value is changed",
      },
      sstoreInitRefundEIP2200: {
        v: 19900,
        d: "Once per SSTORE operation for resetting to the original zero value",
      },
      sstoreCleanRefundEIP2200: {
        v: 4900,
        d: "Once per SSTORE operation for resetting to the original non-zero value",
      },
      call: { v: 0, d: "Base fee of the CALL opcode" },
      callcode: { v: 0, d: "Base fee of the CALLCODE opcode" },
      delegatecall: { v: 0, d: "Base fee of the DELEGATECALL opcode" },
      staticcall: { v: 0, d: "Base fee of the STATICCALL opcode" },
      balance: { v: 0, d: "Base fee of the BALANCE opcode" },
      extcodesize: { v: 0, d: "Base fee of the EXTCODESIZE opcode" },
      extcodecopy: { v: 0, d: "Base fee of the EXTCODECOPY opcode" },
      extcodehash: { v: 0, d: "Base fee of the EXTCODEHASH opcode" },
      sload: { v: 0, d: "Base fee of the SLOAD opcode" },
      sstore: { v: 0, d: "Base fee of the SSTORE opcode" },
    },
    vm: {},
    pow: {},
  },
  j7 = {
    name: "EIP-2930",
    comment: "Optional access lists",
    url: "https://eips.ethereum.org/EIPS/eip-2930",
    status: "Final",
    minimumHardfork: "istanbul",
    requiredEIPs: [2718, 2929],
    gasConfig: {},
    gasPrices: {
      accessListStorageKeyCost: {
        v: 1900,
        d: "Gas cost per storage key in an Access List transaction",
      },
      accessListAddressCost: {
        v: 2400,
        d: "Gas cost per storage key in an Access List transaction",
      },
    },
    vm: {},
    pow: {},
  },
  U7 = {
    name: "EIP-3198",
    number: 3198,
    comment: "BASEFEE opcode",
    url: "https://eips.ethereum.org/EIPS/eip-3198",
    status: "Final",
    minimumHardfork: "london",
    gasConfig: {},
    gasPrices: { basefee: { v: 2, d: "Gas cost of the BASEFEE opcode" } },
    vm: {},
    pow: {},
  },
  $7 = {
    name: "EIP-3529",
    comment: "Reduction in refunds",
    url: "https://eips.ethereum.org/EIPS/eip-3529",
    status: "Final",
    minimumHardfork: "berlin",
    requiredEIPs: [2929],
    gasConfig: {
      maxRefundQuotient: {
        v: 5,
        d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)",
      },
    },
    gasPrices: {
      selfdestructRefund: {
        v: 0,
        d: "Refunded following a selfdestruct operation",
      },
      sstoreClearRefundEIP2200: {
        v: 4800,
        d: "Once per SSTORE operation for clearing an originally existing storage slot",
      },
    },
    vm: {},
    pow: {},
  },
  H7 = {
    name: "EIP-3540",
    number: 3540,
    comment: "EVM Object Format (EOF) v1",
    url: "https://eips.ethereum.org/EIPS/eip-3540",
    status: "Review",
    minimumHardfork: "london",
    requiredEIPs: [3541],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  z7 = {
    name: "EIP-3541",
    comment: "Reject new contracts starting with the 0xEF byte",
    url: "https://eips.ethereum.org/EIPS/eip-3541",
    status: "Final",
    minimumHardfork: "berlin",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  G7 = {
    name: "EIP-3554",
    comment: "Reduction in refunds",
    url: "Difficulty Bomb Delay to December 1st 2021",
    status: "Final",
    minimumHardfork: "muirGlacier",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {
      difficultyBombDelay: {
        v: 95e5,
        d: "the amount of blocks to delay the difficulty bomb with",
      },
    },
  },
  q7 = {
    name: "EIP-3607",
    number: 3607,
    comment: "Reject transactions from senders with deployed code",
    url: "https://eips.ethereum.org/EIPS/eip-3607",
    status: "Final",
    minimumHardfork: "chainstart",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  W7 = {
    name: "EIP-3651",
    number: 3198,
    comment: "Warm COINBASE",
    url: "https://eips.ethereum.org/EIPS/eip-3651",
    status: "Review",
    minimumHardfork: "london",
    requiredEIPs: [2929],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  Q7 = {
    name: "EIP-3670",
    number: 3670,
    comment: "EOF - Code Validation",
    url: "https://eips.ethereum.org/EIPS/eip-3670",
    status: "Review",
    minimumHardfork: "london",
    requiredEIPs: [3540],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  V7 = {
    name: "EIP-3675",
    number: 3675,
    comment: "Upgrade consensus to Proof-of-Stake",
    url: "https://eips.ethereum.org/EIPS/eip-3675",
    status: "Final",
    minimumHardfork: "london",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  K7 = {
    name: "EIP-3855",
    number: 3855,
    comment: "PUSH0 instruction",
    url: "https://eips.ethereum.org/EIPS/eip-3855",
    status: "Review",
    minimumHardfork: "chainstart",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: { push0: { v: 2, d: "Base fee of the PUSH0 opcode" } },
    vm: {},
    pow: {},
  },
  Z7 = {
    name: "EIP-3860",
    number: 3860,
    comment: "Limit and meter initcode",
    url: "https://eips.ethereum.org/EIPS/eip-3860",
    status: "Review",
    minimumHardfork: "spuriousDragon",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: {
      initCodeWordCost: {
        v: 2,
        d: "Gas to pay for each word (32 bytes) of initcode when creating a contract",
      },
    },
    vm: {
      maxInitCodeSize: {
        v: 49152,
        d: "Maximum length of initialization code when creating a contract",
      },
    },
    pow: {},
  },
  J7 = {
    name: "EIP-4345",
    number: 4345,
    comment: "Difficulty Bomb Delay to June 2022",
    url: "https://eips.ethereum.org/EIPS/eip-4345",
    status: "Final",
    minimumHardfork: "london",
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {
      difficultyBombDelay: {
        v: 107e5,
        d: "the amount of blocks to delay the difficulty bomb with",
      },
    },
  },
  Y7 = {
    name: "EIP-4399",
    number: 4399,
    comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
    url: "https://eips.ethereum.org/EIPS/eip-4399",
    status: "Review",
    minimumHardfork: "london",
    requiredEIPs: [],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  X7 = {
    name: "EIP-5133",
    number: 5133,
    comment: "Delaying Difficulty Bomb to mid-September 2022",
    url: "https://eips.ethereum.org/EIPS/eip-5133",
    status: "Draft",
    minimumHardfork: "grayGlacier",
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {
      difficultyBombDelay: {
        v: 114e5,
        d: "the amount of blocks to delay the difficulty bomb with",
      },
    },
  },
  Co = {
    1153: O7,
    1559: R7,
    2315: B7,
    2537: N7,
    2565: M7,
    2718: L7,
    2929: F7,
    2930: j7,
    3198: U7,
    3529: $7,
    3540: H7,
    3541: z7,
    3554: G7,
    3607: q7,
    3651: W7,
    3670: Q7,
    3675: V7,
    3855: K7,
    3860: Z7,
    4345: J7,
    4399: Y7,
    5133: X7,
  },
  ez = {
    name: "chainstart",
    comment: "Start of the Ethereum main chain",
    url: "",
    status: "",
    gasConfig: {
      minGasLimit: { v: 5e3, d: "Minimum the gas limit may ever be" },
      gasLimitBoundDivisor: {
        v: 1024,
        d: "The bound divisor of the gas limit, used in update calculations",
      },
      maxRefundQuotient: {
        v: 2,
        d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)",
      },
    },
    gasPrices: {
      base: {
        v: 2,
        d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)",
      },
      tierStep: {
        v: [0, 2, 3, 5, 8, 10, 20],
        d: "Once per operation, for a selection of them",
      },
      exp: { v: 10, d: "Base fee of the EXP opcode" },
      expByte: {
        v: 10,
        d: "Times ceil(log256(exponent)) for the EXP instruction",
      },
      sha3: { v: 30, d: "Base fee of the SHA3 opcode" },
      sha3Word: { v: 6, d: "Once per word of the SHA3 operation's data" },
      sload: { v: 50, d: "Base fee of the SLOAD opcode" },
      sstoreSet: {
        v: 2e4,
        d: "Once per SSTORE operation if the zeroness changes from zero",
      },
      sstoreReset: {
        v: 5e3,
        d: "Once per SSTORE operation if the zeroness does not change from zero",
      },
      sstoreRefund: {
        v: 15e3,
        d: "Once per SSTORE operation if the zeroness changes to zero",
      },
      jumpdest: { v: 1, d: "Base fee of the JUMPDEST opcode" },
      log: { v: 375, d: "Base fee of the LOG opcode" },
      logData: { v: 8, d: "Per byte in a LOG* operation's data" },
      logTopic: {
        v: 375,
        d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas",
      },
      create: { v: 32e3, d: "Base fee of the CREATE opcode" },
      call: { v: 40, d: "Base fee of the CALL opcode" },
      callStipend: { v: 2300, d: "Free gas given at beginning of call" },
      callValueTransfer: {
        v: 9e3,
        d: "Paid for CALL when the value transfor is non-zero",
      },
      callNewAccount: {
        v: 25e3,
        d: "Paid for CALL when the destination address didn't exist prior",
      },
      selfdestructRefund: {
        v: 24e3,
        d: "Refunded following a selfdestruct operation",
      },
      memory: {
        v: 3,
        d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL",
      },
      quadCoeffDiv: {
        v: 512,
        d: "Divisor for the quadratic particle of the memory cost equation",
      },
      createData: { v: 200, d: "" },
      tx: {
        v: 21e3,
        d: "Per transaction. NOTE: Not payable on data of calls between transactions",
      },
      txCreation: { v: 32e3, d: "The cost of creating a contract via tx" },
      txDataZero: {
        v: 4,
        d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions",
      },
      txDataNonZero: {
        v: 68,
        d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions",
      },
      copy: {
        v: 3,
        d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added",
      },
      ecRecover: { v: 3e3, d: "" },
      sha256: { v: 60, d: "" },
      sha256Word: { v: 12, d: "" },
      ripemd160: { v: 600, d: "" },
      ripemd160Word: { v: 120, d: "" },
      identity: { v: 15, d: "" },
      identityWord: { v: 3, d: "" },
      stop: { v: 0, d: "Base fee of the STOP opcode" },
      add: { v: 3, d: "Base fee of the ADD opcode" },
      mul: { v: 5, d: "Base fee of the MUL opcode" },
      sub: { v: 3, d: "Base fee of the SUB opcode" },
      div: { v: 5, d: "Base fee of the DIV opcode" },
      sdiv: { v: 5, d: "Base fee of the SDIV opcode" },
      mod: { v: 5, d: "Base fee of the MOD opcode" },
      smod: { v: 5, d: "Base fee of the SMOD opcode" },
      addmod: { v: 8, d: "Base fee of the ADDMOD opcode" },
      mulmod: { v: 8, d: "Base fee of the MULMOD opcode" },
      signextend: { v: 5, d: "Base fee of the SIGNEXTEND opcode" },
      lt: { v: 3, d: "Base fee of the LT opcode" },
      gt: { v: 3, d: "Base fee of the GT opcode" },
      slt: { v: 3, d: "Base fee of the SLT opcode" },
      sgt: { v: 3, d: "Base fee of the SGT opcode" },
      eq: { v: 3, d: "Base fee of the EQ opcode" },
      iszero: { v: 3, d: "Base fee of the ISZERO opcode" },
      and: { v: 3, d: "Base fee of the AND opcode" },
      or: { v: 3, d: "Base fee of the OR opcode" },
      xor: { v: 3, d: "Base fee of the XOR opcode" },
      not: { v: 3, d: "Base fee of the NOT opcode" },
      byte: { v: 3, d: "Base fee of the BYTE opcode" },
      address: { v: 2, d: "Base fee of the ADDRESS opcode" },
      balance: { v: 20, d: "Base fee of the BALANCE opcode" },
      origin: { v: 2, d: "Base fee of the ORIGIN opcode" },
      caller: { v: 2, d: "Base fee of the CALLER opcode" },
      callvalue: { v: 2, d: "Base fee of the CALLVALUE opcode" },
      calldataload: { v: 3, d: "Base fee of the CALLDATALOAD opcode" },
      calldatasize: { v: 2, d: "Base fee of the CALLDATASIZE opcode" },
      calldatacopy: { v: 3, d: "Base fee of the CALLDATACOPY opcode" },
      codesize: { v: 2, d: "Base fee of the CODESIZE opcode" },
      codecopy: { v: 3, d: "Base fee of the CODECOPY opcode" },
      gasprice: { v: 2, d: "Base fee of the GASPRICE opcode" },
      extcodesize: { v: 20, d: "Base fee of the EXTCODESIZE opcode" },
      extcodecopy: { v: 20, d: "Base fee of the EXTCODECOPY opcode" },
      blockhash: { v: 20, d: "Base fee of the BLOCKHASH opcode" },
      coinbase: { v: 2, d: "Base fee of the COINBASE opcode" },
      timestamp: { v: 2, d: "Base fee of the TIMESTAMP opcode" },
      number: { v: 2, d: "Base fee of the NUMBER opcode" },
      difficulty: { v: 2, d: "Base fee of the DIFFICULTY opcode" },
      gaslimit: { v: 2, d: "Base fee of the GASLIMIT opcode" },
      pop: { v: 2, d: "Base fee of the POP opcode" },
      mload: { v: 3, d: "Base fee of the MLOAD opcode" },
      mstore: { v: 3, d: "Base fee of the MSTORE opcode" },
      mstore8: { v: 3, d: "Base fee of the MSTORE8 opcode" },
      sstore: { v: 0, d: "Base fee of the SSTORE opcode" },
      jump: { v: 8, d: "Base fee of the JUMP opcode" },
      jumpi: { v: 10, d: "Base fee of the JUMPI opcode" },
      pc: { v: 2, d: "Base fee of the PC opcode" },
      msize: { v: 2, d: "Base fee of the MSIZE opcode" },
      gas: { v: 2, d: "Base fee of the GAS opcode" },
      push: { v: 3, d: "Base fee of the PUSH opcode" },
      dup: { v: 3, d: "Base fee of the DUP opcode" },
      swap: { v: 3, d: "Base fee of the SWAP opcode" },
      callcode: { v: 40, d: "Base fee of the CALLCODE opcode" },
      return: { v: 0, d: "Base fee of the RETURN opcode" },
      invalid: { v: 0, d: "Base fee of the INVALID opcode" },
      selfdestruct: { v: 0, d: "Base fee of the SELFDESTRUCT opcode" },
    },
    vm: {
      stackLimit: { v: 1024, d: "Maximum size of VM stack allowed" },
      callCreateDepth: { v: 1024, d: "Maximum depth of call/create stack" },
      maxExtraDataSize: {
        v: 32,
        d: "Maximum size extra data may be after Genesis",
      },
    },
    pow: {
      minimumDifficulty: {
        v: 131072,
        d: "The minimum that the difficulty may ever be",
      },
      difficultyBoundDivisor: {
        v: 2048,
        d: "The bound divisor of the difficulty, used in the update calculations",
      },
      durationLimit: {
        v: 13,
        d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not",
      },
      epochDuration: { v: 3e4, d: "Duration between proof-of-work epochs" },
      timebombPeriod: { v: 1e5, d: "Exponential difficulty timebomb period" },
      minerReward: {
        v: "5000000000000000000",
        d: "the amount a miner get rewarded for mining a block",
      },
      difficultyBombDelay: {
        v: 0,
        d: "the amount of blocks to delay the difficulty bomb with",
      },
    },
  },
  tz = {
    name: "dao",
    comment: "DAO rescue hardfork",
    url: "https://eips.ethereum.org/EIPS/eip-779",
    status: "Final",
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  nz = {
    name: "homestead",
    comment: "Homestead hardfork with protocol and network changes",
    url: "https://eips.ethereum.org/EIPS/eip-606",
    status: "Final",
    gasConfig: {},
    gasPrices: {
      delegatecall: { v: 40, d: "Base fee of the DELEGATECALL opcode" },
    },
    vm: {},
    pow: {},
  },
  rz = {
    name: "tangerineWhistle",
    comment: "Hardfork with gas cost changes for IO-heavy operations",
    url: "https://eips.ethereum.org/EIPS/eip-608",
    status: "Final",
    gasConfig: {},
    gasPrices: {
      sload: { v: 200, d: "Once per SLOAD operation" },
      call: { v: 700, d: "Once per CALL operation & message call transaction" },
      extcodesize: { v: 700, d: "Base fee of the EXTCODESIZE opcode" },
      extcodecopy: { v: 700, d: "Base fee of the EXTCODECOPY opcode" },
      balance: { v: 400, d: "Base fee of the BALANCE opcode" },
      delegatecall: { v: 700, d: "Base fee of the DELEGATECALL opcode" },
      callcode: { v: 700, d: "Base fee of the CALLCODE opcode" },
      selfdestruct: { v: 5e3, d: "Base fee of the SELFDESTRUCT opcode" },
    },
    vm: {},
    pow: {},
  },
  iz = {
    name: "spuriousDragon",
    comment:
      "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
    url: "https://eips.ethereum.org/EIPS/eip-607",
    status: "Final",
    gasConfig: {},
    gasPrices: {
      expByte: {
        v: 50,
        d: "Times ceil(log256(exponent)) for the EXP instruction",
      },
    },
    vm: { maxCodeSize: { v: 24576, d: "Maximum length of contract code" } },
    pow: {},
  },
  sz = {
    name: "byzantium",
    comment:
      "Hardfork with new precompiles, instructions and other protocol changes",
    url: "https://eips.ethereum.org/EIPS/eip-609",
    status: "Final",
    gasConfig: {},
    gasPrices: {
      modexpGquaddivisor: {
        v: 20,
        d: "Gquaddivisor from modexp precompile for gas calculation",
      },
      ecAdd: { v: 500, d: "Gas costs for curve addition precompile" },
      ecMul: { v: 4e4, d: "Gas costs for curve multiplication precompile" },
      ecPairing: { v: 1e5, d: "Base gas costs for curve pairing precompile" },
      ecPairingWord: {
        v: 8e4,
        d: "Gas costs regarding curve pairing precompile input length",
      },
      revert: { v: 0, d: "Base fee of the REVERT opcode" },
      staticcall: { v: 700, d: "Base fee of the STATICCALL opcode" },
      returndatasize: { v: 2, d: "Base fee of the RETURNDATASIZE opcode" },
      returndatacopy: { v: 3, d: "Base fee of the RETURNDATACOPY opcode" },
    },
    vm: {},
    pow: {
      minerReward: {
        v: "3000000000000000000",
        d: "the amount a miner get rewarded for mining a block",
      },
      difficultyBombDelay: {
        v: 3e6,
        d: "the amount of blocks to delay the difficulty bomb with",
      },
    },
  },
  oz = {
    name: "constantinople",
    comment:
      "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
    url: "https://eips.ethereum.org/EIPS/eip-1013",
    status: "Final",
    gasConfig: {},
    gasPrices: {
      netSstoreNoopGas: {
        v: 200,
        d: "Once per SSTORE operation if the value doesn't change",
      },
      netSstoreInitGas: {
        v: 2e4,
        d: "Once per SSTORE operation from clean zero",
      },
      netSstoreCleanGas: {
        v: 5e3,
        d: "Once per SSTORE operation from clean non-zero",
      },
      netSstoreDirtyGas: { v: 200, d: "Once per SSTORE operation from dirty" },
      netSstoreClearRefund: {
        v: 15e3,
        d: "Once per SSTORE operation for clearing an originally existing storage slot",
      },
      netSstoreResetRefund: {
        v: 4800,
        d: "Once per SSTORE operation for resetting to the original non-zero value",
      },
      netSstoreResetClearRefund: {
        v: 19800,
        d: "Once per SSTORE operation for resetting to the original zero value",
      },
      shl: { v: 3, d: "Base fee of the SHL opcode" },
      shr: { v: 3, d: "Base fee of the SHR opcode" },
      sar: { v: 3, d: "Base fee of the SAR opcode" },
      extcodehash: { v: 400, d: "Base fee of the EXTCODEHASH opcode" },
      create2: { v: 32e3, d: "Base fee of the CREATE2 opcode" },
    },
    vm: {},
    pow: {
      minerReward: {
        v: "2000000000000000000",
        d: "The amount a miner gets rewarded for mining a block",
      },
      difficultyBombDelay: {
        v: 5e6,
        d: "the amount of blocks to delay the difficulty bomb with",
      },
    },
  },
  az = {
    name: "petersburg",
    comment:
      "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
    url: "https://eips.ethereum.org/EIPS/eip-1716",
    status: "Final",
    gasConfig: {},
    gasPrices: {
      netSstoreNoopGas: { v: null, d: "Removed along EIP-1283" },
      netSstoreInitGas: { v: null, d: "Removed along EIP-1283" },
      netSstoreCleanGas: { v: null, d: "Removed along EIP-1283" },
      netSstoreDirtyGas: { v: null, d: "Removed along EIP-1283" },
      netSstoreClearRefund: { v: null, d: "Removed along EIP-1283" },
      netSstoreResetRefund: { v: null, d: "Removed along EIP-1283" },
      netSstoreResetClearRefund: { v: null, d: "Removed along EIP-1283" },
    },
    vm: {},
    pow: {},
  },
  uz = {
    name: "istanbul",
    comment:
      "HF targeted for December 2019 following the Constantinople/Petersburg HF",
    url: "https://eips.ethereum.org/EIPS/eip-1679",
    status: "Final",
    gasConfig: {},
    gasPrices: {
      blake2Round: {
        v: 1,
        d: "Gas cost per round for the Blake2 F precompile",
      },
      ecAdd: { v: 150, d: "Gas costs for curve addition precompile" },
      ecMul: { v: 6e3, d: "Gas costs for curve multiplication precompile" },
      ecPairing: { v: 45e3, d: "Base gas costs for curve pairing precompile" },
      ecPairingWord: {
        v: 34e3,
        d: "Gas costs regarding curve pairing precompile input length",
      },
      txDataNonZero: {
        v: 16,
        d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions",
      },
      sstoreSentryGasEIP2200: {
        v: 2300,
        d: "Minimum gas required to be present for an SSTORE call, not consumed",
      },
      sstoreNoopGasEIP2200: {
        v: 800,
        d: "Once per SSTORE operation if the value doesn't change",
      },
      sstoreDirtyGasEIP2200: {
        v: 800,
        d: "Once per SSTORE operation if a dirty value is changed",
      },
      sstoreInitGasEIP2200: {
        v: 2e4,
        d: "Once per SSTORE operation from clean zero to non-zero",
      },
      sstoreInitRefundEIP2200: {
        v: 19200,
        d: "Once per SSTORE operation for resetting to the original zero value",
      },
      sstoreCleanGasEIP2200: {
        v: 5e3,
        d: "Once per SSTORE operation from clean non-zero to something else",
      },
      sstoreCleanRefundEIP2200: {
        v: 4200,
        d: "Once per SSTORE operation for resetting to the original non-zero value",
      },
      sstoreClearRefundEIP2200: {
        v: 15e3,
        d: "Once per SSTORE operation for clearing an originally existing storage slot",
      },
      balance: { v: 700, d: "Base fee of the BALANCE opcode" },
      extcodehash: { v: 700, d: "Base fee of the EXTCODEHASH opcode" },
      chainid: { v: 2, d: "Base fee of the CHAINID opcode" },
      selfbalance: { v: 5, d: "Base fee of the SELFBALANCE opcode" },
      sload: { v: 800, d: "Base fee of the SLOAD opcode" },
    },
    vm: {},
    pow: {},
  },
  cz = {
    name: "muirGlacier",
    comment: "HF to delay the difficulty bomb",
    url: "https://eips.ethereum.org/EIPS/eip-2384",
    status: "Final",
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {
      difficultyBombDelay: {
        v: 9e6,
        d: "the amount of blocks to delay the difficulty bomb with",
      },
    },
  },
  lz = {
    name: "berlin",
    comment: "HF targeted for July 2020 following the Muir Glacier HF",
    url: "https://eips.ethereum.org/EIPS/eip-2070",
    status: "Final",
    eips: [2565, 2929, 2718, 2930],
  },
  dz = {
    name: "london",
    comment: "HF targeted for July 2021 following the Berlin fork",
    url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
    status: "Final",
    eips: [1559, 3198, 3529, 3541],
  },
  fz = {
    name: "shanghai",
    comment:
      "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
    status: "Final",
    eips: [3651, 3855, 3860, 4895],
  },
  hz = {
    name: "arrowGlacier",
    comment: "HF to delay the difficulty bomb",
    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
    status: "Final",
    eips: [4345],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  pz = {
    name: "grayGlacier",
    comment: "Delaying the difficulty bomb to Mid September 2022",
    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
    status: "Draft",
    eips: [5133],
    gasConfig: {},
    gasPrices: {},
    vm: {},
    pow: {},
  },
  mz = {
    name: "mergeForkIdTransition",
    comment: "Pre-merge hardfork to fork off non-upgraded clients",
    url: "https://eips.ethereum.org/EIPS/eip-3675",
    status: "Draft",
    eips: [],
  },
  yz = {
    name: "merge",
    comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
    url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
    status: "Final",
    consensus: { type: "pos", algorithm: "casper", casper: {} },
    eips: [3675, 4399],
  },
  gz = {
    chainstart: ez,
    homestead: nz,
    dao: tz,
    tangerineWhistle: rz,
    spuriousDragon: iz,
    byzantium: sz,
    constantinople: oz,
    petersburg: az,
    istanbul: uz,
    muirGlacier: cz,
    berlin: lz,
    london: dz,
    shanghai: fz,
    arrowGlacier: hz,
    grayGlacier: pz,
    mergeForkIdTransition: mz,
    merge: yz,
  },
  { buf: vz } = I7;
class gt extends zb {
  constructor(t) {
    var n, r;
    super(),
      (this._eips = []),
      (this._customChains =
        (n = t.customChains) !== null && n !== void 0 ? n : []),
      (this._chainParams = this.setChain(t.chain)),
      (this.DEFAULT_HARDFORK =
        (r = this._chainParams.defaultHardfork) !== null && r !== void 0
          ? r
          : Ue.Merge),
      (this.HARDFORK_CHANGES = this.hardforks().map((i) => [
        i.name,
        gz[i.name],
      ])),
      (this._hardfork = this.DEFAULT_HARDFORK),
      t.hardfork !== void 0 && this.setHardfork(t.hardfork),
      t.eips && this.setEIPs(t.eips);
  }
  static custom(t, n = {}) {
    var r;
    const i = (r = n.baseChain) !== null && r !== void 0 ? r : "mainnet",
      s = Object.assign({}, gt._getChainParams(i));
    if (((s.name = "custom-chain"), typeof t != "string"))
      return new gt(
        Object.assign({ chain: Object.assign(Object.assign({}, s), t) }, n)
      );
    if (t === Qt.PolygonMainnet)
      return gt.custom(
        { name: Qt.PolygonMainnet, chainId: 137, networkId: 137 },
        n
      );
    if (t === Qt.PolygonMumbai)
      return gt.custom(
        { name: Qt.PolygonMumbai, chainId: 80001, networkId: 80001 },
        n
      );
    if (t === Qt.ArbitrumRinkebyTestnet)
      return gt.custom(
        { name: Qt.ArbitrumRinkebyTestnet, chainId: 421611, networkId: 421611 },
        n
      );
    if (t === Qt.ArbitrumOne)
      return gt.custom(
        { name: Qt.ArbitrumOne, chainId: 42161, networkId: 42161 },
        n
      );
    if (t === Qt.xDaiChain)
      return gt.custom({ name: Qt.xDaiChain, chainId: 100, networkId: 100 }, n);
    if (t === Qt.OptimisticKovan)
      return gt.custom(
        { name: Qt.OptimisticKovan, chainId: 69, networkId: 69 },
        Object.assign({ hardfork: Ue.Berlin }, n)
      );
    if (t === Qt.OptimisticEthereum)
      return gt.custom(
        { name: Qt.OptimisticEthereum, chainId: 10, networkId: 10 },
        Object.assign({ hardfork: Ue.Berlin }, n)
      );
    throw new Error(`Custom chain ${t} not supported`);
  }
  static fromGethGenesis(
    t,
    { chain: n, eips: r, genesisHash: i, hardfork: s, mergeForkIdPostMerge: o }
  ) {
    var a;
    const u = v7(t, n, o),
      l = new gt({
        chain: (a = u.name) !== null && a !== void 0 ? a : "custom",
        customChains: [u],
        eips: r,
        hardfork: s ?? u.hardfork,
      });
    return i !== void 0 && l.setForkHashes(i), l;
  }
  static isSupportedChainId(t) {
    return !!this._getInitializedChains().names[t.toString()];
  }
  static _getChainParams(t, n) {
    let r = t;
    const i = this._getInitializedChains(n);
    if (typeof r == "number" || typeof r == "bigint") {
      if (((r = r.toString()), i.names[r])) {
        const s = i.names[r];
        return i[s];
      }
      throw new Error(`Chain with ID ${r} not supported`);
    }
    if (i[r] !== void 0) return i[r];
    throw new Error(`Chain with name ${r} not supported`);
  }
  setChain(t) {
    if (typeof t == "number" || typeof t == "bigint" || typeof t == "string")
      this._chainParams = gt._getChainParams(t, this._customChains);
    else if (typeof t == "object") {
      if (this._customChains.length > 0)
        throw new Error(
          "Chain must be a string, number, or bigint when initialized with customChains passed in"
        );
      const n = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
      for (const r of n)
        if (!(r in t))
          throw new Error(`Missing required chain parameter: ${r}`);
      this._chainParams = t;
    } else throw new Error("Wrong input format");
    for (const n of this.hardforks())
      if (n.block === void 0)
        throw new Error("Hardfork cannot have undefined block number");
    return this._chainParams;
  }
  setHardfork(t) {
    let n = !1;
    for (const r of this.HARDFORK_CHANGES)
      r[0] === t &&
        (this._hardfork !== t &&
          ((this._hardfork = t), this.emit("hardforkChanged", t)),
        (n = !0));
    if (!n) throw new Error(`Hardfork with name ${t} not supported`);
  }
  getHardforkByBlockNumber(t, n, r) {
    const i = xo(t, Wn.BigInt),
      s = xo(n, Wn.BigInt),
      o = xo(r, Wn.Number),
      a = this.hardforks().filter(
        (p) =>
          p.block !== null ||
          (p.ttd !== null && p.ttd !== void 0) ||
          p.timestamp !== void 0
      ),
      u = a.findIndex((p) => p.ttd !== null && p.ttd !== void 0);
    if (
      a.slice(u + 1).findIndex((p) => p.ttd !== null && p.ttd !== void 0) >= 0
    )
      throw Error("More than one merge hardforks found with ttd specified");
    let c = a.findIndex(
      (p) =>
        (p.block !== null && p.block > i) ||
        (o !== void 0 && Number(p.timestamp) > o)
    );
    if (c === -1) c = a.length;
    else if (c === 0) throw Error("Must have at least one hardfork at block 0");
    if (o === void 0) {
      const p = a
        .slice(0, c)
        .reverse()
        .findIndex((m) => m.block !== null || m.ttd !== void 0);
      c -= p;
    }
    if (((c -= 1), a[c].block === null && a[c].timestamp === void 0))
      (s == null || BigInt(a[c].ttd) > s) && (c -= 1);
    else if (u >= 0 && s !== void 0 && s !== null) {
      if (c >= u && BigInt(a[u].ttd) > s)
        throw Error(
          "Maximum HF determined by total difficulty is lower than the block number HF"
        );
      if (c < u && BigInt(a[u].ttd) <= s)
        throw Error(
          "HF determined by block number is lower than the minimum total difficulty HF"
        );
    }
    const d = c;
    for (
      ;
      c < a.length - 1 &&
      !(a[c].block !== a[c + 1].block || a[c].timestamp !== a[c + 1].timestamp);
      c += 1
    );
    if (o) {
      if (
        a.slice(0, d).reduce((g, w) => {
          var v;
          return Math.max(
            Number((v = w.timestamp) !== null && v !== void 0 ? v : "0"),
            g
          );
        }, 0) > o
      )
        throw Error(
          "Maximum HF determined by timestamp is lower than the block number/ttd HF"
        );
      if (
        a.slice(c + 1).reduce((g, w) => {
          var v;
          return Math.min(
            Number((v = w.timestamp) !== null && v !== void 0 ? v : o),
            g
          );
        }, o) < o
      )
        throw Error(
          "Maximum HF determined by block number/ttd is lower than timestamp HF"
        );
    }
    return a[c].name;
  }
  setHardforkByBlockNumber(t, n, r) {
    const i = this.getHardforkByBlockNumber(t, n, r);
    return this.setHardfork(i), i;
  }
  _getHardfork(t) {
    const n = this.hardforks();
    for (const r of n) if (r.name === t) return r;
    return null;
  }
  setEIPs(t = []) {
    for (const n of t) {
      if (!(n in Co)) throw new Error(`${n} not supported`);
      const r = this.gteHardfork(Co[n].minimumHardfork);
      if (!r)
        throw new Error(
          `${n} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`
        );
      if (Co[n].requiredEIPs !== void 0) {
        for (const i of Co[n].requiredEIPs)
          if (!(t.includes(i) || this.isActivatedEIP(i)))
            throw new Error(
              `${n} requires EIP ${i}, but is not included in the EIP list`
            );
      }
    }
    this._eips = t;
  }
  param(t, n) {
    let r;
    for (const i of this._eips)
      if (((r = this.paramByEIP(t, n, i)), r !== void 0)) return r;
    return this.paramByHardfork(t, n, this._hardfork);
  }
  paramByHardfork(t, n, r) {
    let i = null;
    for (const s of this.HARDFORK_CHANGES) {
      if ("eips" in s[1]) {
        const o = s[1].eips;
        for (const a of o) {
          const u = this.paramByEIP(t, n, a);
          i = typeof u == "bigint" ? u : i;
        }
      } else {
        if (s[1][t] === void 0) throw new Error(`Topic ${t} not defined`);
        s[1][t][n] !== void 0 && (i = s[1][t][n].v);
      }
      if (s[0] === r) break;
    }
    return BigInt(i ?? 0);
  }
  paramByEIP(t, n, r) {
    if (!(r in Co)) throw new Error(`${r} not supported`);
    const i = Co[r];
    if (!(t in i)) throw new Error(`Topic ${t} not defined`);
    if (i[t][n] === void 0) return;
    const s = i[t][n].v;
    return BigInt(s);
  }
  paramByBlock(t, n, r, i, s) {
    const o = this.getHardforkByBlockNumber(r, i, s);
    return this.paramByHardfork(t, n, o);
  }
  isActivatedEIP(t) {
    if (this.eips().includes(t)) return !0;
    for (const n of this.HARDFORK_CHANGES) {
      const r = n[1];
      if (this.gteHardfork(r.name) && "eips" in r && r.eips.includes(t))
        return !0;
    }
    return !1;
  }
  hardforkIsActiveOnBlock(t, n) {
    const r = xo(n, Wn.BigInt),
      i = t ?? this._hardfork,
      s = this.hardforkBlock(i);
    return typeof s == "bigint" && s !== BigInt(0) && r >= s;
  }
  activeOnBlock(t) {
    return this.hardforkIsActiveOnBlock(null, t);
  }
  hardforkGteHardfork(t, n) {
    const r = t ?? this._hardfork,
      i = this.hardforks();
    let s = -1,
      o = -1,
      a = 0;
    for (const u of i)
      u.name === r && (s = a), u.name === n && (o = a), (a += 1);
    return s >= o && o !== -1;
  }
  gteHardfork(t) {
    return this.hardforkGteHardfork(null, t);
  }
  hardforkBlock(t) {
    var n;
    const r = t ?? this._hardfork,
      i =
        (n = this._getHardfork(r)) === null || n === void 0 ? void 0 : n.block;
    return i == null ? null : BigInt(i);
  }
  hardforkTimestamp(t) {
    var n;
    const r = t ?? this._hardfork,
      i =
        (n = this._getHardfork(r)) === null || n === void 0
          ? void 0
          : n.timestamp;
    return i == null ? null : BigInt(i);
  }
  eipBlock(t) {
    for (const n of this.HARDFORK_CHANGES) {
      const r = n[1];
      if ("eips" in r && r.eips.includes(t))
        return this.hardforkBlock(
          typeof n[0] == "number" ? String(n[0]) : n[0]
        );
    }
    return null;
  }
  hardforkTTD(t) {
    var n;
    const r = t ?? this._hardfork,
      i = (n = this._getHardfork(r)) === null || n === void 0 ? void 0 : n.ttd;
    return i == null ? null : BigInt(i);
  }
  isHardforkBlock(t, n) {
    const r = xo(t, Wn.BigInt),
      i = n ?? this._hardfork,
      s = this.hardforkBlock(i);
    return typeof s == "bigint" && s !== BigInt(0) ? s === r : !1;
  }
  nextHardforkBlockOrTimestamp(t) {
    var n, r;
    const i = t ?? this._hardfork,
      s = this.hardforks();
    let o = s.findIndex((c) => c.name === i);
    if ((i === Ue.Merge && (o -= 1), o < 0)) return null;
    let a = (n = s[o].timestamp) !== null && n !== void 0 ? n : s[o].block;
    a = a != null ? Number(a) : null;
    const u = s.slice(o + 1).find((c) => {
      var d;
      let f = (d = c.timestamp) !== null && d !== void 0 ? d : c.block;
      return (
        (f = f != null ? Number(f) : null),
        c.name !== Ue.Merge && f !== null && f !== void 0 && f !== a
      );
    });
    if (u === void 0) return null;
    const l = (r = u.timestamp) !== null && r !== void 0 ? r : u.block;
    return l == null ? null : BigInt(l);
  }
  nextHardforkBlock(t) {
    const n = t ?? this._hardfork;
    let r = this.hardforkBlock(n);
    if (r === null && n === Ue.Merge) {
      const s = this.hardforks(),
        o = s.findIndex((a) => a.ttd !== null && a.ttd !== void 0);
      if (o < 0) throw Error("Merge hardfork should have been found");
      r = this.hardforkBlock(s[o - 1].name);
    }
    return r === null
      ? null
      : this.hardforks().reduce((s, o) => {
          const a = BigInt(
            o.block === null || (o.ttd !== void 0 && o.ttd !== null)
              ? 0
              : o.block
          );
          return a > r && s === null ? a : s;
        }, null);
  }
  isNextHardforkBlock(t, n) {
    const r = xo(t, Wn.BigInt),
      i = n ?? this._hardfork,
      s = this.nextHardforkBlock(i);
    return s === null ? !1 : s === r;
  }
  _calcForkHash(t, n) {
    let r = new Uint8Array(),
      i = 0;
    for (const a of this.hardforks()) {
      const { block: u, timestamp: l, name: c } = a;
      let d = l ?? u;
      if (
        ((d = d !== null ? Number(d) : null),
        typeof d == "number" && d !== 0 && d !== i && c !== Ue.Merge)
      ) {
        const f = He(d.toString(16).padStart(16, "0"));
        (r = an(r, f)), (i = d);
      }
      if (a.name === t) break;
    }
    const s = an(n, r);
    return ve(b7(vz(s) >>> 0));
  }
  forkHash(t, n) {
    const r = t ?? this._hardfork,
      i = this._getHardfork(r);
    if (
      i === null ||
      ((i == null ? void 0 : i.block) === null &&
        (i == null ? void 0 : i.timestamp) === void 0 &&
        (i == null ? void 0 : i.ttd) === void 0)
    ) {
      const s = "No fork hash calculation possible for future hardfork";
      throw new Error(s);
    }
    if (
      (i == null ? void 0 : i.forkHash) !== null &&
      (i == null ? void 0 : i.forkHash) !== void 0
    )
      return i.forkHash;
    if (!n) throw new Error("genesisHash required for forkHash calculation");
    return this._calcForkHash(r, n);
  }
  hardforkForForkHash(t) {
    const n = this.hardforks().filter((r) => r.forkHash === t);
    return n.length >= 1 ? n[n.length - 1] : null;
  }
  setForkHashes(t) {
    var n;
    for (const r of this.hardforks()) {
      const i = (n = r.timestamp) !== null && n !== void 0 ? n : r.block;
      (r.forkHash === null || r.forkHash === void 0) &&
        (i != null || typeof r.ttd < "u") &&
        (r.forkHash = this.forkHash(r.name, t));
    }
  }
  genesis() {
    return this._chainParams.genesis;
  }
  hardforks() {
    return this._chainParams.hardforks;
  }
  bootstrapNodes() {
    return this._chainParams.bootstrapNodes;
  }
  dnsNetworks() {
    return this._chainParams.dnsNetworks;
  }
  hardfork() {
    return this._hardfork;
  }
  chainId() {
    return BigInt(this._chainParams.chainId);
  }
  chainName() {
    return this._chainParams.name;
  }
  networkId() {
    return BigInt(this._chainParams.networkId);
  }
  eips() {
    return this._eips;
  }
  consensusType() {
    const t = this.hardfork();
    let n;
    for (const r of this.HARDFORK_CHANGES)
      if (("consensus" in r[1] && (n = r[1].consensus.type), r[0] === t)) break;
    return n ?? this._chainParams.consensus.type;
  }
  consensusAlgorithm() {
    const t = this.hardfork();
    let n;
    for (const r of this.HARDFORK_CHANGES)
      if (("consensus" in r[1] && (n = r[1].consensus.algorithm), r[0] === t))
        break;
    return n ?? this._chainParams.consensus.algorithm;
  }
  consensusConfig() {
    var t;
    const n = this.hardfork();
    let r;
    for (const i of this.HARDFORK_CHANGES)
      if (
        ("consensus" in i[1] && (r = i[1].consensus[i[1].consensus.algorithm]),
        i[0] === n)
      )
        break;
    return (t = r ?? this._chainParams.consensus[this.consensusAlgorithm()]) !==
      null && t !== void 0
      ? t
      : {};
  }
  copy() {
    const t = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    return t.removeAllListeners(), t;
  }
  static _getInitializedChains(t) {
    const n = {};
    for (const [i, s] of Object.entries(sh)) n[s] = i.toLowerCase();
    const r = { mainnet: P7, goerli: k7, sepolia: D7 };
    if (t)
      for (const i of t) {
        const { name: s } = i;
        (n[i.chainId.toString()] = s), (r[s] = i);
      }
    return (r.names = n), r;
  }
}
var Cr;
(function (e) {
  (e[(e.EIP155ReplayProtection = 155)] = "EIP155ReplayProtection"),
    (e[(e.EIP1559FeeMarket = 1559)] = "EIP1559FeeMarket"),
    (e[(e.EIP2718TypedTransaction = 2718)] = "EIP2718TypedTransaction"),
    (e[(e.EIP2930AccessLists = 2930)] = "EIP2930AccessLists");
})(Cr || (Cr = {}));
function bz(e) {
  if (e.length === 0) return !0;
  const t = e[0];
  return !!Array.isArray(t);
}
function wz(e) {
  return !bz(e);
}
class ua {
  constructor(t) {
    if (t.length !== 20) throw new Error("Invalid address length");
    this.buf = t;
  }
  static zero() {
    return new ua(RT(20));
  }
  equals(t) {
    return gp(this.buf, t.buf);
  }
  isZero() {
    return this.equals(ua.zero());
  }
  toString() {
    return ve(this.buf);
  }
  toArray() {
    return this.buf;
  }
  static publicToAddress(t, n = !1) {
    let r = t;
    if (
      (ow(r),
      n &&
        r.length !== 64 &&
        (r = bi.ProjectivePoint.fromHex(r).toRawBytes(!1).slice(1)),
      r.length !== 64)
    )
      throw new Error("Expected pubKey to be of length 64");
    return Zt(r).slice(-20);
  }
}
const Ez = (e, t) => {
    const n = e.param("vm", "maxInitCodeSize");
    if (n && BigInt(t) > n)
      throw new Error(
        `the initcode size of this transaction is too large: it is ${t} while the max is ${e.param(
          "vm",
          "maxInitCodeSize"
        )}`
      );
  },
  $T = (e) => {
    let t, n;
    if (wz(e)) {
      t = e;
      const r = [];
      for (let i = 0; i < e.length; i += 1) {
        const s = e[i],
          o = Qe(s.address),
          a = [];
        for (let u = 0; u < s.storageKeys.length; u += 1)
          a.push(Qe(s.storageKeys[u]));
        r.push([o, a]);
      }
      n = r;
    } else {
      n = e ?? [];
      const r = [];
      for (let i = 0; i < n.length; i += 1) {
        const s = n[i],
          o = ve(s[0]),
          a = [];
        for (let l = 0; l < s[1].length; l += 1) a.push(ve(s[1][l]));
        const u = { address: o, storageKeys: a };
        r.push(u);
      }
      t = r;
    }
    return { AccessListJSON: t, accessList: n };
  },
  HT = (e) => {
    for (let t = 0; t < e.length; t += 1) {
      const n = e[t],
        r = n[0],
        i = n[1];
      if (n[2] !== void 0)
        throw new Error(
          "Access list item cannot have 3 elements. It can only have an address, and an array of storage slots."
        );
      if (r.length !== 20)
        throw new Error(
          "Invalid EIP-2930 transaction: address length should be 20 bytes"
        );
      for (let s = 0; s < i.length; s += 1)
        if (i[s].length !== 32)
          throw new Error(
            "Invalid EIP-2930 transaction: storage slot length should be 32 bytes"
          );
    }
  },
  zT = (e) => {
    const t = [];
    for (let n = 0; n < e.length; n += 1) {
      const r = e[n],
        i = { address: ve(Z_(r[0], 20)), storageKeys: [] },
        s = r && r[1];
      for (let o = 0; o < s.length; o += 1) {
        const a = s[o];
        i.storageKeys.push(ve(Z_(a, 32)));
      }
      t.push(i);
    }
    return t;
  },
  GT = (e, t) => {
    const n = t.param("gasPrices", "accessListStorageKeyCost"),
      r = t.param("gasPrices", "accessListAddressCost");
    let i = 0;
    for (let o = 0; o < e.length; o += 1) {
      const u = e[o][1];
      i += u.length;
    }
    return e.length * Number(r) + i * Number(n);
  };
class Ia {
  constructor(t, n) {
    var r, i;
    (this.cache = { hash: void 0, dataFee: void 0 }),
      (this.activeCapabilities = []),
      (this.DEFAULT_CHAIN = sh.Mainnet),
      (this.DEFAULT_HARDFORK = Ue.Merge);
    const {
      nonce: s,
      gasLimit: o,
      to: a,
      value: u,
      data: l,
      v: c,
      r: d,
      s: f,
      type: p,
    } = t;
    (this._type = Number(je(Qe(p)))), (this.txOptions = n);
    const m = Qe(a === "" ? "0x" : a),
      g = Qe(c === "" ? "0x" : c),
      w = Qe(d === "" ? "0x" : d),
      v = Qe(f === "" ? "0x" : f);
    (this.nonce = je(Qe(s === "" ? "0x" : s))),
      (this.gasLimit = je(Qe(o === "" ? "0x" : o))),
      (this.to = m.length > 0 ? new ua(m) : void 0),
      (this.value = je(Qe(u === "" ? "0x" : u))),
      (this.data = Qe(l === "" ? "0x" : l)),
      (this.v = g.length > 0 ? je(g) : void 0),
      (this.r = w.length > 0 ? je(w) : void 0),
      (this.s = v.length > 0 ? je(v) : void 0),
      this._validateCannotExceedMaxInteger({
        value: this.value,
        r: this.r,
        s: this.s,
      }),
      this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64),
      this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, !0);
    const y = this.to === void 0 || this.to === null,
      b = (r = n.allowUnlimitedInitCodeSize) !== null && r !== void 0 ? r : !1,
      _ = (i = n.common) !== null && i !== void 0 ? i : this._getCommon();
    y && _.isActivatedEIP(3860) && !b && Ez(_, this.data.length);
  }
  get type() {
    return this._type;
  }
  supports(t) {
    return this.activeCapabilities.includes(t);
  }
  validate(t = !1) {
    const n = [];
    return (
      this.getBaseFee() > this.gasLimit &&
        n.push(
          `gasLimit is too low. given ${
            this.gasLimit
          }, need at least ${this.getBaseFee()}`
        ),
      this.isSigned() && !this.verifySignature() && n.push("Invalid Signature"),
      t ? n : n.length === 0
    );
  }
  _validateYParity() {
    const { v: t } = this;
    if (t !== void 0 && t !== BigInt(0) && t !== BigInt(1)) {
      const n = this._errorMsg(
        "The y-parity of the transaction should either be 0 or 1"
      );
      throw new Error(n);
    }
  }
  _validateHighS() {
    const { s: t } = this;
    if (this.common.gteHardfork("homestead") && t !== void 0 && t > p7) {
      const n = this._errorMsg(
        "Invalid Signature: s-values greater than secp256k1n/2 are considered invalid"
      );
      throw new Error(n);
    }
  }
  getBaseFee() {
    const t = this.common.param("gasPrices", "tx");
    let n = this.getDataFee();
    if (
      (t && (n += t),
      this.common.gteHardfork("homestead") && this.toCreationAddress())
    ) {
      const r = this.common.param("gasPrices", "txCreation");
      r && (n += r);
    }
    return n;
  }
  getDataFee() {
    const t = this.common.param("gasPrices", "txDataZero"),
      n = this.common.param("gasPrices", "txDataNonZero");
    let r = BigInt(0);
    for (let i = 0; i < this.data.length; i += 1)
      this.data[i] === 0 ? (r += t) : (r += n);
    if (
      (this.to === void 0 || this.to === null) &&
      this.common.isActivatedEIP(3860)
    ) {
      const i = BigInt(Math.ceil(this.data.length / 32)),
        s = this.common.param("gasPrices", "initCodeWordCost") * i;
      r += s;
    }
    return r;
  }
  toCreationAddress() {
    return this.to === void 0 || this.to.buf.length === 0;
  }
  isSigned() {
    const { v: t, r: n, s: r } = this;
    return !(t === void 0 || n === void 0 || r === void 0);
  }
  verifySignature() {
    try {
      const t = this.getSenderPublicKey();
      return oh(t).length !== 0;
    } catch {
      return !1;
    }
  }
  getSenderAddress() {
    return new ua(ua.publicToAddress(this.getSenderPublicKey()));
  }
  sign(t) {
    if (t.length !== 32) {
      const u = this._errorMsg("Private key must be 32 bytes in length.");
      throw new Error(u);
    }
    let n = !1;
    this.type === 0 &&
      this.common.gteHardfork("spuriousDragon") &&
      !this.supports(Cr.EIP155ReplayProtection) &&
      (this.activeCapabilities.push(Cr.EIP155ReplayProtection), (n = !0));
    const r = this.getMessageToSign(!0),
      { v: i, r: s, s: o } = this._ecsign(r, t),
      a = this._processSignature(i, s, o);
    if (n) {
      const u = this.activeCapabilities.indexOf(Cr.EIP155ReplayProtection);
      u > -1 && this.activeCapabilities.splice(u, 1);
    }
    return a;
  }
  _getCommon(t, n) {
    var r;
    if (n !== void 0) {
      const i = je(Qe(n));
      if (t) {
        if (t.chainId() !== i) {
          const s = this._errorMsg(
            "The chain ID does not match the chain ID of Common"
          );
          throw new Error(s);
        }
        return t.copy();
      }
      return gt.isSupportedChainId(i)
        ? new gt({ chain: i, hardfork: this.DEFAULT_HARDFORK })
        : gt.custom(
            { name: "custom-chain", networkId: i, chainId: i },
            { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK }
          );
    }
    return (r = t == null ? void 0 : t.copy()) !== null && r !== void 0
      ? r
      : new gt({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
  }
  _validateCannotExceedMaxInteger(t, n = 256, r = !1) {
    for (const [i, s] of Object.entries(t))
      switch (n) {
        case 64:
          if (r) {
            if (s !== void 0 && s >= Q_) {
              const o = this._errorMsg(
                `${i} cannot equal or exceed MAX_UINT64 (2^64-1), given ${s}`
              );
              throw new Error(o);
            }
          } else if (s !== void 0 && s > Q_) {
            const o = this._errorMsg(
              `${i} cannot exceed MAX_UINT64 (2^64-1), given ${s}`
            );
            throw new Error(o);
          }
          break;
        case 256:
          if (r) {
            if (s !== void 0 && s >= Qc) {
              const o = this._errorMsg(
                `${i} cannot equal or exceed MAX_INTEGER (2^256-1), given ${s}`
              );
              throw new Error(o);
            }
          } else if (s !== void 0 && s > Qc) {
            const o = this._errorMsg(
              `${i} cannot exceed MAX_INTEGER (2^256-1), given ${s}`
            );
            throw new Error(o);
          }
          break;
        default: {
          const o = this._errorMsg("unimplemented bits value");
          throw new Error(o);
        }
      }
  }
  static _validateNotArray(t) {
    const n = [
      "nonce",
      "gasPrice",
      "gasLimit",
      "to",
      "value",
      "data",
      "v",
      "r",
      "s",
      "type",
      "baseFee",
      "maxFeePerGas",
      "chainId",
    ];
    for (const [r, i] of Object.entries(t))
      if (n.includes(r) && Array.isArray(i))
        throw new Error(`${r} cannot be an array`);
  }
  _getSharedErrorPostfix() {
    let t = "";
    try {
      t = this.isSigned() ? ve(this.hash()) : "not available (unsigned)";
    } catch {
      t = "error";
    }
    let n = "";
    try {
      n = this.isSigned().toString();
    } catch {
      t = "error";
    }
    let r = "";
    try {
      r = this.common.hardfork();
    } catch {
      r = "error";
    }
    let i = `tx type=${this.type} hash=${t} nonce=${this.nonce} value=${this.value} `;
    return (i += `signed=${n} hf=${r}`), i;
  }
  _ecsign(t, n, r) {
    const i = bi.sign(t, n),
      s = i.toCompactRawBytes(),
      o = s.subarray(0, 32),
      a = s.subarray(32, 64),
      u =
        r === void 0
          ? BigInt(i.recovery + 27)
          : BigInt(i.recovery + 35) + BigInt(r) * BigInt(2);
    return { r: o, s: a, v: u };
  }
  static fromSerializedTx(t, n = {}) {}
  static fromTxData(t, n = {}) {}
}
const bg = 2,
  Km = He(bg.toString(16).padStart(2, "0"));
class Ms extends Ia {
  constructor(t, n = {}) {
    var r;
    super(Object.assign(Object.assign({}, t), { type: bg }), n),
      (this.DEFAULT_HARDFORK = "london");
    const {
      chainId: i,
      accessList: s,
      maxFeePerGas: o,
      maxPriorityFeePerGas: a,
    } = t;
    if (
      ((this.common = this._getCommon(n.common, i)),
      (this.chainId = this.common.chainId()),
      !this.common.isActivatedEIP(1559))
    )
      throw new Error("EIP-1559 not enabled on Common");
    this.activeCapabilities = this.activeCapabilities.concat([
      1559, 2718, 2930,
    ]);
    const u = $T(s ?? []);
    if (
      ((this.accessList = u.accessList),
      (this.AccessListJSON = u.AccessListJSON),
      HT(this.accessList),
      (this.maxFeePerGas = je(Qe(o === "" ? "0x" : o))),
      (this.maxPriorityFeePerGas = je(Qe(a === "" ? "0x" : a))),
      this._validateCannotExceedMaxInteger({
        maxFeePerGas: this.maxFeePerGas,
        maxPriorityFeePerGas: this.maxPriorityFeePerGas,
      }),
      Ia._validateNotArray(t),
      this.gasLimit * this.maxFeePerGas > Qc)
    ) {
      const c = this._errorMsg(
        "gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)"
      );
      throw new Error(c);
    }
    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
      const c = this._errorMsg(
        "maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)"
      );
      throw new Error(c);
    }
    this._validateYParity(),
      this._validateHighS(),
      ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0 ? r : !0) &&
        Object.freeze(this);
  }
  static fromTxData(t, n = {}) {
    return new Ms(t, n);
  }
  static fromSerializedTx(t, n = {}) {
    if (!gp(t.subarray(0, 1), Km))
      throw new Error(
        `Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${bg}, received: ${ve(
          t.subarray(0, 1)
        )}`
      );
    const r = Sn.decode(t.subarray(1));
    if (!Array.isArray(r))
      throw new Error("Invalid serialized tx input: must be array");
    return Ms.fromValuesArray(r, n);
  }
  static fromValuesArray(t, n = {}) {
    if (t.length !== 9 && t.length !== 12)
      throw new Error(
        "Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx)."
      );
    const [r, i, s, o, a, u, l, c, d, f, p, m] = t;
    return (
      this._validateNotArray({ chainId: r, v: f }),
      Nb({
        nonce: i,
        maxPriorityFeePerGas: s,
        maxFeePerGas: o,
        gasLimit: a,
        value: l,
        v: f,
        r: p,
        s: m,
      }),
      new Ms(
        {
          chainId: je(r),
          nonce: i,
          maxPriorityFeePerGas: s,
          maxFeePerGas: o,
          gasLimit: a,
          to: u,
          value: l,
          data: c,
          accessList: d ?? [],
          v: f !== void 0 ? je(f) : void 0,
          r: p,
          s: m,
        },
        n
      )
    );
  }
  getDataFee() {
    if (
      this.cache.dataFee &&
      this.cache.dataFee.hardfork === this.common.hardfork()
    )
      return this.cache.dataFee.value;
    let t = super.getDataFee();
    return (
      (t += BigInt(GT(this.accessList, this.common))),
      Object.isFrozen(this) &&
        (this.cache.dataFee = { value: t, hardfork: this.common.hardfork() }),
      t
    );
  }
  getUpfrontCost(t = BigInt(0)) {
    const n = this.maxPriorityFeePerGas,
      r = this.maxFeePerGas - t,
      s = (n < r ? n : r) + t;
    return this.gasLimit * s + this.value;
  }
  raw() {
    return [
      xe(this.chainId),
      xe(this.nonce),
      xe(this.maxPriorityFeePerGas),
      xe(this.maxFeePerGas),
      xe(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      xe(this.value),
      this.data,
      this.accessList,
      this.v !== void 0 ? xe(this.v) : Uint8Array.from([]),
      this.r !== void 0 ? xe(this.r) : Uint8Array.from([]),
      this.s !== void 0 ? xe(this.s) : Uint8Array.from([]),
    ];
  }
  serialize() {
    const t = this.raw();
    return an(Km, Sn.encode(t));
  }
  getMessageToSign(t = !0) {
    const n = this.raw().slice(0, 9),
      r = an(Km, Sn.encode(n));
    return t ? Zt(r) : r;
  }
  hash() {
    if (!this.isSigned()) {
      const t = this._errorMsg(
        "Cannot call hash method if transaction is not signed"
      );
      throw new Error(t);
    }
    return Object.isFrozen(this)
      ? (this.cache.hash || (this.cache.hash = Zt(this.serialize())),
        this.cache.hash)
      : Zt(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const s = this._errorMsg(
        "Cannot call this method if transaction is not signed"
      );
      throw new Error(s);
    }
    const t = this.getMessageToVerifySignature(),
      { v: n, r, s: i } = this;
    this._validateHighS();
    try {
      return aw(t, n + BigInt(27), xe(r), xe(i));
    } catch {
      const o = this._errorMsg("Invalid Signature");
      throw new Error(o);
    }
  }
  _processSignature(t, n, r) {
    const i = Object.assign(Object.assign({}, this.txOptions), {
      common: this.common,
    });
    return Ms.fromTxData(
      {
        chainId: this.chainId,
        nonce: this.nonce,
        maxPriorityFeePerGas: this.maxPriorityFeePerGas,
        maxFeePerGas: this.maxFeePerGas,
        gasLimit: this.gasLimit,
        to: this.to,
        value: this.value,
        data: this.data,
        accessList: this.accessList,
        v: t - BigInt(27),
        r: je(n),
        s: je(r),
      },
      i
    );
  }
  toJSON() {
    const t = zT(this.accessList);
    return {
      chainId: Ve(this.chainId),
      nonce: Ve(this.nonce),
      maxPriorityFeePerGas: Ve(this.maxPriorityFeePerGas),
      maxFeePerGas: Ve(this.maxFeePerGas),
      gasLimit: Ve(this.gasLimit),
      to: this.to !== void 0 ? this.to.toString() : void 0,
      value: Ve(this.value),
      data: ve(this.data),
      accessList: t,
      v: this.v !== void 0 ? Ve(this.v) : void 0,
      r: this.r !== void 0 ? Ve(this.r) : void 0,
      s: this.s !== void 0 ? Ve(this.s) : void 0,
    };
  }
  errorStr() {
    let t = this._getSharedErrorPostfix();
    return (
      (t += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`),
      t
    );
  }
  _errorMsg(t) {
    return `${t} (${this.errorStr()})`;
  }
}
const wg = 1,
  Zm = He(wg.toString(16).padStart(2, "0"));
class Ls extends Ia {
  constructor(t, n = {}) {
    var r;
    super(Object.assign(Object.assign({}, t), { type: wg }), n),
      (this.DEFAULT_HARDFORK = "berlin");
    const { chainId: i, accessList: s, gasPrice: o } = t;
    if (
      ((this.common = this._getCommon(n.common, i)),
      (this.chainId = this.common.chainId()),
      !this.common.isActivatedEIP(2930))
    )
      throw new Error("EIP-2930 not enabled on Common");
    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
    const a = $T(s ?? []);
    if (
      ((this.accessList = a.accessList),
      (this.AccessListJSON = a.AccessListJSON),
      HT(this.accessList),
      (this.gasPrice = je(Qe(o === "" ? "0x" : o))),
      this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice }),
      Ia._validateNotArray(t),
      this.gasPrice * this.gasLimit > Qc)
    ) {
      const l = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
      throw new Error(l);
    }
    this._validateYParity(),
      this._validateHighS(),
      ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0 ? r : !0) &&
        Object.freeze(this);
  }
  static fromTxData(t, n = {}) {
    return new Ls(t, n);
  }
  static fromSerializedTx(t, n = {}) {
    if (!gp(t.subarray(0, 1), Zm))
      throw new Error(
        `Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${wg}, received: ${ve(
          t.subarray(0, 1)
        )}`
      );
    const r = Sn.decode(Uint8Array.from(t.subarray(1)));
    if (!Array.isArray(r))
      throw new Error("Invalid serialized tx input: must be array");
    return Ls.fromValuesArray(r, n);
  }
  static fromValuesArray(t, n = {}) {
    if (t.length !== 8 && t.length !== 11)
      throw new Error(
        "Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx)."
      );
    const [r, i, s, o, a, u, l, c, d, f, p] = t;
    this._validateNotArray({ chainId: r, v: d }),
      Nb({ nonce: i, gasPrice: s, gasLimit: o, value: u, v: d, r: f, s: p });
    const m = [];
    return new Ls(
      {
        chainId: je(r),
        nonce: i,
        gasPrice: s,
        gasLimit: o,
        to: a,
        value: u,
        data: l,
        accessList: c ?? m,
        v: d !== void 0 ? je(d) : void 0,
        r: f,
        s: p,
      },
      n
    );
  }
  getDataFee() {
    if (
      this.cache.dataFee &&
      this.cache.dataFee.hardfork === this.common.hardfork()
    )
      return this.cache.dataFee.value;
    let t = super.getDataFee();
    return (
      (t += BigInt(GT(this.accessList, this.common))),
      Object.isFrozen(this) &&
        (this.cache.dataFee = { value: t, hardfork: this.common.hardfork() }),
      t
    );
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  raw() {
    return [
      xe(this.chainId),
      xe(this.nonce),
      xe(this.gasPrice),
      xe(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      xe(this.value),
      this.data,
      this.accessList,
      this.v !== void 0 ? xe(this.v) : Uint8Array.from([]),
      this.r !== void 0 ? xe(this.r) : Uint8Array.from([]),
      this.s !== void 0 ? xe(this.s) : Uint8Array.from([]),
    ];
  }
  serialize() {
    const t = this.raw();
    return an(Zm, Sn.encode(t));
  }
  getMessageToSign(t = !0) {
    const n = this.raw().slice(0, 8),
      r = an(Zm, Sn.encode(n));
    return t ? Zt(r) : r;
  }
  hash() {
    if (!this.isSigned()) {
      const t = this._errorMsg(
        "Cannot call hash method if transaction is not signed"
      );
      throw new Error(t);
    }
    return Object.isFrozen(this)
      ? (this.cache.hash || (this.cache.hash = Zt(this.serialize())),
        this.cache.hash)
      : Zt(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const s = this._errorMsg(
        "Cannot call this method if transaction is not signed"
      );
      throw new Error(s);
    }
    const t = this.getMessageToVerifySignature(),
      { v: n, r, s: i } = this;
    this._validateHighS();
    try {
      return aw(t, n + BigInt(27), xe(r), xe(i));
    } catch {
      const o = this._errorMsg("Invalid Signature");
      throw new Error(o);
    }
  }
  _processSignature(t, n, r) {
    const i = Object.assign(Object.assign({}, this.txOptions), {
      common: this.common,
    });
    return Ls.fromTxData(
      {
        chainId: this.chainId,
        nonce: this.nonce,
        gasPrice: this.gasPrice,
        gasLimit: this.gasLimit,
        to: this.to,
        value: this.value,
        data: this.data,
        accessList: this.accessList,
        v: t - BigInt(27),
        r: je(n),
        s: je(r),
      },
      i
    );
  }
  toJSON() {
    const t = zT(this.accessList);
    return {
      chainId: Ve(this.chainId),
      nonce: Ve(this.nonce),
      gasPrice: Ve(this.gasPrice),
      gasLimit: Ve(this.gasLimit),
      to: this.to !== void 0 ? this.to.toString() : void 0,
      value: Ve(this.value),
      data: ve(this.data),
      accessList: t,
      v: this.v !== void 0 ? Ve(this.v) : void 0,
      r: this.r !== void 0 ? Ve(this.r) : void 0,
      s: this.s !== void 0 ? Ve(this.s) : void 0,
    };
  }
  errorStr() {
    var t, n;
    let r = this._getSharedErrorPostfix();
    return (
      (r += ` gasPrice=${this.gasPrice} accessListCount=${
        (n =
          (t = this.accessList) === null || t === void 0
            ? void 0
            : t.length) !== null && n !== void 0
          ? n
          : 0
      }`),
      r
    );
  }
  _errorMsg(t) {
    return `${t} (${this.errorStr()})`;
  }
}
const _z = 0;
function X_(e, t) {
  const n = Number(e),
    r = Number(t) * 2;
  return n === r + 35 || n === r + 36;
}
class Hi extends Ia {
  constructor(t, n = {}) {
    var r;
    if (
      (super(Object.assign(Object.assign({}, t), { type: _z }), n),
      (this.common = this._validateTxV(this.v, n.common)),
      (this.gasPrice = je(Qe(t.gasPrice === "" ? "0x" : t.gasPrice))),
      this.gasPrice * this.gasLimit > Qc)
    ) {
      const s = this._errorMsg(
        "gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)"
      );
      throw new Error(s);
    }
    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice }),
      Ia._validateNotArray(t),
      this.common.gteHardfork("spuriousDragon") &&
        (this.isSigned()
          ? X_(this.v, this.common.chainId()) &&
            this.activeCapabilities.push(Cr.EIP155ReplayProtection)
          : this.activeCapabilities.push(Cr.EIP155ReplayProtection)),
      ((r = n == null ? void 0 : n.freeze) !== null && r !== void 0 ? r : !0) &&
        Object.freeze(this);
  }
  static fromTxData(t, n = {}) {
    return new Hi(t, n);
  }
  static fromSerializedTx(t, n = {}) {
    const r = Sn.decode(t);
    if (!Array.isArray(r))
      throw new Error("Invalid serialized tx input. Must be array");
    return this.fromValuesArray(r, n);
  }
  static fromValuesArray(t, n = {}) {
    if (t.length !== 6 && t.length !== 9)
      throw new Error(
        "Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx)."
      );
    const [r, i, s, o, a, u, l, c, d] = t;
    return (
      Nb({ nonce: r, gasPrice: i, gasLimit: s, value: a, v: l, r: c, s: d }),
      new Hi(
        {
          nonce: r,
          gasPrice: i,
          gasLimit: s,
          to: o,
          value: a,
          data: u,
          v: l,
          r: c,
          s: d,
        },
        n
      )
    );
  }
  raw() {
    return [
      xe(this.nonce),
      xe(this.gasPrice),
      xe(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      xe(this.value),
      this.data,
      this.v !== void 0 ? xe(this.v) : Uint8Array.from([]),
      this.r !== void 0 ? xe(this.r) : Uint8Array.from([]),
      this.s !== void 0 ? xe(this.s) : Uint8Array.from([]),
    ];
  }
  serialize() {
    return Sn.encode(this.raw());
  }
  _getMessageToSign() {
    const t = [
      xe(this.nonce),
      xe(this.gasPrice),
      xe(this.gasLimit),
      this.to !== void 0 ? this.to.buf : Uint8Array.from([]),
      xe(this.value),
      this.data,
    ];
    return (
      this.supports(Cr.EIP155ReplayProtection) &&
        (t.push(Qe(this.common.chainId())),
        t.push(oh(Qe(0))),
        t.push(oh(Qe(0)))),
      t
    );
  }
  getMessageToSign(t = !0) {
    const n = this._getMessageToSign();
    return t ? Zt(Sn.encode(n)) : n;
  }
  getDataFee() {
    return this.cache.dataFee &&
      this.cache.dataFee.hardfork === this.common.hardfork()
      ? this.cache.dataFee.value
      : (Object.isFrozen(this) &&
          (this.cache.dataFee = {
            value: super.getDataFee(),
            hardfork: this.common.hardfork(),
          }),
        super.getDataFee());
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  hash() {
    if (!this.isSigned()) {
      const t = this._errorMsg(
        "Cannot call hash method if transaction is not signed"
      );
      throw new Error(t);
    }
    return Object.isFrozen(this)
      ? (this.cache.hash || (this.cache.hash = Zt(Sn.encode(this.raw()))),
        this.cache.hash)
      : Zt(Sn.encode(this.raw()));
  }
  getMessageToVerifySignature() {
    if (!this.isSigned()) {
      const n = this._errorMsg("This transaction is not signed");
      throw new Error(n);
    }
    const t = this._getMessageToSign();
    return Zt(Sn.encode(t));
  }
  getSenderPublicKey() {
    const t = this.getMessageToVerifySignature(),
      { v: n, r, s: i } = this;
    this._validateHighS();
    try {
      return aw(
        t,
        n,
        xe(r),
        xe(i),
        this.supports(Cr.EIP155ReplayProtection)
          ? this.common.chainId()
          : void 0
      );
    } catch {
      const o = this._errorMsg("Invalid Signature");
      throw new Error(o);
    }
  }
  _processSignature(t, n, r) {
    let i = t;
    this.supports(Cr.EIP155ReplayProtection) &&
      (i += this.common.chainId() * BigInt(2) + BigInt(8));
    const s = Object.assign(Object.assign({}, this.txOptions), {
      common: this.common,
    });
    return Hi.fromTxData(
      {
        nonce: this.nonce,
        gasPrice: this.gasPrice,
        gasLimit: this.gasLimit,
        to: this.to,
        value: this.value,
        data: this.data,
        v: i,
        r: je(n),
        s: je(r),
      },
      s
    );
  }
  toJSON() {
    return {
      nonce: Ve(this.nonce),
      gasPrice: Ve(this.gasPrice),
      gasLimit: Ve(this.gasLimit),
      to: this.to !== void 0 ? this.to.toString() : void 0,
      value: Ve(this.value),
      data: ve(this.data),
      v: this.v !== void 0 ? Ve(this.v) : void 0,
      r: this.r !== void 0 ? Ve(this.r) : void 0,
      s: this.s !== void 0 ? Ve(this.s) : void 0,
    };
  }
  _validateTxV(t, n) {
    let r;
    const i = t !== void 0 ? Number(t) : void 0;
    if (i !== void 0 && i < 37 && i !== 27 && i !== 28)
      throw new Error(
        `Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${i}`
      );
    if (
      i !== void 0 &&
      i !== 0 &&
      (!n || n.gteHardfork("spuriousDragon")) &&
      i !== 27 &&
      i !== 28
    )
      if (n) {
        if (!X_(BigInt(i), n.chainId()))
          throw new Error(
            `Incompatible EIP155-based V ${i} and chain id ${n.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`
          );
      } else {
        let s;
        (i - 35) % 2 === 0 ? (s = 35) : (s = 36),
          (r = BigInt(i - s) / BigInt(2));
      }
    return this._getCommon(n, r);
  }
  errorStr() {
    let t = this._getSharedErrorPostfix();
    return (t += ` gasPrice=${this.gasPrice}`), t;
  }
  _errorMsg(t) {
    return `${t} (${this.errorStr()})`;
  }
}
const Jm = new Map();
class lo {
  constructor() {}
  static typeToInt(t) {
    return Number(je(Qe(t)));
  }
  static registerTransactionType(t, n) {
    const r = lo.typeToInt(t);
    Jm.set(r, n);
  }
  static fromTxData(t, n = {}) {
    if (!("type" in t) || t.type === void 0) return Hi.fromTxData(t, n);
    const r = lo.typeToInt(t.type);
    if (r === 0) return Hi.fromTxData(t, n);
    if (r === 1) return Ls.fromTxData(t, n);
    if (r === 2) return Ms.fromTxData(t, n);
    const i = Jm.get(r);
    if (i != null && i.fromTxData) return i.fromTxData(t, n);
    throw new Error(`Tx instantiation with type ${r} not supported`);
  }
  static fromSerializedData(t, n = {}) {
    if (t[0] <= 127)
      switch (t[0]) {
        case 1:
          return Ls.fromSerializedTx(t, n);
        case 2:
          return Ms.fromSerializedTx(t, n);
        default: {
          const r = Jm.get(Number(t[0]));
          if (r != null && r.fromSerializedTx) return r.fromSerializedTx(t, n);
          throw new Error(`TypedTransaction with ID ${t[0]} unknown`);
        }
      }
    else return Hi.fromSerializedTx(t, n);
  }
  static fromBlockBodyData(t, n = {}) {
    if (t instanceof Uint8Array) return this.fromSerializedData(t, n);
    if (Array.isArray(t)) return Hi.fromValuesArray(t, n);
    throw new Error("Cannot decode transaction: unknown type input");
  }
}
var Sp = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const Wa = (e, t) => {
    let n;
    if (!t && typeof e == "string" && De(e) && e.length !== 66) throw new m_();
    try {
      n = e instanceof Uint8Array ? e : Nr(e);
    } catch {
      throw new vj();
    }
    if (!t && n.byteLength !== 32) throw new m_();
    return n;
  },
  cw = (e) => {
    const t = De(e) ? e : yr(e),
      n = He(t),
      r = He(
        j3(`Ethereum Signed Message:
${n.byteLength}`)
      ),
      i = an(r, n);
    return On(i);
  },
  qT = (e, t) => {
    const n = Wa(t),
      r = cw(e),
      i = bi.sign(r.substring(2), n),
      s = i.toCompactRawBytes(),
      o = i.r.toString(16).padStart(64, "0"),
      a = i.s.toString(16).padStart(64, "0"),
      u = i.recovery + 27;
    return {
      message: e,
      messageHash: r,
      v: kn(u),
      r: `0x${o}`,
      s: `0x${a}`,
      signature: `${ve(s)}${u.toString(16)}`,
    };
  },
  Az = (e, t) =>
    Sp(void 0, void 0, void 0, function* () {
      const n = e.sign(He(t));
      if (M(n.v) || M(n.r) || M(n.s)) throw new tg("Signer Error");
      const r = n.validate(!0);
      if (r.length > 0) {
        let o = "Signer Error ";
        for (const a of r) o += `${o} ${a}.`;
        throw new tg(o);
      }
      const i = ve(n.serialize()),
        s = On(i);
      return {
        messageHash: ve(n.getMessageToSign(!0)),
        v: `0x${n.v.toString(16)}`,
        r: `0x${n.r.toString(16).padStart(64, "0")}`,
        s: `0x${n.s.toString(16).padStart(64, "0")}`,
        rawTransaction: i,
        transactionHash: ve(s),
      };
    }),
  xz = (e) => {
    if (M(e)) throw new Nj();
    const t = lo.fromSerializedData(He(e));
    return Lr(t.getSenderAddress().toString());
  },
  Eg = (e, t, n, r, i) => {
    if (typeof e == "object") {
      const d = `${e.r}${e.s.slice(2)}${e.v.slice(2)}`;
      return Eg(e.messageHash, d, n);
    }
    if (typeof t == "string" && typeof n == "string" && !M(r)) {
      const d = `${n}${r.slice(2)}${t.slice(2)}`;
      return Eg(e, d, i);
    }
    if (M(t)) throw new bj("signature string undefined");
    const s = 130,
      o = n ? e : cw(e);
    let a = parseInt(t.substring(s), 16);
    a > 26 && (a -= 27);
    const u = bi.Signature.fromCompact(t.slice(2, s))
        .addRecoveryBit(a)
        .recoverPublicKey(o.replace("0x", ""))
        .toRawBytes(!1),
      l = On(u.subarray(1));
    return Lr(`0x${l.slice(-40)}`);
  },
  Cp = (e) => {
    const t = Wa(e),
      n = bi.getPublicKey(t, !1),
      i = On(n.slice(1)).slice(-40);
    return Lr(`0x${i}`);
  },
  Sz = (e, t) => {
    const n = Wa(e);
    return `0x${ve(bi.getPublicKey(n, t)).slice(4)}`;
  },
  WT = (e, t, n) =>
    Sp(void 0, void 0, void 0, function* () {
      var r, i, s, o, a, u, l;
      const c = Wa(e);
      let d;
      if (
        (n != null && n.salt
          ? (d = typeof n.salt == "string" ? He(n.salt) : n.salt)
          : (d = Gc(32)),
        !(Ob(t) || t instanceof Uint8Array))
      )
        throw new _j();
      const f = typeof t == "string" ? He(yr(t)) : t;
      let p;
      if (n != null && n.iv) {
        if (((p = typeof n.iv == "string" ? He(n.iv) : n.iv), p.length !== 16))
          throw new Aj();
      } else p = Gc(16);
      const m =
        (r = n == null ? void 0 : n.kdf) !== null && r !== void 0
          ? r
          : "scrypt";
      let g, w;
      if (m === "pbkdf2") {
        if (
          ((w = {
            dklen:
              (i = n == null ? void 0 : n.dklen) !== null && i !== void 0
                ? i
                : 32,
            salt: ve(d).replace("0x", ""),
            c:
              (s = n == null ? void 0 : n.c) !== null && s !== void 0
                ? s
                : 262144,
            prf: "hmac-sha256",
          }),
          w.c < 1e3)
        )
          throw new xj();
        g = _T(f, d, w.c, w.dklen, "sha256");
      } else if (m === "scrypt")
        (w = {
          n: (o = n == null ? void 0 : n.n) !== null && o !== void 0 ? o : 8192,
          r: (a = n == null ? void 0 : n.r) !== null && a !== void 0 ? a : 8,
          p: (u = n == null ? void 0 : n.p) !== null && u !== void 0 ? u : 1,
          dklen:
            (l = n == null ? void 0 : n.dklen) !== null && l !== void 0
              ? l
              : 32,
          salt: ve(d).replace("0x", ""),
        }),
          (g = AT(f, d, w.n, w.p, w.r, w.dklen));
      else throw new r3();
      const v = yield Yb(c, g.slice(0, 16), p, "aes-128-ctr"),
        y = ve(v).slice(2),
        b = On(an(g.slice(16, 32), v)).replace("0x", "");
      return {
        version: 3,
        id: Qb(),
        address: Cp(c).toLowerCase().replace("0x", ""),
        crypto: {
          ciphertext: y,
          cipherparams: { iv: ve(p).replace("0x", "") },
          cipher: "aes-128-ctr",
          kdf: m,
          kdfparams: w,
          mac: b,
        },
      };
    }),
  lw = (e, t) => {
    const n = Wa(e, t);
    return {
      address: Cp(n),
      privateKey: ve(n),
      signTransaction: (r) => {
        throw new tg("Do not have network access to sign the transaction");
      },
      sign: (r) => qT(typeof r == "string" ? r : JSON.stringify(r), n),
      encrypt: (r, i) =>
        Sp(void 0, void 0, void 0, function* () {
          return WT(n, r, i);
        }),
    };
  },
  Cz = () => {
    const e = bi.utils.randomPrivateKey();
    return lw(`${ve(e)}`);
  },
  Tz = (e, t, n) =>
    Sp(void 0, void 0, void 0, function* () {
      const r = typeof e == "object" ? e : JSON.parse(n ? e.toLowerCase() : e);
      if ((ie.validateJSONSchema(m7, r), r.version !== 3)) throw new Ej();
      const i = typeof t == "string" ? He(yr(t)) : t;
      ie.validate(["bytes"], [i]);
      let s;
      if (r.crypto.kdf === "scrypt") {
        const l = r.crypto.kdfparams,
          c = typeof l.salt == "string" ? He(l.salt) : l.salt;
        s = AT(i, c, l.n, l.p, l.r, l.dklen);
      } else if (r.crypto.kdf === "pbkdf2") {
        const l = r.crypto.kdfparams,
          c = typeof l.salt == "string" ? He(l.salt) : l.salt;
        s = _T(i, c, l.c, l.dklen, "sha256");
      } else throw new r3();
      const o = He(r.crypto.ciphertext);
      if (On(an(s.slice(16, 32), o)).replace("0x", "") !== r.crypto.mac)
        throw new wj();
      const u = yield gH(
        He(r.crypto.ciphertext),
        s.slice(0, 16),
        He(r.crypto.cipherparams.iv)
      );
      return lw(u);
    });
var e2 = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const Iz = 1e3;
class kz {
  constructor(t) {
    (this._requestManager = t), (this._requests = new Map());
  }
  get requests() {
    return [...this._requests.values()].map((t) => t.payload);
  }
  add(t) {
    const n = uo(t),
      r = new nh();
    return this._requests.set(n.id, { payload: n, promise: r }), r;
  }
  execute(t) {
    var n;
    return e2(this, void 0, void 0, function* () {
      if (this.requests.length === 0) return Promise.resolve([]);
      const r = new nh({
        timeout:
          (n = t == null ? void 0 : t.timeout) !== null && n !== void 0
            ? n
            : Iz,
        eagerStart: !0,
        timeoutMessage: "Batch request timeout",
      });
      return (
        this._processBatchRequest(r).catch((i) => r.reject(i)),
        r.catch((i) => {
          i instanceof i3 && this._abortAllRequests("Batch request timeout"),
            r.reject(i);
        }),
        r
      );
    });
  }
  _processBatchRequest(t) {
    var n, r;
    return e2(this, void 0, void 0, function* () {
      const i = yield this._requestManager.sendBatch(
        [...this._requests.values()].map((a) => a.payload)
      );
      if (i.length !== this._requests.size)
        throw (
          (this._abortAllRequests("Invalid batch response"),
          new Kr(
            i,
            `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${i.length}`
          ))
        );
      const s = this.requests
          .map((a) => a.id)
          .map(Number)
          .sort((a, u) => a - u),
        o = i
          .map((a) => a.id)
          .map(Number)
          .sort((a, u) => a - u);
      if (JSON.stringify(s) !== JSON.stringify(o))
        throw (
          (this._abortAllRequests("Invalid batch response"),
          new Kr(
            i,
            `Batch request mismatch the results. Requests: [${s.join()}], Responses: [${o.join()}]`
          ))
        );
      for (const a of i)
        ei(a)
          ? (n = this._requests.get(a.id)) === null ||
            n === void 0 ||
            n.promise.resolve(a.result)
          : ti(a) &&
            ((r = this._requests.get(a.id)) === null ||
              r === void 0 ||
              r.promise.reject(a.error));
      t.resolve(i);
    });
  }
  _abortAllRequests(t) {
    for (const { promise: n } of this._requests.values()) n.reject(new Dj(t));
  }
}
var Pz = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class gn extends cH {
  constructor(t) {
    var n;
    if (
      (super(),
      (this.providers = qs.providers),
      ce(t) || (typeof t == "string" && t.trim() !== "") || rh(t))
    ) {
      (this._requestManager = new qs(t)),
        (this._subscriptionManager = new dg(this._requestManager, {}));
      return;
    }
    const {
      config: r,
      provider: i,
      requestManager: s,
      subscriptionManager: o,
      registeredSubscriptions: a,
      accountProvider: u,
      wallet: l,
    } = t;
    this.setConfig(r ?? {}),
      (this._requestManager =
        s ??
        new qs(
          i,
          (n = r == null ? void 0 : r.enableExperimentalFeatures) === null ||
          n === void 0
            ? void 0
            : n.useSubscriptionWhenCheckingBlockTimeout
        )),
      o
        ? (this._subscriptionManager = o)
        : (this._subscriptionManager = new dg(this.requestManager, a ?? {})),
      u && (this._accountProvider = u),
      l && (this._wallet = l);
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...t) {
    return new this(...t.reverse());
  }
  getContextObject() {
    var t;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions:
        (t = this.subscriptionManager) === null || t === void 0
          ? void 0
          : t.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider,
    };
  }
  use(t, ...n) {
    const r = new t(...n, this.getContextObject());
    return (
      this.on(co.CONFIG_CHANGE, (i) => {
        r.setConfig({ [i.name]: i.newValue });
      }),
      r
    );
  }
  link(t) {
    this.setConfig(t.config),
      (this._requestManager = t.requestManager),
      (this.provider = t.provider),
      (this._subscriptionManager = t.subscriptionManager),
      (this._wallet = t.wallet),
      (this._accountProvider = t._accountProvider),
      t.on(co.CONFIG_CHANGE, (n) => {
        this.setConfig({ [n.name]: n.newValue });
      });
  }
  registerPlugin(t) {
    if (this[t.pluginNamespace] !== void 0) throw new Oj(t.pluginNamespace);
    const n = { [t.pluginNamespace]: t };
    n[t.pluginNamespace].link(this), Object.assign(this, n);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(t) {
    this.requestManager.setProvider(t);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(t) {
    this.requestManager.setProvider(t);
  }
  get givenProvider() {
    return gn.givenProvider;
  }
  setProvider(t) {
    return (this.provider = t), !0;
  }
  get BatchRequest() {
    return kz.bind(void 0, this._requestManager);
  }
  extend(t) {
    var n;
    return (
      t.property && !this[t.property] && (this[t.property] = {}),
      (n = t.methods) === null ||
        n === void 0 ||
        n.forEach((r) => {
          const i = (...s) =>
            Pz(this, void 0, void 0, function* () {
              return this.requestManager.send({ method: r.call, params: s });
            });
          t.property ? (this[t.property][r.name] = i) : (this[r.name] = i);
        }),
      this
    );
  }
}
gn.providers = qs.providers;
class at {
  constructor(t) {
    if (
      ((this.toAddress = () => {
        if (this.isDirect()) {
          const n = this._iban.slice(4),
            r = at._parseInt(n, 36),
            i = Hc(r, 40);
          return Lr(i);
        }
        throw new Error(
          "Iban is indirect and cannot be converted. Must be length of 34 or 35"
        );
      }),
      at.isIndirect(t) || at.isDirect(t))
    )
      this._iban = t;
    else throw new Error("Invalid IBAN was provided");
  }
  static isDirect(t) {
    return t.length === 34 || t.length === 35;
  }
  isDirect() {
    return at.isDirect(this._iban);
  }
  static isIndirect(t) {
    return t.length === 20;
  }
  isIndirect() {
    return at.isIndirect(this._iban);
  }
  static isValid(t) {
    return (
      /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(t) &&
      at._mod9710(at._iso13616Prepare(t)) === 1
    );
  }
  isValid() {
    return at.isValid(this._iban);
  }
  static fromBban(t) {
    const n = "XE",
      i = `0${(
        98 - this._mod9710(this._iso13616Prepare(`${n}00${t}`))
      ).toString()}`.slice(-2);
    return new at(`${n}${i}${t}`);
  }
  static createIndirect(t) {
    return at.fromBban(`ETH${t.institution}${t.identifier}`);
  }
  static fromAddress(t) {
    if (!er(t)) throw new kb(t);
    const r = BigInt(bl(t)).toString(36),
      i = Hc(r, 15);
    return at.fromBban(i.toUpperCase());
  }
  static toIban(t) {
    return at.fromAddress(t).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
}
at._iso13616Prepare = (e) => {
  const r = e.toUpperCase();
  return `${r.slice(4)}${r.slice(0, 4)}`
    .split("")
    .map((s) => {
      const o = s.charCodeAt(0);
      return o >= 65 && o <= 90 ? o - 65 + 10 : s;
    })
    .join("");
};
at._parseInt = (e, t) =>
  [...e].reduce((n, r) => BigInt(parseInt(r, t)) + BigInt(t) * n, BigInt(0));
at._mod9710 = (e) => {
  let t = e,
    n;
  for (; t.length > 2; )
    (n = t.slice(0, 9)),
      (t = `${(parseInt(n, 10) % 97).toString()}${t.slice(n.length)}`);
  return parseInt(t, 10) % 97;
};
at.toAddress = (e) => new at(e).toAddress();
var Ym = function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(c) {
        try {
          l(r.next(c));
        } catch (d) {
          o(d);
        }
      }
      function u(c) {
        try {
          l(r.throw(c));
        } catch (d) {
          o(d);
        }
      }
      function l(c) {
        c.done ? s(c.value) : i(c.value).then(a, u);
      }
      l((r = r.apply(e, t || [])).next());
    });
  },
  QT;
class VT extends wp {
  constructor(t) {
    super(), (this[QT] = "Promise"), (this._promise = new Promise(t));
  }
  then(t, n) {
    return Ym(this, void 0, void 0, function* () {
      return this._promise.then(t, n);
    });
  }
  catch(t) {
    return Ym(this, void 0, void 0, function* () {
      return this._promise.catch(t);
    });
  }
  finally(t) {
    return Ym(this, void 0, void 0, function* () {
      return this._promise.finally(t);
    });
  }
  on(t, n) {
    return super.on(t, n), this;
  }
  once(t, n) {
    return super.once(t, n), this;
  }
}
QT = Symbol.toStringTag;
(function (e, t) {
  if (e.setImmediate) return;
  var n = 1,
    r = {},
    i = !1,
    s = e.document,
    o;
  function a(y) {
    typeof y != "function" && (y = new Function("" + y));
    for (var b = new Array(arguments.length - 1), _ = 0; _ < b.length; _++)
      b[_] = arguments[_ + 1];
    var A = { callback: y, args: b };
    return (r[n] = A), o(n), n++;
  }
  function u(y) {
    delete r[y];
  }
  function l(y) {
    var b = y.callback,
      _ = y.args;
    switch (_.length) {
      case 0:
        b();
        break;
      case 1:
        b(_[0]);
        break;
      case 2:
        b(_[0], _[1]);
        break;
      case 3:
        b(_[0], _[1], _[2]);
        break;
      default:
        b.apply(t, _);
        break;
    }
  }
  function c(y) {
    if (i) setTimeout(c, 0, y);
    else {
      var b = r[y];
      if (b) {
        i = !0;
        try {
          l(b);
        } finally {
          u(y), (i = !1);
        }
      }
    }
  }
  function d() {
    o = function (y) {
      process.nextTick(function () {
        c(y);
      });
    };
  }
  function f() {
    if (e.postMessage && !e.importScripts) {
      var y = !0,
        b = e.onmessage;
      return (
        (e.onmessage = function () {
          y = !1;
        }),
        e.postMessage("", "*"),
        (e.onmessage = b),
        y
      );
    }
  }
  function p() {
    var y = "setImmediate$" + Math.random() + "$",
      b = function (_) {
        _.source === e &&
          typeof _.data == "string" &&
          _.data.indexOf(y) === 0 &&
          c(+_.data.slice(y.length));
      };
    e.addEventListener
      ? e.addEventListener("message", b, !1)
      : e.attachEvent("onmessage", b),
      (o = function (_) {
        e.postMessage(y + _, "*");
      });
  }
  function m() {
    var y = new MessageChannel();
    (y.port1.onmessage = function (b) {
      var _ = b.data;
      c(_);
    }),
      (o = function (b) {
        y.port2.postMessage(b);
      });
  }
  function g() {
    var y = s.documentElement;
    o = function (b) {
      var _ = s.createElement("script");
      (_.onreadystatechange = function () {
        c(b), (_.onreadystatechange = null), y.removeChild(_), (_ = null);
      }),
        y.appendChild(_);
    };
  }
  function w() {
    o = function (y) {
      setTimeout(c, 0, y);
    };
  }
  var v = Object.getPrototypeOf && Object.getPrototypeOf(e);
  (v = v && v.setTimeout ? v : e),
    {}.toString.call(e.process) === "[object process]"
      ? d()
      : f()
      ? p()
      : e.MessageChannel
      ? m()
      : s && "onreadystatechange" in s.createElement("script")
      ? g()
      : w(),
    (v.setImmediate = a),
    (v.clearImmediate = u);
})(typeof self > "u" ? Cu : self);
var me = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function Dz(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_protocolVersion", params: [] });
  });
}
function KT(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_syncing", params: [] });
  });
}
function Oz(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_coinbase", params: [] });
  });
}
function Rz(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_mining", params: [] });
  });
}
function Bz(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_hashrate", params: [] });
  });
}
function Nz(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_gasPrice", params: [] });
  });
}
function Mz(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_accounts", params: [] });
  });
}
function Lz(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_blockNumber", params: [] });
  });
}
function Fz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["address", "blockNumberOrTag"], [t, n]),
      e.send({ method: "eth_getBalance", params: [t, n] })
    );
  });
}
function jz(e, t, n, r) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["address", "hex", "blockNumberOrTag"], [t, n, r]),
      e.send({ method: "eth_getStorageAt", params: [t, n, r] })
    );
  });
}
function Uz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["address", "blockNumberOrTag"], [t, n]),
      e.send({ method: "eth_getTransactionCount", params: [t, n] })
    );
  });
}
function $z(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes32"], [t]),
      e.send({ method: "eth_getBlockTransactionCountByHash", params: [t] })
    );
  });
}
function Hz(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag"], [t]),
      e.send({ method: "eth_getBlockTransactionCountByNumber", params: [t] })
    );
  });
}
function zz(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes32"], [t]),
      e.send({ method: "eth_getUncleCountByBlockHash", params: [t] })
    );
  });
}
function Gz(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag"], [t]),
      e.send({ method: "eth_getUncleCountByBlockNumber", params: [t] })
    );
  });
}
function qz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["address", "blockNumberOrTag"], [t, n]),
      e.send({ method: "eth_getCode", params: [t, n] })
    );
  });
}
function Wz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["address", "hex"], [t, n]),
      e.send({ method: "eth_sign", params: [t, n] })
    );
  });
}
function Qz(e, t) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_signTransaction", params: [t] });
  });
}
function Vz(e, t) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_sendTransaction", params: [t] });
  });
}
function ZT(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["hex"], [t]),
      e.send({ method: "eth_sendRawTransaction", params: [t] })
    );
  });
}
function Kz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag"], [n]),
      e.send({ method: "eth_call", params: [t, n] })
    );
  });
}
function Zz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag"], [n]),
      e.send({ method: "eth_estimateGas", params: [t, n] })
    );
  });
}
function Jz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes32", "bool"], [t, n]),
      e.send({ method: "eth_getBlockByHash", params: [t, n] })
    );
  });
}
function JT(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag", "bool"], [t, n]),
      e.send({ method: "eth_getBlockByNumber", params: [t, n] })
    );
  });
}
function Yz(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes32"], [t]),
      e.send({ method: "eth_getTransactionByHash", params: [t] })
    );
  });
}
function Xz(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes32", "hex"], [t, n]),
      e.send({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [t, n],
      })
    );
  });
}
function eG(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag", "hex"], [t, n]),
      e.send({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [t, n],
      })
    );
  });
}
function tG(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes32"], [t]),
      e.send({ method: "eth_getTransactionReceipt", params: [t] })
    );
  });
}
function nG(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes32", "hex"], [t, n]),
      e.send({ method: "eth_getUncleByBlockHashAndIndex", params: [t, n] })
    );
  });
}
function rG(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag", "hex"], [t, n]),
      e.send({ method: "eth_getUncleByBlockNumberAndIndex", params: [t, n] })
    );
  });
}
function iG(e, t) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["filter"], [t]),
      e.send({ method: "eth_getLogs", params: [t] })
    );
  });
}
function sG(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_getWork", params: [] });
  });
}
function oG(e, t, n, r) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["bytes8", "bytes32", "bytes32"], [t, n, r]),
      e.send({ method: "eth_submitWork", params: [t, n, r] })
    );
  });
}
function aG(e, t, n, r) {
  return me(this, void 0, void 0, function* () {
    ie.validate(["hex", "blockNumberOrTag"], [t, n]);
    for (const i of r) ie.validate(["number"], [i]);
    return e.send({ method: "eth_feeHistory", params: [t, n, r] });
  });
}
function uG(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_pendingTransactions", params: [] });
  });
}
function cG(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_requestAccounts", params: [] });
  });
}
function lG(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "eth_chainId", params: [] });
  });
}
function dG(e, t, n, r) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["address", "bytes32[]", "blockNumberOrTag"], [t, n, r]),
      e.send({ method: "eth_getProof", params: [t, n, r] })
    );
  });
}
function fG(e) {
  return me(this, void 0, void 0, function* () {
    return e.send({ method: "web3_clientVersion", params: [] });
  });
}
function hG(e, t, n) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["blockNumberOrTag"], [n]),
      e.send({ method: "eth_createAccessList", params: [t, n] })
    );
  });
}
function pG(e, t, n, r = !1) {
  return me(this, void 0, void 0, function* () {
    return (
      ie.validate(["address"], [t]),
      e.send({ method: `eth_signTypedData${r ? "" : "_v4"}`, params: [t, n] })
    );
  });
}
var dw = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function mG(e) {
  return dw(this, void 0, void 0, function* () {
    return e.send({ method: "net_version", params: [] });
  });
}
function yG(e) {
  return dw(this, void 0, void 0, function* () {
    return e.send({ method: "net_peerCount", params: [] });
  });
}
function gG(e) {
  return dw(this, void 0, void 0, function* () {
    return e.send({ method: "net_listening", params: [] });
  });
}
var wi = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const vG = (e) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_listAccounts", params: [] });
    }),
  bG = (e, t) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_newAccount", params: [t] });
    }),
  wG = (e, t, n, r) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_unlockAccount", params: [t, n, r] });
    }),
  EG = (e, t) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_lockAccount", params: [t] });
    }),
  _G = (e, t, n) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_importRawKey", params: [t, n] });
    }),
  AG = (e, t, n) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_sendTransaction", params: [t, n] });
    }),
  xG = (e, t, n) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_signTransaction", params: [t, n] });
    }),
  SG = (e, t, n, r) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_sign", params: [t, n, r] });
    }),
  CG = (e, t, n) =>
    wi(void 0, void 0, void 0, function* () {
      return e.send({ method: "personal_ecRecover", params: [t, n] });
    }),
  t2 = {
    type: "object",
    properties: {
      accessList: { type: "null" },
      maxFeePerGas: { type: "null" },
      maxPriorityFeePerGas: { type: "null" },
    },
  },
  n2 = {
    type: "object",
    properties: {
      maxFeePerGas: { type: "null" },
      maxPriorityFeePerGas: { type: "null" },
    },
  },
  r2 = { type: "object", properties: { gasPrice: { type: "null" } } },
  td = (e, t, n) => {
    try {
      ie.validateJSONSchema(e, t);
    } catch (r) {
      throw r instanceof Aa ? new oU(r.errors, n) : r;
    }
  },
  TG = (e) => {
    var t, n;
    const r = e;
    if (!M(r.type)) {
      let s;
      switch (r.type) {
        case "0x0":
          s = t2;
          break;
        case "0x1":
          s = n2;
          break;
        case "0x2":
          s = r2;
          break;
        default:
          return $({ format: "uint" }, r.type, ae);
      }
      return td(s, r, r.type), $({ format: "uint" }, r.type, ae);
    }
    if (!M(r.maxFeePerGas) || !M(r.maxPriorityFeePerGas))
      return td(r2, r, "0x2"), "0x2";
    if (!M(r.accessList)) return td(n2, r, "0x1"), "0x1";
    const i =
      (t = r.hardfork) !== null && t !== void 0
        ? t
        : (n = r.common) === null || n === void 0
        ? void 0
        : n.hardfork;
    if (!M(i)) {
      const s = Object.keys(Hu).indexOf(i);
      if (s >= Object.keys(Hu).indexOf("london"))
        return M(r.gasPrice) ? "0x2" : "0x0";
      if (s === Object.keys(Hu).indexOf("berlin")) return "0x0";
    }
    if (!M(r.gasPrice)) return td(t2, r, "0x0"), "0x0";
  },
  IG = (e, t) => {
    var n;
    return (
      (n = t == null ? void 0 : t.transactionTypeParser) !== null &&
        n !== void 0
        ? n
        : TG
    )(e);
  },
  kG = (e) => (e[0] > 127 ? "0x0" : cs(e[0])),
  PG = {
    type: "object",
    properties: {
      address: { format: "address" },
      storageKeys: { type: "array", items: { format: "bytes32" } },
    },
  },
  fw = { type: "array", items: Object.assign({}, PG) },
  DG = {
    type: "object",
    properties: {
      accessList: Object.assign({}, fw),
      gasUsed: { type: "string" },
    },
  },
  i2 = {
    type: "string",
    enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"],
  },
  s2 = {
    type: "string",
    enum: [
      "arrowGlacier",
      "berlin",
      "byzantium",
      "chainstart",
      "constantinople",
      "dao",
      "homestead",
      "istanbul",
      "london",
      "merge",
      "muirGlacier",
      "petersburg",
      "shanghai",
      "spuriousDragon",
      "tangerineWhistle",
    ],
  },
  OG = {
    type: "object",
    properties: {
      name: { format: "string" },
      networkId: { format: "uint" },
      chainId: { format: "uint" },
    },
  },
  YT = {
    type: "object",
    properties: {
      from: { format: "address" },
      to: { oneOf: [{ format: "address" }, { type: "null" }] },
      value: { format: "uint" },
      gas: { format: "uint" },
      gasPrice: { format: "uint" },
      effectiveGasPrice: { format: "uint" },
      type: { format: "uint" },
      maxFeePerGas: { format: "uint" },
      maxPriorityFeePerGas: { format: "uint" },
      accessList: Object.assign({}, fw),
      data: { format: "bytes" },
      input: { format: "bytes" },
      nonce: { format: "uint" },
      chain: Object.assign({}, i2),
      hardfork: Object.assign({}, s2),
      chainId: { format: "uint" },
      networkId: { format: "uint" },
      common: {
        type: "object",
        properties: {
          customChain: Object.assign({}, OG),
          baseChain: Object.assign({}, i2),
          hardfork: Object.assign({}, s2),
        },
      },
      gasLimit: { format: "uint" },
      v: { format: "uint" },
      r: { format: "bytes32" },
      s: { format: "bytes32" },
    },
  },
  _g = {
    type: "object",
    properties: Object.assign(Object.assign({}, YT.properties), {
      blockHash: { format: "bytes32" },
      blockNumber: { format: "uint" },
      hash: { format: "bytes32" },
      transactionIndex: { format: "uint" },
      from: { format: "address" },
      to: { oneOf: [{ format: "address" }, { type: "null" }] },
      value: { format: "uint" },
      gas: { format: "uint" },
      gasPrice: { format: "uint" },
      effectiveGasPrice: { format: "uint" },
      type: { format: "uint" },
      maxFeePerGas: { format: "uint" },
      maxPriorityFeePerGas: { format: "uint" },
      accessList: Object.assign({}, fw),
      data: { format: "bytes" },
      input: { format: "bytes" },
      nonce: { format: "uint" },
      gasLimit: { format: "uint" },
      v: { format: "uint" },
      r: { format: "bytes32" },
      s: { format: "bytes32" },
    }),
  },
  uh = {
    type: "object",
    properties: {
      parentHash: { format: "bytes32" },
      sha3Uncles: { format: "bytes32" },
      miner: { format: "bytes" },
      stateRoot: { format: "bytes32" },
      transactionsRoot: { format: "bytes32" },
      receiptsRoot: { format: "bytes32" },
      logsBloom: { format: "bytes256" },
      difficulty: { format: "uint" },
      number: { format: "uint" },
      gasLimit: { format: "uint" },
      gasUsed: { format: "uint" },
      timestamp: { format: "uint" },
      extraData: { format: "bytes" },
      mixHash: { format: "bytes32" },
      nonce: { format: "uint" },
      totalDifficulty: { format: "uint" },
      baseFeePerGas: { format: "uint" },
      size: { format: "uint" },
      transactions: {
        oneOf: [
          { type: "array", items: Object.assign({}, _g) },
          { type: "array", items: { format: "bytes32" } },
        ],
      },
      uncles: { type: "array", items: { format: "bytes32" } },
      hash: { format: "bytes32" },
    },
  },
  RG = {
    type: "object",
    properties: {
      index: { format: "uint" },
      validatorIndex: { format: "uint" },
      address: { format: "address" },
      amount: { format: "uint" },
    },
  },
  BG = {
    type: "object",
    properties: {
      author: { format: "bytes32" },
      hash: { format: "bytes32" },
      parentHash: { format: "bytes32" },
      receiptsRoot: { format: "bytes32" },
      miner: { format: "bytes" },
      stateRoot: { format: "bytes32" },
      transactionsRoot: { format: "bytes32" },
      withdrawalsRoot: { format: "bytes32" },
      logsBloom: { format: "bytes256" },
      difficulty: { format: "uint" },
      totalDifficulty: { format: "uint" },
      number: { format: "uint" },
      gasLimit: { format: "uint" },
      gasUsed: { format: "uint" },
      timestamp: { format: "uint" },
      extraData: { format: "bytes" },
      nonce: { format: "uint" },
      sha3Uncles: { format: "bytes32" },
      size: { format: "uint" },
      baseFeePerGas: { format: "uint" },
      excessDataGas: { format: "uint" },
      mixHash: { format: "bytes32" },
      transactions: { type: "array", items: { format: "bytes32" } },
      uncles: { type: "array", items: { format: "bytes32" } },
      withdrawals: { type: "array", items: Object.assign({}, RG) },
    },
  },
  Tp = {
    type: "object",
    properties: {
      removed: { format: "bool" },
      logIndex: { format: "uint" },
      transactionIndex: { format: "uint" },
      transactionHash: { format: "bytes32" },
      blockHash: { format: "bytes32" },
      blockNumber: { format: "uint" },
      address: { format: "address" },
      data: { format: "bytes" },
      topics: { type: "array", items: { format: "bytes32" } },
    },
  },
  NG = {
    type: "object",
    properties: {
      startingBlock: { format: "string" },
      currentBlock: { format: "string" },
      highestBlock: { format: "string" },
      knownStates: { format: "string" },
      pulledStates: { format: "string" },
    },
  },
  Qa = {
    type: "object",
    properties: {
      transactionHash: { format: "bytes32" },
      transactionIndex: { format: "uint" },
      blockHash: { format: "bytes32" },
      blockNumber: { format: "uint" },
      from: { format: "address" },
      to: { format: "address" },
      cumulativeGasUsed: { format: "uint" },
      gasUsed: { format: "uint" },
      effectiveGasPrice: { format: "uint" },
      contractAddress: { format: "address" },
      logs: { type: "array", items: Object.assign({}, Tp) },
      logsBloom: { format: "bytes" },
      root: { format: "bytes" },
      status: { format: "uint" },
      type: { format: "uint" },
    },
  },
  MG = {
    type: "object",
    properties: {
      messageHash: { format: "bytes" },
      r: { format: "bytes32" },
      s: { format: "bytes32" },
      v: { format: "bytes" },
      message: { format: "bytes" },
      signature: { format: "bytes" },
    },
  },
  LG = {
    type: "object",
    properties: {
      oldestBlock: { format: "uint" },
      baseFeePerGas: { type: "array", items: { format: "uint" } },
      reward: {
        type: "array",
        items: { type: "array", items: { format: "uint" } },
      },
      gasUsedRatio: { type: "array", items: { type: "number" } },
    },
  },
  FG = {
    type: "object",
    properties: {
      key: { format: "bytes32" },
      value: { format: "uint" },
      proof: { type: "array", items: { format: "bytes32" } },
    },
  },
  jG = {
    type: "object",
    properties: {
      balance: { format: "uint" },
      codeHash: { format: "bytes32" },
      nonce: { format: "uint" },
      storageHash: { format: "bytes32" },
      accountProof: { type: "array", items: { format: "bytes32" } },
      storageProof: { type: "array", items: Object.assign({}, FG) },
    },
  };
function _n(e, t = Y, n = { transactionSchema: _g, fillInputAndData: !1 }) {
  var r, i;
  let s = ws({}, e);
  if (
    (M(e == null ? void 0 : e.common) ||
      ((s.common = Object.assign({}, e.common)),
      M((r = e.common) === null || r === void 0 ? void 0 : r.customChain) ||
        (s.common.customChain = Object.assign({}, e.common.customChain))),
    (s = $((i = n.transactionSchema) !== null && i !== void 0 ? i : _g, s, t)),
    !M(s.data) && !M(s.input) && cs(s.data) !== cs(s.input))
  )
    throw new u3({ data: ve(s.data), input: ve(s.input) });
  return (
    n.fillInputAndData &&
      (M(s.data) ? M(s.input) || (s.data = s.input) : (s.input = s.data)),
    M(s.gasLimit) || ((s.gas = s.gasLimit), delete s.gasLimit),
    s
  );
}
function UG(e, t, n = { fillInputAndData: !1 }) {
  return {
    raw: $({ format: "bytes" }, e, t),
    tx: _n(
      Object.assign(Object.assign({}, lo.fromSerializedData(He(e)).toJSON()), {
        hash: ve(zc(He(e))),
        type: kG(He(e)),
      }),
      t,
      { fillInputAndData: n.fillInputAndData }
    ),
  };
}
var hw = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function pw(e, t) {
  return hw(this, void 0, void 0, function* () {
    const n = yield mG(e.requestManager);
    return $({ format: "uint" }, n, t);
  });
}
function $G(e, t) {
  return hw(this, void 0, void 0, function* () {
    const n = yield yG(e.requestManager);
    return $({ format: "uint" }, n, t);
  });
}
const HG = (e) =>
  hw(void 0, void 0, void 0, function* () {
    return gG(e.requestManager);
  });
var Xm = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class XT extends gn {
  getId(t = Y) {
    return Xm(this, void 0, void 0, function* () {
      return pw(this, t);
    });
  }
  getPeerCount(t = Y) {
    return Xm(this, void 0, void 0, function* () {
      return $G(this, t);
    });
  }
  isListening() {
    return Xm(this, void 0, void 0, function* () {
      return HG(this);
    });
  }
}
const ka = "ALLEVENTS",
  Ag = { name: ka, signature: "", type: "event", inputs: [] },
  Ip = { bytes: mi.HEX, number: Kn.NUMBER };
var eI = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function zG(e, t, n) {
  var r, i, s;
  return eI(this, void 0, void 0, function* () {
    const o = yield DI(t, t.defaultBlock, !1, n);
    if (M(o.baseFeePerGas)) throw new tU();
    if (!M(e.gasPrice)) {
      const a = $({ format: "uint" }, e.gasPrice, n);
      return { maxPriorityFeePerGas: a, maxFeePerGas: a };
    }
    return {
      maxPriorityFeePerGas: $(
        { format: "uint" },
        (r = e.maxPriorityFeePerGas) !== null && r !== void 0
          ? r
          : t.defaultMaxPriorityFeePerGas,
        n
      ),
      maxFeePerGas: $(
        { format: "uint" },
        (i = e.maxFeePerGas) !== null && i !== void 0
          ? i
          : BigInt(o.baseFeePerGas) * BigInt(2) +
              BigInt(
                (s = e.maxPriorityFeePerGas) !== null && s !== void 0
                  ? s
                  : t.defaultMaxPriorityFeePerGas
              ),
        n
      ),
    };
  });
}
function tI(e, t, n) {
  return eI(this, void 0, void 0, function* () {
    const r = nI(e, t);
    if (!M(r)) {
      if (r.startsWith("-")) throw new b_(r);
      if (Number(r) < 0 || Number(r) > 127) throw new b_(r);
      if (M(e.gasPrice) && (r === "0x0" || r === "0x1"))
        return {
          gasPrice: yield PI(t, n),
          maxPriorityFeePerGas: void 0,
          maxFeePerGas: void 0,
        };
      if (r === "0x2")
        return Object.assign({ gasPrice: void 0 }, yield zG(e, t, n));
    }
  });
}
var mw = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const xg = (e, t, n, r) => {
    if (n !== void 0 && e in n && n[e] !== void 0) {
      if (typeof n[e] == "string" && er(n[e])) return n[e];
      if (!De(n[e]) && L3(n[e])) {
        if (t.wallet) {
          const i = t.wallet.get($({ format: "uint" }, n[e], Ip));
          if (!M(i)) return i.address;
          throw new w_();
        }
        throw new w_();
      } else throw e === "from" ? new Mj(n.from) : new Lj(n.to);
    }
    if (e === "from") {
      if (!M(r)) return Cp(r);
      if (!M(t.defaultAccount)) return t.defaultAccount;
    }
  },
  GG = (e, t, n = Y) =>
    mw(void 0, void 0, void 0, function* () {
      if (M(t)) throw new eU();
      return RI(e, t, e.defaultBlock, n);
    }),
  nI = (e, t) => {
    const n = IG(e, t);
    if (!M(n)) return n;
    if (!M(t.defaultTransactionType))
      return $({ format: "uint" }, t.defaultTransactionType, ae);
  };
function qG(e) {
  var t, n;
  return mw(this, void 0, void 0, function* () {
    let r = $(YT, e.transaction, Y);
    if (
      (M(r.from) && (r.from = xg("from", e.web3Context, void 0, e.privateKey)),
      M(r.nonce) && (r.nonce = yield GG(e.web3Context, r.from, ae)),
      M(r.value) && (r.value = "0x0"),
      M(r.data))
    )
      M(r.input)
        ? (r.input = "0x")
        : r.input.startsWith("0x") || (r.input = `0x${r.input}`);
    else {
      if (!M(r.input) && r.data !== r.input)
        throw new u3({ data: ve(r.data), input: ve(r.input) });
      r.data.startsWith("0x") || (r.data = `0x${r.data}`);
    }
    if (M(r.common)) {
      if (e.web3Context.defaultCommon) {
        const i = e.web3Context.defaultCommon,
          s = i.customChain.chainId,
          o = i.customChain.networkId,
          a = i.customChain.name;
        r.common = Object.assign(Object.assign({}, i), {
          customChain: { chainId: s, networkId: o, name: a },
        });
      }
      M(r.chain) && (r.chain = e.web3Context.defaultChain),
        M(r.hardfork) && (r.hardfork = e.web3Context.defaultHardfork);
    }
    if (
      (M(r.chainId) &&
        M(
          (t = r.common) === null || t === void 0
            ? void 0
            : t.customChain.chainId
        ) &&
        (r.chainId = yield NI(e.web3Context, ae)),
      M(r.networkId) &&
        (r.networkId =
          (n = e.web3Context.defaultNetworkId) !== null && n !== void 0
            ? n
            : yield pw(e.web3Context, ae)),
      M(r.gasLimit) && !M(r.gas) && (r.gasLimit = r.gas),
      (r.type = nI(r, e.web3Context)),
      M(r.accessList) &&
        (r.type === "0x1" || r.type === "0x2") &&
        (r.accessList = []),
      e.fillGasPrice &&
        (r = Object.assign(
          Object.assign({}, r),
          yield tI(r, e.web3Context, ae)
        )),
      M(r.gas) && M(r.gasLimit) && e.fillGasLimit)
    ) {
      const i = yield xw(e.web3Context, r, "latest", ae);
      r = Object.assign(Object.assign({}, r), {
        gas: $({ format: "uint" }, i, ae),
      });
    }
    return r;
  });
}
const WG = (e) =>
  mw(void 0, void 0, void 0, function* () {
    var t;
    return (
      (t = e.web3Context.transactionBuilder) !== null && t !== void 0 ? t : qG
    )(Object.assign(Object.assign({}, e), { transaction: e.transaction }));
  });
var yw = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function Sg(e, t, n) {
  const r = e.transactionPollingInterval,
    [i, s] = iT(
      () =>
        yw(this, void 0, void 0, function* () {
          let a;
          try {
            a = yield _w(e, Ip);
          } catch (l) {
            console.warn(
              "An error happen while trying to get the block number",
              l
            );
            return;
          }
          const u = a - t;
          if (u >= e.transactionBlockTimeout)
            return new l3({
              starterBlockNumber: t,
              numberOfBlocks: u,
              transactionHash: n,
            });
        }),
      r
    );
  return [
    s,
    {
      clean: () => {
        clearInterval(i);
      },
    },
  ];
}
function QG(e, t, n) {
  var r;
  return yw(this, void 0, void 0, function* () {
    let i = !0,
      s,
      o;
    function a(l, c) {
      c &&
        console.warn(
          "error happened at subscription. So revert to polling...",
          c
        ),
        o.clean(),
        (i = !1);
      const [d, f] = Sg(e, t, n);
      (o.clean = f.clean), d.catch((p) => l(p));
    }
    try {
      (s = yield (r = e.subscriptionManager) === null || r === void 0
        ? void 0
        : r.subscribe("newHeads")),
        (o = {
          clean: () => {
            var l;
            s.id &&
              ((l = e.subscriptionManager) === null ||
                l === void 0 ||
                l
                  .removeSubscription(s)
                  .then(() => {})
                  .catch(() => {}));
          },
        });
    } catch {
      return Sg(e, t, n);
    }
    return [
      new Promise((l, c) => {
        try {
          s.on("data", (d) => {
            if (((i = !1), !(d != null && d.number))) return;
            const f = Number(BigInt(d.number) - BigInt(t));
            f >= e.transactionBlockTimeout &&
              c(
                new l3({
                  starterBlockNumber: t,
                  numberOfBlocks: f,
                  transactionHash: n,
                })
              );
          }),
            s.on("error", (d) => {
              a(c, d);
            });
        } catch (d) {
          a(c, d);
        }
        setTimeout(() => {
          i && a(c);
        }, e.blockHeaderTimeout * 1e3);
      }),
      o,
    ];
  });
}
function rI(e, t) {
  var n, r;
  return yw(this, void 0, void 0, function* () {
    const { provider: i } = e.requestManager;
    let s;
    const o = yield _w(e, Ip);
    return (
      !((r = (n = i).supportsSubscriptions) === null || r === void 0) &&
      r.call(n) &&
      e.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout
        ? (s = yield QG(e, o, t))
        : (s = Sg(e, o, t)),
      s
    );
  });
}
var VG = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function Cg(e, t, n) {
  return VG(this, void 0, void 0, function* () {
    const [r, i] = Wb(
        e.transactionSendTimeout,
        new nU({
          numberOfSeconds: e.transactionSendTimeout / 1e3,
          transactionHash: n,
        })
      ),
      [s, o] = yield rI(e, n);
    try {
      return yield Promise.race([t(), i, s]);
    } finally {
      clearTimeout(r), o.clean();
    }
  });
}
var o2 = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function iI(e, t, n) {
  var r;
  return o2(this, void 0, void 0, function* () {
    const i =
        (r = e.transactionReceiptPollingInterval) !== null && r !== void 0
          ? r
          : e.transactionPollingInterval,
      [s, o] = qb(
        () =>
          o2(this, void 0, void 0, function* () {
            try {
              return OI(e, t, n);
            } catch (d) {
              console.warn(
                "An error happen while trying to get the transaction receipt",
                d
              );
              return;
            }
          }),
        i
      ),
      [a, u] = Wb(
        e.transactionPollingTimeout,
        new rU({
          numberOfSeconds: e.transactionPollingTimeout / 1e3,
          transactionHash: t,
        })
      ),
      [l, c] = yield rI(e, t);
    try {
      return yield Promise.race([s, u, l]);
    } finally {
      a && clearTimeout(a), o && clearInterval(o), c.clean();
    }
  });
}
var KG = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const Rd = ({
  web3Context: e,
  transactionReceipt: t,
  transactionPromiEvent: n,
  returnFormat: r,
}) => {
  var i;
  let s = 1;
  const o = setInterval(
    () => {
      KG(void 0, void 0, void 0, function* () {
        s >= e.transactionConfirmationBlocks && clearInterval(o);
        const a = yield JT(
          e.requestManager,
          kn(BigInt(t.blockNumber) + BigInt(s)),
          !1
        );
        a != null &&
          a.hash &&
          ((s += 1),
          n.emit("confirmation", {
            confirmations: $({ format: "uint" }, s, r),
            receipt: $(Qa, t, r),
            latestBlockHash: $({ format: "bytes32" }, a.hash, r),
          }));
      });
    },
    (i = e.transactionReceiptPollingInterval) !== null && i !== void 0
      ? i
      : e.transactionPollingInterval
  );
};
var a2 = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const ZG = ({
  web3Context: e,
  transactionReceipt: t,
  transactionPromiEvent: n,
  returnFormat: r,
}) => {
  let i = !0,
    s;
  setImmediate(() => {
    var o;
    (o = e.subscriptionManager) === null ||
      o === void 0 ||
      o
        .subscribe("newHeads")
        .then((a) => {
          a.on("data", (u) =>
            a2(void 0, void 0, void 0, function* () {
              var l;
              if (
                ((i = !1),
                !(u != null && u.number) ||
                  s === (u == null ? void 0 : u.parentHash))
              )
                return;
              s = u == null ? void 0 : u.parentHash;
              const c = BigInt(u.number) - BigInt(t.blockNumber) + BigInt(1);
              n.emit("confirmation", {
                confirmations: $({ format: "uint" }, c, r),
                receipt: $(Qa, t, r),
                latestBlockHash: $({ format: "bytes32" }, u.parentHash, r),
              }),
                c >= e.transactionConfirmationBlocks &&
                  (yield (l = e.subscriptionManager) === null || l === void 0
                    ? void 0
                    : l.removeSubscription(a));
            })
          ),
            a.on("error", () =>
              a2(void 0, void 0, void 0, function* () {
                var u;
                yield (u = e.subscriptionManager) === null || u === void 0
                  ? void 0
                  : u.removeSubscription(a),
                  (i = !1),
                  Rd({
                    web3Context: e,
                    transactionReceipt: t,
                    transactionPromiEvent: n,
                    returnFormat: r,
                  });
              })
            );
        })
        .catch(() => {
          (i = !1),
            Rd({
              web3Context: e,
              transactionReceipt: t,
              transactionPromiEvent: n,
              returnFormat: r,
            });
        });
  }),
    setTimeout(() => {
      i &&
        Rd({
          web3Context: e,
          transactionReceipt: t,
          transactionPromiEvent: n,
          returnFormat: r,
        });
    }, e.blockHeaderTimeout * 1e3);
};
function JG(e, t, n, r, i) {
  if (M(n) || M(n.blockHash))
    throw new iU({
      receipt: n,
      blockHash: $({ format: "bytes32" }, n == null ? void 0 : n.blockHash, i),
      transactionHash: $({ format: "bytes32" }, r, i),
    });
  if (!n.blockNumber) throw new sU({ receipt: n });
  t.emit("confirmation", {
    confirmations: $({ format: "uint" }, 1, i),
    receipt: $(Qa, n, i),
    latestBlockHash: $({ format: "bytes32" }, n.blockHash, i),
  });
  const s = e.requestManager.provider;
  s && "supportsSubscriptions" in s && s.supportsSubscriptions()
    ? ZG({
        web3Context: e,
        transactionReceipt: n,
        transactionPromiEvent: t,
        returnFormat: i,
      })
    : Rd({
        web3Context: e,
        transactionReceipt: n,
        transactionPromiEvent: t,
        returnFormat: i,
      });
}
const kp = (e) =>
    !ce(e) && typeof e == "object" && !ce(e.type) && e.type === "error",
  gw = (e) =>
    !ce(e) && typeof e == "object" && !ce(e.type) && e.type === "event",
  Pp = (e) =>
    !ce(e) && typeof e == "object" && !ce(e.type) && e.type === "function",
  YG = (e) =>
    !ce(e) && typeof e == "object" && !ce(e.type) && e.type === "constructor",
  XG = (e) =>
    typeof e == "object" && typeof e.components > "u" && typeof e.name > "u",
  sI = (e) =>
    e.includes("[]")
      ? { type: "tuple[]", name: e.slice(0, -2) }
      : { type: "tuple", name: e },
  oI = (e) => {
    const t = [];
    for (const n of Object.keys(e)) {
      const r = e[n];
      typeof r == "object"
        ? t.push(Object.assign(Object.assign({}, sI(n)), { components: oI(r) }))
        : t.push({ name: n, type: e[n] });
    }
    return t;
  },
  Tg = (e, t) => {
    const n = [];
    return (
      t.forEach((r) => {
        if (typeof r.components == "object") {
          if (!r.type.startsWith("tuple"))
            throw new Te(
              `Invalid value given "${r.type}". Error: components found but type is not tuple.`
            );
          const i = r.type.indexOf("["),
            s = i >= 0 ? r.type.substring(i) : "",
            o = Tg(e, r.components);
          Array.isArray(o) && e
            ? n.push(`tuple(${o.join(",")})${s}`)
            : e
            ? n.push(`(${o.join()})`)
            : n.push(`(${o.join(",")})${s}`);
        } else n.push(r.type);
      }),
      n
    );
  },
  fo = (e) => {
    var t, n, r, i;
    return kp(e) || gw(e) || Pp(e)
      ? !((t = e.name) === null || t === void 0) && t.includes("(")
        ? e.name
        : `${(n = e.name) !== null && n !== void 0 ? n : ""}(${Tg(
            !1,
            (r = e.inputs) !== null && r !== void 0 ? r : []
          ).join(",")})`
      : `(${Tg(!1, (i = e.inputs) !== null && i !== void 0 ? i : []).join(
          ","
        )})`;
  },
  eq = (e) => {
    if (typeof e != "string" && !kp(e))
      throw new Te("Invalid parameter value in encodeErrorSignature");
    let t;
    return (
      e && (typeof e == "function" || typeof e == "object")
        ? (t = fo(e))
        : (t = e),
      On(t)
    );
  },
  vw = (e) => {
    if (typeof e != "string" && !gw(e))
      throw new Te("Invalid parameter value in encodeEventSignature");
    let t;
    return (
      e && (typeof e == "function" || typeof e == "object")
        ? (t = fo(e))
        : (t = e),
      On(t)
    );
  };
function bw(e, t) {
  const n = e.exec(t);
  return n == null ? void 0 : n.groups;
}
var aI = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
  uI =
    /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
  cI = /^\(.+?\).*?$/,
  tq = Object.defineProperty,
  nq = (e, t, n) =>
    t in e
      ? tq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
      : (e[t] = n),
  fu = (e, t, n) => (nq(e, typeof t != "symbol" ? t + "" : t, n), n),
  rq = "abitype",
  iq = "0.7.1",
  hn = class extends Error {
    constructor(e, t = {}) {
      var s;
      const n =
          t.cause instanceof hn
            ? t.cause.details
            : (s = t.cause) != null && s.message
            ? t.cause.message
            : t.details,
        r = (t.cause instanceof hn && t.cause.docsPath) || t.docsPath,
        i = [
          e || "An error occurred.",
          "",
          ...(t.metaMessages ? [...t.metaMessages, ""] : []),
          ...(r ? [`Docs: https://abitype.dev${r}`] : []),
          ...(n ? [`Details: ${n}`] : []),
          `Version: ${rq}@${iq}`,
        ].join(`
`);
      super(i),
        fu(this, "details"),
        fu(this, "docsPath"),
        fu(this, "metaMessages"),
        fu(this, "shortMessage"),
        fu(this, "name", "AbiTypeError"),
        t.cause && (this.cause = t.cause),
        (this.details = n),
        (this.docsPath = r),
        (this.metaMessages = t.metaMessages),
        (this.shortMessage = e);
    }
  },
  lI = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;
function dI(e) {
  return lI.test(e);
}
function sq(e) {
  return bw(lI, e);
}
var u2 = new Set(["memory", "indexed", "storage", "calldata"]),
  oq = new Set(["calldata", "memory", "storage"]);
function aq(e, t) {
  return t ? `${t}:${e}` : e;
}
var e0 = new Map([
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: !0 },
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: !0 }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: !0 },
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: !0 },
    ],
  ]),
  uq =
    /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
  cq =
    /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
  lq = /^u?int$/;
function ch(e, t) {
  var d, f;
  const n = aq(e, t == null ? void 0 : t.type);
  if (e0.has(n)) return e0.get(n);
  const r = cI.test(e),
    i = bw(r ? cq : uq, e);
  if (!i) throw new hn("Invalid ABI parameter.", { details: e });
  if (i.name && fq(i.name))
    throw new hn("Invalid ABI parameter.", {
      details: e,
      metaMessages: [
        `"${i.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
      ],
    });
  const s = i.name ? { name: i.name } : {},
    o = i.modifier === "indexed" ? { indexed: !0 } : {},
    a = (t == null ? void 0 : t.structs) ?? {};
  let u,
    l = {};
  if (r) {
    u = "tuple";
    const p = Oo(i.type),
      m = [],
      g = p.length;
    for (let w = 0; w < g; w++) m.push(ch(p[w], { structs: a }));
    l = { components: m };
  } else if (i.type in a) (u = "tuple"), (l = { components: a[i.type] });
  else if (lq.test(i.type)) u = `${i.type}256`;
  else if (((u = i.type), (t == null ? void 0 : t.type) !== "struct" && !fI(u)))
    throw new hn("Unknown type.", {
      metaMessages: [`Type "${u}" is not a valid ABI type.`],
    });
  if (i.modifier) {
    if (
      !(
        (f = (d = t == null ? void 0 : t.modifiers) == null ? void 0 : d.has) !=
          null && f.call(d, i.modifier)
      )
    )
      throw new hn("Invalid ABI parameter.", {
        details: e,
        metaMessages: [
          `Modifier "${i.modifier}" not allowed${
            t != null && t.type ? ` in "${t.type}" type` : ""
          }.`,
        ],
      });
    if (oq.has(i.modifier) && !hq(u, !!i.array))
      throw new hn("Invalid ABI parameter.", {
        details: e,
        metaMessages: [
          `Modifier "${i.modifier}" not allowed${
            t != null && t.type ? ` in "${t.type}" type` : ""
          }.`,
          `Data location can only be specified for array, struct, or mapping types, but "${i.modifier}" was given.`,
        ],
      });
  }
  const c = { type: `${u}${i.array ?? ""}`, ...s, ...o, ...l };
  return e0.set(n, c), c;
}
function Oo(e, t = [], n = "", r = 0) {
  if (e === "") {
    if (n === "") return t;
    if (r !== 0)
      throw new hn("Unbalanced parentheses.", {
        metaMessages: [
          `"${n.trim()}" has too many ${
            r > 0 ? "opening" : "closing"
          } parentheses.`,
        ],
        details: `Depth "${r}"`,
      });
    return [...t, n.trim()];
  }
  const i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s],
      a = e.slice(s + 1);
    switch (o) {
      case ",":
        return r === 0 ? Oo(a, [...t, n.trim()]) : Oo(a, t, `${n}${o}`, r);
      case "(":
        return Oo(a, t, `${n}${o}`, r + 1);
      case ")":
        return Oo(a, t, `${n}${o}`, r - 1);
      default:
        return Oo(a, t, `${n}${o}`, r);
    }
  }
  return [];
}
function fI(e) {
  return (
    e === "address" ||
    e === "bool" ||
    e === "function" ||
    e === "string" ||
    aI.test(e) ||
    uI.test(e)
  );
}
var dq =
  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function fq(e) {
  return (
    e === "address" ||
    e === "bool" ||
    e === "function" ||
    e === "string" ||
    e === "tuple" ||
    aI.test(e) ||
    uI.test(e) ||
    dq.test(e)
  );
}
function hq(e, t) {
  return t || e === "bytes" || e === "string" || e === "tuple";
}
function pq(e) {
  const t = {},
    n = e.length;
  for (let o = 0; o < n; o++) {
    const a = e[o];
    if (!dI(a)) continue;
    const u = sq(a);
    if (!u) throw new hn("Invalid struct signature.", { details: a });
    const l = u.properties.split(";"),
      c = [],
      d = l.length;
    for (let f = 0; f < d; f++) {
      const m = l[f].trim();
      if (!m) continue;
      const g = ch(m, { type: "struct" });
      c.push(g);
    }
    if (!c.length)
      throw new hn("Invalid struct signature.", {
        details: a,
        metaMessages: ["No properties exist."],
      });
    t[u.name] = c;
  }
  const r = {},
    i = Object.entries(t),
    s = i.length;
  for (let o = 0; o < s; o++) {
    const [a, u] = i[o];
    r[a] = hI(u, t);
  }
  return r;
}
var mq = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;
function hI(e, t, n = new Set()) {
  const r = [],
    i = e.length;
  for (let s = 0; s < i; s++) {
    const o = e[s];
    if (cI.test(o.type)) r.push(o);
    else {
      const u = bw(mq, o.type);
      if (!(u != null && u.type))
        throw new hn("Invalid ABI parameter.", {
          details: JSON.stringify(o, null, 2),
          metaMessages: ["ABI parameter type is invalid."],
        });
      const { array: l, type: c } = u;
      if (c in t) {
        if (n.has(c))
          throw new hn("Circular reference detected.", {
            metaMessages: [`Struct "${c}" is a circular reference.`],
          });
        r.push({
          ...o,
          type: `tuple${l ?? ""}`,
          components: hI(t[c] ?? [], t, new Set([...n, c])),
        });
      } else if (fI(c)) r.push(o);
      else
        throw new hn("Unknown type.", {
          metaMessages: [
            `Type "${c}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
          ],
        });
    }
  }
  return r;
}
function yq(e) {
  let t;
  if (typeof e == "string") t = ch(e, { modifiers: u2 });
  else {
    const n = pq(e),
      r = e.length;
    for (let i = 0; i < r; i++) {
      const s = e[i];
      if (!dI(s)) {
        t = ch(s, { modifiers: u2, structs: n });
        break;
      }
    }
  }
  if (!t)
    throw new hn("Failed to parse ABI parameter.", {
      details: `parseAbiParameter(${JSON.stringify(e, null, 2)})`,
      docsPath: "/api/human.html#parseabiparameter-1",
    });
  return t;
}
const it = 32;
function Ig(e = 0) {
  var t;
  if (
    ((t = globalThis.Buffer) === null || t === void 0 ? void 0 : t.alloc) !==
    void 0
  ) {
    const n = globalThis.Buffer.alloc(e);
    return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  }
  return new Uint8Array(e);
}
function pI(e) {
  var t, n;
  return Object.assign(Object.assign({}, e), {
    name: (t = e.name) !== null && t !== void 0 ? t : "",
    components:
      (n = e.components) === null || n === void 0
        ? void 0
        : n.map((r) => pI(r)),
  });
}
function gq(e) {
  return (
    !ce(e) && typeof e == "object" && !ce(e.type) && typeof e.type == "string"
  );
}
function mI(e) {
  return e.map((t) => {
    var n;
    if (gq(t)) return t;
    if (typeof t == "string") return pI(yq(t.replace(/tuple/, "")));
    if (XG(t)) {
      const r = Object.keys(t)[0],
        i = sI(r);
      return (
        (i.name = (n = i.name) !== null && n !== void 0 ? n : ""),
        Object.assign(Object.assign({}, i), { components: oI(t[r]) })
      );
    }
    throw new Te("Invalid abi");
  });
}
function ww(e) {
  const t = e.type.lastIndexOf("["),
    n = e.type.substring(0, t),
    r = e.type.substring(t);
  let i = -1;
  if (r !== "[]" && ((i = Number(r.slice(1, -1))), isNaN(i)))
    throw new Te("Invalid fixed array size", { size: r });
  return { param: { type: n, name: "", components: e.components }, size: i };
}
function lh(e) {
  var t, n;
  return e.type === "string" || e.type === "bytes" || e.type.endsWith("[]")
    ? !0
    : e.type === "tuple"
    ? (n =
        (t = e.components) === null || t === void 0 ? void 0 : t.some(lh)) !==
        null && n !== void 0
      ? n
      : !1
    : e.type.endsWith("]")
    ? lh(ww(e).param)
    : !1;
}
const yI = 20,
  gI = it - yI;
function vq(e, t) {
  if (typeof t != "string")
    throw new Te("address type expects string as input type", {
      value: t,
      name: e.name,
      type: e.type,
    });
  let n = t.toLowerCase();
  if ((n.startsWith("0x") || (n = `0x${n}`), !er(n)))
    throw new Te("provided input is not valid address", {
      value: t,
      name: e.name,
      type: e.type,
    });
  const r = vo(n),
    i = Ig(it);
  return i.set(r, gI), { dynamic: !1, encoded: i };
}
function bq(e, t) {
  const n = t.subarray(gI, it);
  if (n.length !== yI)
    throw new Te("Invalid decoding input, not enough bytes to decode address", {
      bytes: t,
    });
  const r = vs(n);
  return { result: Lr(r), encoded: t.subarray(it), consumed: it };
}
const ls = new Map();
let nd = BigInt(256);
for (let e = 8; e <= 256; e += 8)
  ls.set(`uint${e}`, { min: BigInt(0), max: nd - BigInt(1) }),
    ls.set(`int${e}`, {
      min: -nd / BigInt(2),
      max: nd / BigInt(2) - BigInt(1),
    }),
    (nd *= BigInt(256));
ls.set("int", ls.get("int256"));
ls.set("uint", ls.get("uint256"));
const vI = BigInt(1) << BigInt(256);
function wq(e, t = it) {
  let n;
  return (
    e < 0 ? (n = (vI + e).toString(16)) : (n = e.toString(16)),
    (n = xa(n, t * 2)),
    vo(n)
  );
}
function Eq(e, t) {
  const n = vs(e),
    r = BigInt(n);
  return r <= t ? r : r - vI;
}
function Al(e, t) {
  let n;
  try {
    n = Bs(t);
  } catch {
    throw new Te("provided input is not number value", {
      type: e.type,
      value: t,
      name: e.name,
    });
  }
  const r = ls.get(e.type);
  if (!r)
    throw new Te("provided abi contains invalid number datatype", {
      type: e.type,
    });
  if (n < r.min)
    throw new Te("provided input is less then minimum for given type", {
      type: e.type,
      value: t,
      name: e.name,
      minimum: r.min.toString(),
    });
  if (n > r.max)
    throw new Te("provided input is greater then maximum for given type", {
      type: e.type,
      value: t,
      name: e.name,
      maximum: r.max.toString(),
    });
  return { dynamic: !1, encoded: wq(n) };
}
function Pa(e, t) {
  if (t.length < it)
    throw new Te("Not enough bytes left to decode", {
      param: e,
      bytesLeft: t.length,
    });
  const n = t.subarray(0, it),
    r = ls.get(e.type);
  if (!r)
    throw new Te("provided abi contains invalid number datatype", {
      type: e.type,
    });
  const i = Eq(n, r.max);
  if (i < r.min)
    throw new Te("decoded value is less then minimum for given type", {
      type: e.type,
      value: i,
      name: e.name,
      minimum: r.min.toString(),
    });
  if (i > r.max)
    throw new Te("decoded value is greater then maximum for given type", {
      type: e.type,
      value: i,
      name: e.name,
      maximum: r.max.toString(),
    });
  return { result: i, encoded: t.subarray(it), consumed: it };
}
function _q(e, t) {
  let n;
  try {
    n = H3(t);
  } catch (r) {
    if (r instanceof Pb)
      throw new Te("provided input is not valid boolean value", {
        type: e.type,
        value: t,
        name: e.name,
      });
  }
  return Al({ type: "uint8", name: "" }, Number(n));
}
function Aq(e, t) {
  const n = Pa({ type: "uint8", name: "" }, t);
  if (n.result > 1 || n.result < 0)
    throw new Te("Invalid boolean value encoded", {
      boolBytes: t.subarray(0, it),
      numberResult: n,
    });
  return { result: n.result === BigInt(1), encoded: n.encoded, consumed: it };
}
const xq = 32;
function bI(e, t) {
  if ((typeof t == "string" && t.length % 2 !== 0 && (t += "0"), !bs(t)))
    throw new Te("provided input is not valid bytes value", {
      type: e.type,
      value: t,
      name: e.name,
    });
  const n = Nr(t),
    [, r] = e.type.split("bytes");
  if (r) {
    if (Number(r) > xq || Number(r) < 1)
      throw new Te(
        "invalid bytes type. Static byte type can have between 1 and 32 bytes",
        { type: e.type }
      );
    if (Number(r) < n.length)
      throw new Te("provided input size is different than type size", {
        type: e.type,
        value: t,
        name: e.name,
      });
    const o = Ig(it);
    return o.set(n), { dynamic: !1, encoded: o };
  }
  const i = Math.ceil(n.length / it),
    s = Ig(it + i * it);
  return (
    s.set(Al({ type: "uint32", name: "" }, n.length).encoded),
    s.set(n, it),
    { dynamic: !0, encoded: s }
  );
}
function wI(e, t) {
  const [, n] = e.type.split("bytes");
  let r = Number(n),
    i = t,
    s = 1,
    o = 0;
  if (!r) {
    const a = Pa({ type: "uint32", name: "" }, i);
    (r = Number(a.result)),
      (o += a.consumed),
      (i = a.encoded),
      (s = Math.ceil(r / it));
  }
  if (r > t.length)
    throw new Te("there is not enough data to decode", {
      type: e.type,
      encoded: t,
      size: r,
    });
  return {
    result: ve(i.subarray(0, r)),
    encoded: i.subarray(s * it),
    consumed: o + s * it,
  };
}
function Sq(e, t) {
  if (typeof t != "string")
    throw new Te("invalid input, should be string", { input: t });
  const n = Ub(t);
  return bI({ type: "bytes", name: "" }, n);
}
function Cq(e, t) {
  const n = wI({ type: "bytes", name: "" }, t);
  return { result: mp(n.result), encoded: n.encoded, consumed: n.consumed };
}
function EI(e) {
  let t = 0,
    n = 0;
  const r = [],
    i = [];
  for (const s of e) s.dynamic ? (t += it) : (t += s.encoded.length);
  for (const s of e)
    s.dynamic
      ? (r.push(Al({ type: "uint256", name: "" }, t + n)),
        i.push(s),
        (n += s.encoded.length))
      : r.push(s);
  return an(...r.map((s) => s.encoded), ...i.map((s) => s.encoded));
}
function Tq(e, t) {
  if (!Array.isArray(t))
    throw new Te("Expected value to be array", { abi: e, values: t });
  const { size: n, param: r } = ww(e),
    i = t.map((a) => kg(r, a)),
    s = n === -1,
    o = i.length > 0 && i[0].dynamic;
  if (!s && t.length !== n)
    throw new Te("Given arguments count doesn't match array length", {
      arrayLength: n,
      argumentsLength: t.length,
    });
  if (s || o) {
    const a = EI(i);
    if (s) {
      const u = Al({ type: "uint256", name: "" }, i.length).encoded;
      return { dynamic: !0, encoded: i.length > 0 ? an(u, a) : u };
    }
    return { dynamic: !0, encoded: a };
  }
  return { dynamic: !1, encoded: an(...i.map((a) => a.encoded)) };
}
function Iq(e, t) {
  let { size: n, param: r } = ww(e);
  const i = n === -1;
  let s = 0;
  const o = [];
  let a = t;
  if (i) {
    const l = Pa({ type: "uint32", name: "" }, t);
    (n = Number(l.result)), (s = l.consumed), (a = l.encoded);
  }
  if (lh(r)) {
    for (let l = 0; l < n; l += 1) {
      const c = Pa({ type: "uint32", name: "" }, a.subarray(l * it));
      s += c.consumed;
      const d = dh(r, a.subarray(Number(c.result)));
      (s += d.consumed), o.push(d.result);
    }
    return { result: o, encoded: a.subarray(s), consumed: s };
  }
  for (let l = 0; l < n; l += 1) {
    const c = dh(r, t.subarray(s));
    (s += c.consumed), o.push(c.result);
  }
  return { result: o, encoded: t.subarray(s), consumed: s };
}
function kg(e, t) {
  if (e.type === "string") return Sq(e, t);
  if (e.type === "bool") return _q(e, t);
  if (e.type === "address") return vq(e, t);
  if (e.type === "tuple") return _I(e, t);
  if (e.type.endsWith("]")) return Tq(e, t);
  if (e.type.startsWith("bytes")) return bI(e, t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) return Al(e, t);
  throw new Error("Unsupported");
}
function dh(e, t) {
  if (e.type === "string") return Cq(e, t);
  if (e.type === "bool") return Aq(e, t);
  if (e.type === "address") return bq(e, t);
  if (e.type === "tuple") return AI(e, t);
  if (e.type.endsWith("]")) return Iq(e, t);
  if (e.type.startsWith("bytes")) return wI(e, t);
  if (e.type.startsWith("uint") || e.type.startsWith("int")) return Pa(e, t);
  throw new Error("Unsupported");
}
function _I(e, t) {
  var n, r, i;
  let s = !1;
  if (!Array.isArray(t) && typeof t != "object")
    throw new Te("param must be either Array or Object", {
      param: e,
      input: t,
    });
  const o = t,
    a = [];
  for (
    let u = 0;
    u <
    ((r = (n = e.components) === null || n === void 0 ? void 0 : n.length) !==
      null && r !== void 0
      ? r
      : 0);
    u += 1
  ) {
    const l = e.components[u];
    let c;
    if (Array.isArray(o)) {
      if (u >= o.length)
        throw new Te("input param length missmatch", { param: e, input: t });
      c = kg(l, o[u]);
    } else {
      const d = o[(i = l.name) !== null && i !== void 0 ? i : ""];
      if (d == null)
        throw new Te("missing input defined in abi", {
          param: e,
          input: t,
          paramName: l.name,
        });
      c = kg(l, d);
    }
    c.dynamic && (s = !0), a.push(c);
  }
  return s
    ? { dynamic: !0, encoded: EI(a) }
    : { dynamic: !1, encoded: an(...a.map((u) => u.encoded)) };
}
function AI(e, t) {
  const n = { __length__: 0 };
  let r = 0;
  if (!e.components) return { result: n, encoded: t, consumed: r };
  let i = 0;
  for (const [s, o] of e.components.entries()) {
    let a;
    if (lh(o)) {
      const u = Pa({ type: "uint32", name: "" }, t.subarray(r));
      (a = dh(o, t.subarray(Number(u.result)))),
        (r += u.consumed),
        (i += a.consumed);
    } else (a = dh(o, t.subarray(r))), (r += a.consumed);
    (n.__length__ += 1),
      (n[s] = a.result),
      o.name && o.name !== "" && (n[o.name] = a.result);
  }
  return { encoded: t.subarray(r + i), result: n, consumed: r + i };
}
function kq(e, t, n) {
  const r = mI(e),
    i = vo(t);
  return AI({ type: "tuple", name: "", components: r }, i).result;
}
function Pq(e, t) {
  if (e.length !== t.length)
    throw new Te("Invalid number of values received for given ABI", {
      expected: e.length,
      received: t.length,
    });
  const n = mI(e);
  return vs(_I({ type: "tuple", name: "", components: n }, t).encoded);
}
const Dp = (e, t) => Pq(e, t),
  Pg = (e, t) => Dp([e], [t]),
  xI = (e, t, n) => {
    try {
      if (e.length > 0 && (!t || t === "0x" || t === "0X"))
        throw new Te(
          "Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced."
        );
      return kq(e, `0x${t.replace(/0x/i, "")}`, n);
    } catch (r) {
      throw new Te(`Parameter decoding error: ${r.message}`, {
        internalErr: r,
      });
    }
  },
  Op = (e, t) => xI(e, t, !1),
  SI = (e, t) => Op([e], t)[0],
  Rp = (e) => {
    if (typeof e != "string" && !Pp(e))
      throw new Te("Invalid parameter value in encodeFunctionSignature");
    let t;
    return (
      e && (typeof e == "function" || typeof e == "object")
        ? (t = fo(e))
        : (t = e),
      On(t).slice(0, 10)
    );
  },
  Dq = (e, t) => {
    var n;
    if (!Pp(e)) throw new Te("Invalid parameter value in encodeFunctionCall");
    return `${Rp(e)}${Dp(
      (n = e.inputs) !== null && n !== void 0 ? n : [],
      t ?? []
    ).replace("0x", "")}`;
  },
  Oq = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"],
  Rq = (e, t) => (e === "string" ? t : SI(e, t)),
  CI = (e, t, n) => {
    const r = Array.isArray(n) ? n : [n],
      i = {},
      s = {};
    for (const [f, p] of e.entries()) p.indexed ? (i[f] = p) : (s[f] = p);
    const o = t ? xI(Object.values(s), t, !0) : { __length__: 0 },
      a = r.length - Object.keys(i).length,
      u = Object.values(i).map((f, p) =>
        Oq.some((m) => f.type.startsWith(m)) ? Rq(f.type, r[p + a]) : r[p + a]
      ),
      l = { __length__: 0 };
    let c = 0,
      d = 0;
    for (const [f, p] of e.entries())
      (l[f] = p.type === "string" ? "" : void 0),
        i[f] && ((l[f] = u[c]), (c += 1)),
        s[f] && ((l[f] = o[String(d)]), (d += 1)),
        p.name && (l[p.name] = l[f]),
        (l.__length__ += 1);
    return l;
  },
  Bd = (e, t) => {
    if (t != null && t.data) {
      let n, r, i;
      try {
        const s = t.data.slice(0, 10),
          o = e.find((a) => eq(a).startsWith(s));
        o != null &&
          o.inputs &&
          ((n = o.name),
          (r = fo(o)),
          (i = Op([...o.inputs], t.data.substring(10))));
      } catch (s) {
        console.error(s);
      }
      n && t.setDecodedProperties(n, r, i);
    }
  };
var Bq = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const TI = (e, t) => {
  var n, r, i, s;
  if (e instanceof zs && e.innerError instanceof up) {
    if (t !== void 0) {
      const o = t.filter((a) => kp(a));
      return (
        Bd(o, e.innerError),
        {
          reason: e.innerError.message,
          signature:
            (n = e.innerError.data) === null || n === void 0
              ? void 0
              : n.slice(0, 10),
          data:
            (r = e.innerError.data) === null || r === void 0
              ? void 0
              : r.substring(10),
          customErrorName: e.innerError.errorName,
          customErrorDecodedSignature: e.innerError.errorSignature,
          customErrorArguments: e.innerError.errorArgs,
        }
      );
    }
    return {
      reason: e.innerError.message,
      signature:
        (i = e.innerError.data) === null || i === void 0
          ? void 0
          : i.slice(0, 10),
      data:
        (s = e.innerError.data) === null || s === void 0
          ? void 0
          : s.substring(10),
    };
  }
  if (
    e instanceof Ic &&
    !Array.isArray(e.innerError) &&
    e.innerError !== void 0
  )
    return e.innerError.message;
  throw e;
};
function II(e, t, n, r = Y) {
  return Bq(this, void 0, void 0, function* () {
    try {
      yield Aw(e, t, e.defaultBlock, r);
      return;
    } catch (i) {
      return TI(i, n);
    }
  });
}
var Nq = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
function t0(e, t, n, r, i, s) {
  return Nq(this, void 0, void 0, function* () {
    let o = s;
    o === void 0 &&
      (r !== void 0
        ? (o = TI(r))
        : e.handleRevert && t !== void 0 && (o = yield II(e, t, i)));
    let a;
    if (o === void 0) a = new o3(n);
    else if (typeof o == "string") a = new jf(o, void 0, n);
    else if (
      o.customErrorName !== void 0 &&
      o.customErrorDecodedSignature !== void 0 &&
      o.customErrorArguments !== void 0
    ) {
      const u = o;
      a = new s3(
        u.reason,
        u.customErrorName,
        u.customErrorDecodedSignature,
        u.customErrorArguments,
        u.signature,
        n,
        u.data
      );
    } else a = new jf(o.reason, o.signature, n, o.data);
    return a;
  });
}
const Ew = (e, t, n, r = Y) => {
  var i, s, o, a, u;
  let l = Object.assign({}, e);
  const c = $(Tp, t, r);
  if ([ka, "allEvents"].includes(l.name)) {
    const f = n.find((p) => p.signature === t.topics[0]);
    f ? (l = f) : (l = { anonymous: !0 });
  }
  if (
    ((l.inputs =
      (s = (i = l.inputs) !== null && i !== void 0 ? i : e.inputs) !== null &&
      s !== void 0
        ? s
        : []),
    !l.anonymous)
  ) {
    let f = 0;
    ((o = l.inputs) !== null && o !== void 0 ? o : []).forEach((p) => {
      p.indexed && (f += 1);
    }),
      f > 0 &&
        t != null &&
        t.topics &&
        (t == null ? void 0 : t.topics.length) !== f + 1 &&
        (l = Object.assign(Object.assign({}, l), {
          anonymous: !0,
          inputs: [],
        }));
  }
  const d = l.anonymous
    ? t.topics
    : ((a = t.topics) !== null && a !== void 0 ? a : []).slice(1);
  return Object.assign(Object.assign({}, c), {
    returnValues: CI(
      [...((u = l.inputs) !== null && u !== void 0 ? u : [])],
      t.data,
      d
    ),
    event: l.name,
    signature:
      l.anonymous || !t.topics || t.topics.length === 0 || !t.topics[0]
        ? void 0
        : t.topics[0],
    raw: { data: t.data, topics: t.topics },
  });
};
var xs = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class kI {
  constructor({ options: t, web3Context: n, promiEvent: r, returnFormat: i }) {
    (this.options = { checkRevertBeforeSending: !0 }),
      (this.options = t),
      (this.web3Context = n),
      (this.promiEvent = r),
      (this.returnFormat = i);
  }
  getReceiptWithEvents(t) {
    var n, r;
    const i = Object.assign({}, t ?? {});
    if (
      !((n = this.options) === null || n === void 0) &&
      n.contractAbi &&
      i.logs &&
      i.logs.length > 0
    ) {
      i.events = {};
      for (const s of i.logs) {
        const o = Ew(
          Ag,
          s,
          (r = this.options) === null || r === void 0 ? void 0 : r.contractAbi,
          this.returnFormat
        );
        o.event && (i.events[o.event] = o);
      }
    }
    return i;
  }
  checkRevertBeforeSending(t) {
    return xs(this, void 0, void 0, function* () {
      if (this.options.checkRevertBeforeSending !== !1) {
        const n = yield II(this.web3Context, t, this.options.contractAbi);
        if (n !== void 0)
          throw yield t0(
            this.web3Context,
            t,
            void 0,
            void 0,
            this.options.contractAbi,
            n
          );
      }
    });
  }
  emitSending(t) {
    this.promiEvent.listenerCount("sending") > 0 &&
      this.promiEvent.emit("sending", t);
  }
  populateGasPrice({ transactionFormatted: t, transaction: n }) {
    var r;
    return xs(this, void 0, void 0, function* () {
      let i = t;
      return (
        !(
          !((r = this.options) === null || r === void 0) && r.ignoreGasPricing
        ) &&
          M(t.gasPrice) &&
          (M(n.maxPriorityFeePerGas) || M(n.maxFeePerGas)) &&
          (i = Object.assign(
            Object.assign({}, t),
            yield tI(t, this.web3Context, ae)
          )),
        i
      );
    });
  }
  signAndSend({ wallet: t, tx: n }) {
    return xs(this, void 0, void 0, function* () {
      if (t) {
        const r = yield t.signTransaction(n);
        return Cg(
          this.web3Context,
          () =>
            xs(this, void 0, void 0, function* () {
              return ZT(this.web3Context.requestManager, r.rawTransaction);
            }),
          r.transactionHash
        );
      }
      return Cg(this.web3Context, () =>
        xs(this, void 0, void 0, function* () {
          return Vz(this.web3Context.requestManager, n);
        })
      );
    });
  }
  emitSent(t) {
    this.promiEvent.listenerCount("sent") > 0 &&
      this.promiEvent.emit("sent", t);
  }
  emitTransactionHash(t) {
    this.promiEvent.listenerCount("transactionHash") > 0 &&
      this.promiEvent.emit("transactionHash", t);
  }
  emitReceipt(t) {
    this.promiEvent.listenerCount("receipt") > 0 &&
      this.promiEvent.emit("receipt", t);
  }
  handleError({ error: t, tx: n }) {
    var r;
    return xs(this, void 0, void 0, function* () {
      let i = t;
      return (
        i instanceof zs &&
          this.web3Context.handleRevert &&
          (i = yield t0(
            this.web3Context,
            n,
            void 0,
            void 0,
            (r = this.options) === null || r === void 0 ? void 0 : r.contractAbi
          )),
        (i instanceof Ic ||
          i instanceof zs ||
          i instanceof s3 ||
          i instanceof o3 ||
          i instanceof jf) &&
          this.promiEvent.listenerCount("error") > 0 &&
          this.promiEvent.emit("error", i),
        i
      );
    });
  }
  emitConfirmation({ receipt: t, transactionHash: n }) {
    this.promiEvent.listenerCount("confirmation") > 0 &&
      JG(this.web3Context, this.promiEvent, t, n, this.returnFormat);
  }
  handleResolve({ receipt: t, tx: n }) {
    var r, i, s;
    return xs(this, void 0, void 0, function* () {
      if (
        !((r = this.options) === null || r === void 0) &&
        r.transactionResolver
      )
        return (i = this.options) === null || i === void 0
          ? void 0
          : i.transactionResolver(t);
      if (t.status === BigInt(0)) {
        const o = yield t0(
          this.web3Context,
          n,
          t,
          void 0,
          (s = this.options) === null || s === void 0 ? void 0 : s.contractAbi
        );
        throw (
          (this.promiEvent.listenerCount("error") > 0 &&
            this.promiEvent.emit("error", o),
          o)
        );
      } else return t;
    });
  }
}
var Be = function (e, t, n, r) {
    function i(s) {
      return s instanceof n
        ? s
        : new n(function (o) {
            o(s);
          });
    }
    return new (n || (n = Promise))(function (s, o) {
      function a(c) {
        try {
          l(r.next(c));
        } catch (d) {
          o(d);
        }
      }
      function u(c) {
        try {
          l(r.throw(c));
        } catch (d) {
          o(d);
        }
      }
      function l(c) {
        c.done ? s(c.value) : i(c.value).then(a, u);
      }
      l((r = r.apply(e, t || [])).next());
    });
  },
  Mq = function (e, t) {
    var n = {};
    for (var r in e)
      Object.prototype.hasOwnProperty.call(e, r) &&
        t.indexOf(r) < 0 &&
        (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
        t.indexOf(r[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(e, r[i]) &&
          (n[r[i]] = e[r[i]]);
    return n;
  };
const Lq = (e) =>
  Be(void 0, void 0, void 0, function* () {
    return KT(e.requestManager);
  });
function Fq(e, t) {
  return Be(this, void 0, void 0, function* () {
    const n = yield Bz(e.requestManager);
    return $({ format: "uint" }, n, t);
  });
}
function PI(e, t) {
  return Be(this, void 0, void 0, function* () {
    const n = yield Nz(e.requestManager);
    return $({ format: "uint" }, n, t);
  });
}
function _w(e, t) {
  return Be(this, void 0, void 0, function* () {
    const n = yield Lz(e.requestManager);
    return $({ format: "uint" }, n, t);
  });
}
function jq(e, t, n = e.defaultBlock, r) {
  return Be(this, void 0, void 0, function* () {
    const i = _t(n) ? n : $({ format: "uint" }, n, ae),
      s = yield Fz(e.requestManager, t, i);
    return $({ format: "uint" }, s, r);
  });
}
function Uq(e, t, n, r = e.defaultBlock, i) {
  return Be(this, void 0, void 0, function* () {
    const s = $({ format: "uint" }, n, ae),
      o = _t(r) ? r : $({ format: "uint" }, r, ae),
      a = yield jz(e.requestManager, t, s, o);
    return $({ format: "bytes" }, a, i);
  });
}
function $q(e, t, n = e.defaultBlock, r) {
  return Be(this, void 0, void 0, function* () {
    const i = _t(n) ? n : $({ format: "uint" }, n, ae),
      s = yield qz(e.requestManager, t, i);
    return $({ format: "bytes" }, s, r);
  });
}
function DI(e, t = e.defaultBlock, n = !1, r) {
  return Be(this, void 0, void 0, function* () {
    let i;
    if (bs(t)) {
      const s = $({ format: "bytes32" }, t, ae);
      i = yield Jz(e.requestManager, s, n);
    } else {
      const s = _t(t) ? t : $({ format: "uint" }, t, ae);
      i = yield JT(e.requestManager, s, n);
    }
    return $(uh, i, r);
  });
}
function Hq(e, t = e.defaultBlock, n) {
  return Be(this, void 0, void 0, function* () {
    let r;
    if (bs(t)) {
      const i = $({ format: "bytes32" }, t, ae);
      r = yield $z(e.requestManager, i);
    } else {
      const i = _t(t) ? t : $({ format: "uint" }, t, ae);
      r = yield Hz(e.requestManager, i);
    }
    return $({ format: "uint" }, r, n);
  });
}
function zq(e, t = e.defaultBlock, n) {
  return Be(this, void 0, void 0, function* () {
    let r;
    if (bs(t)) {
      const i = $({ format: "bytes32" }, t, ae);
      r = yield zz(e.requestManager, i);
    } else {
      const i = _t(t) ? t : $({ format: "uint" }, t, ae);
      r = yield Gz(e.requestManager, i);
    }
    return $({ format: "uint" }, r, n);
  });
}
function Gq(e, t = e.defaultBlock, n, r) {
  return Be(this, void 0, void 0, function* () {
    const i = $({ format: "uint" }, n, ae);
    let s;
    if (bs(t)) {
      const o = $({ format: "bytes32" }, t, ae);
      s = yield nG(e.requestManager, o, i);
    } else {
      const o = _t(t) ? t : $({ format: "uint" }, t, ae);
      s = yield rG(e.requestManager, o, i);
    }
    return $(uh, s, r);
  });
}
function qq(e, t, n) {
  return Be(this, void 0, void 0, function* () {
    const r = $({ format: "bytes32" }, t, Y),
      i = yield Yz(e.requestManager, r);
    return M(i) ? i : _n(i, n, { fillInputAndData: !0 });
  });
}
function Wq(e, t) {
  return Be(this, void 0, void 0, function* () {
    return (yield uG(e.requestManager)).map((r) =>
      _n(r, t, { fillInputAndData: !0 })
    );
  });
}
function Qq(e, t = e.defaultBlock, n, r) {
  return Be(this, void 0, void 0, function* () {
    const i = $({ format: "uint" }, n, ae);
    let s;
    if (bs(t)) {
      const o = $({ format: "bytes32" }, t, ae);
      s = yield Xz(e.requestManager, o, i);
    } else {
      const o = _t(t) ? t : $({ format: "uint" }, t, ae);
      s = yield eG(e.requestManager, o, i);
    }
    return M(s) ? s : _n(s, r, { fillInputAndData: !0 });
  });
}
function OI(e, t, n) {
  return Be(this, void 0, void 0, function* () {
    const r = $({ format: "bytes32" }, t, Y),
      i = yield tG(e.requestManager, r);
    return M(i) ? i : $(Qa, i, n);
  });
}
function RI(e, t, n = e.defaultBlock, r) {
  return Be(this, void 0, void 0, function* () {
    const i = _t(n) ? n : $({ format: "uint" }, n, ae),
      s = yield Uz(e.requestManager, t, i);
    return $({ format: "uint" }, s, r);
  });
}
function Dg(e, t, n, r = { checkRevertBeforeSending: !0 }) {
  const i = new VT((s, o) => {
    setImmediate(() => {
      Be(this, void 0, void 0, function* () {
        const a = new kI({
          web3Context: e,
          promiEvent: i,
          options: r,
          returnFormat: n,
        });
        let u = _n(
          Object.assign(Object.assign({}, t), {
            from: xg("from", e, t),
            to: xg("to", e, t),
          }),
          ae
        );
        try {
          (u = yield a.populateGasPrice({
            transaction: t,
            transactionFormatted: u,
          })),
            yield a.checkRevertBeforeSending(u),
            a.emitSending(u);
          let l;
          e.wallet && !M(u.from) && (l = e.wallet.get(u.from));
          const c = yield a.signAndSend({ wallet: l, tx: u }),
            d = $({ format: "bytes32" }, c, n);
          a.emitSent(u), a.emitTransactionHash(d);
          const f = yield iI(e, c, n),
            p = a.getReceiptWithEvents($(Qa, f, n));
          a.emitReceipt(p),
            s(yield a.handleResolve({ receipt: p, tx: u })),
            a.emitConfirmation({ receipt: p, transactionHash: c });
        } catch (l) {
          o(yield a.handleError({ error: l, tx: u }));
        }
      });
    });
  });
  return i;
}
function Vq(e, t, n, r = { checkRevertBeforeSending: !0 }) {
  const i = new VT((s, o) => {
    setImmediate(() => {
      Be(this, void 0, void 0, function* () {
        const a = new kI({
            web3Context: e,
            promiEvent: i,
            options: r,
            returnFormat: n,
          }),
          u = $({ format: "bytes" }, t, ae),
          l = lo.fromSerializedData(Nr(He(u))),
          c = Object.assign(Object.assign({}, l.toJSON()), {
            from: l.getSenderAddress().toString(),
          });
        try {
          const { v: d, r: f, s: p } = c,
            m = Mq(c, ["v", "r", "s"]);
          yield a.checkRevertBeforeSending(m), a.emitSending(u);
          const g = yield Cg(e, () =>
            Be(this, void 0, void 0, function* () {
              return ZT(e.requestManager, u);
            })
          );
          a.emitSent(u);
          const w = $({ format: "bytes32" }, g, n);
          a.emitTransactionHash(w);
          const v = yield iI(e, g, n),
            y = a.getReceiptWithEvents($(Qa, v, n));
          a.emitReceipt(y),
            s(yield a.handleResolve({ receipt: y, tx: c })),
            a.emitConfirmation({ receipt: y, transactionHash: g });
        } catch (d) {
          o(yield a.handleError({ error: d, tx: c }));
        }
      });
    });
  });
  return i;
}
function Kq(e, t, n, r) {
  var i;
  return Be(this, void 0, void 0, function* () {
    const s = $({ format: "bytes" }, t, Y);
    if (!((i = e.wallet) === null || i === void 0) && i.get(n)) {
      const u = e.wallet.get(n).sign(s);
      return $(MG, u, r);
    }
    if (typeof n == "number")
      throw new Bj(
        t,
        'RPC method "eth_sign" does not support index signatures'
      );
    const o = yield Wz(e.requestManager, n, s);
    return $({ format: "bytes" }, o, r);
  });
}
function Zq(e, t, n) {
  return Be(this, void 0, void 0, function* () {
    const r = yield Qz(e.requestManager, _n(t, ae));
    return Ob(r)
      ? UG(r, n, { fillInputAndData: !0 })
      : {
          raw: $({ format: "bytes" }, r.raw, n),
          tx: _n(r.tx, n, { fillInputAndData: !0 }),
        };
  });
}
function Aw(e, t, n = e.defaultBlock, r) {
  return Be(this, void 0, void 0, function* () {
    const i = _t(n) ? n : $({ format: "uint" }, n, ae),
      s = yield Kz(e.requestManager, _n(t, ae), i);
    return $({ format: "bytes" }, s, r);
  });
}
function xw(e, t, n = e.defaultBlock, r) {
  return Be(this, void 0, void 0, function* () {
    const i = _n(t, ae),
      s = _t(n) ? n : $({ format: "uint" }, n, ae),
      o = yield Zz(e.requestManager, i, s);
    return $({ format: "uint" }, o, r);
  });
}
function BI(e, t, n) {
  return Be(this, void 0, void 0, function* () {
    let { toBlock: r, fromBlock: i } = t;
    M(r) || ((typeof r == "number" || typeof r == "bigint") && (r = kn(r))),
      M(i) || ((typeof i == "number" || typeof i == "bigint") && (i = kn(i)));
    const s = Object.assign(Object.assign({}, t), { fromBlock: i, toBlock: r });
    return (yield iG(e.requestManager, s)).map((u) =>
      typeof u == "string" ? u : $(Tp, u, n)
    );
  });
}
function NI(e, t) {
  return Be(this, void 0, void 0, function* () {
    const n = yield lG(e.requestManager);
    return $({ format: "uint" }, n, t);
  });
}
function Jq(e, t, n, r = e.defaultBlock, i) {
  return Be(this, void 0, void 0, function* () {
    const s = n.map((u) => $({ format: "bytes" }, u, ae)),
      o = _t(r) ? r : $({ format: "uint" }, r, ae),
      a = yield dG(e.requestManager, t, s, o);
    return $(jG, a, i);
  });
}
function Yq(e, t, n = e.defaultBlock, r, i) {
  return Be(this, void 0, void 0, function* () {
    const s = $({ format: "uint" }, t, ae),
      o = _t(n) ? n : $({ format: "uint" }, n, ae),
      a = $({ type: "array", items: { format: "uint" } }, r, Ip),
      u = yield aG(e.requestManager, s, o, a);
    return $(LG, u, i);
  });
}
function MI(e, t, n = e.defaultBlock, r) {
  return Be(this, void 0, void 0, function* () {
    const i = _t(n) ? n : $({ format: "uint" }, n, ae),
      s = yield hG(e.requestManager, _n(t, ae), i);
    return $(DG, s, r);
  });
}
function Xq(e, t, n, r, i) {
  return Be(this, void 0, void 0, function* () {
    const s = yield pG(e.requestManager, t, n, r);
    return $({ format: "bytes" }, s, i);
  });
}
let LI = class extends El {
  _buildSubscriptionParams() {
    return ["logs", this.args];
  }
  formatSubscriptionResult(t) {
    return $(Tp, t, super.returnFormat);
  }
};
class c2 extends El {
  _buildSubscriptionParams() {
    return ["newPendingTransactions"];
  }
  formatSubscriptionResult(t) {
    return $({ format: "string" }, t, super.returnFormat);
  }
}
class fh extends El {
  _buildSubscriptionParams() {
    return ["newHeads"];
  }
  formatSubscriptionResult(t) {
    return $(BG, t, super.returnFormat);
  }
}
class FI extends El {
  _buildSubscriptionParams() {
    return ["syncing"];
  }
  _processSubscriptionResult(t) {
    if (typeof t == "boolean") this.emit("changed", t);
    else {
      const n = Object.fromEntries(
        Object.entries(t.status).map(([r, i]) => [
          r.charAt(0).toLowerCase() + r.substring(1),
          i,
        ])
      );
      this.emit("changed", t.syncing),
        this.emit("data", $(NG, n, super.returnFormat));
    }
  }
}
var Ee = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const Og = {
  logs: LI,
  newPendingTransactions: c2,
  newHeads: fh,
  syncing: FI,
  pendingTransactions: c2,
  newBlockHeaders: fh,
};
class Bp extends gn {
  constructor(t) {
    if (typeof t == "string" || rh(t)) {
      super({ provider: t, registeredSubscriptions: Og });
      return;
    }
    if (t.registeredSubscriptions) {
      super(t);
      return;
    }
    super(Object.assign(Object.assign({}, t), { registeredSubscriptions: Og }));
  }
  getProtocolVersion() {
    return Ee(this, void 0, void 0, function* () {
      return Dz(this.requestManager);
    });
  }
  isSyncing() {
    return Ee(this, void 0, void 0, function* () {
      return KT(this.requestManager);
    });
  }
  getCoinbase() {
    return Ee(this, void 0, void 0, function* () {
      return Oz(this.requestManager);
    });
  }
  isMining() {
    return Ee(this, void 0, void 0, function* () {
      return Rz(this.requestManager);
    });
  }
  getHashrate(t = Y) {
    return Ee(this, void 0, void 0, function* () {
      return this.getHashRate(t);
    });
  }
  getHashRate(t = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Fq(this, t);
    });
  }
  getGasPrice(t = Y) {
    return Ee(this, void 0, void 0, function* () {
      return PI(this, t);
    });
  }
  getAccounts() {
    var t;
    return Ee(this, void 0, void 0, function* () {
      return (
        (t = yield Mz(this.requestManager)) !== null && t !== void 0 ? t : []
      ).map((r) => Lr(r));
    });
  }
  getBlockNumber(t = Y) {
    return Ee(this, void 0, void 0, function* () {
      return _w(this, t);
    });
  }
  getBalance(t, n = this.defaultBlock, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return jq(this, t, n, r);
    });
  }
  getStorageAt(t, n, r = this.defaultBlock, i = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Uq(this, t, n, r, i);
    });
  }
  getCode(t, n = this.defaultBlock, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return $q(this, t, n, r);
    });
  }
  getBlock(t = this.defaultBlock, n = !1, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return DI(this, t, n, r);
    });
  }
  getBlockTransactionCount(t = this.defaultBlock, n = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Hq(this, t, n);
    });
  }
  getBlockUncleCount(t = this.defaultBlock, n = Y) {
    return Ee(this, void 0, void 0, function* () {
      return zq(this, t, n);
    });
  }
  getUncle(t = this.defaultBlock, n, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Gq(this, t, n, r);
    });
  }
  getTransaction(t, n = Y) {
    return Ee(this, void 0, void 0, function* () {
      const r = yield qq(this, t, n);
      if (!r) throw new v_();
      return r;
    });
  }
  getPendingTransactions(t = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Wq(this, t);
    });
  }
  getTransactionFromBlock(t = this.defaultBlock, n, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Qq(this, t, n, r);
    });
  }
  getTransactionReceipt(t, n = Y) {
    return Ee(this, void 0, void 0, function* () {
      const r = yield OI(this, t, n);
      if (!r) throw new v_();
      return r;
    });
  }
  getTransactionCount(t, n = this.defaultBlock, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return RI(this, t, n, r);
    });
  }
  sendTransaction(t, n = Y, r) {
    return Dg(this, t, n, r);
  }
  sendSignedTransaction(t, n = Y, r) {
    return Vq(this, t, n, r);
  }
  sign(t, n, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Kq(this, t, n, r);
    });
  }
  signTransaction(t, n = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Zq(this, t, n);
    });
  }
  call(t, n = this.defaultBlock, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Aw(this, t, n, r);
    });
  }
  estimateGas(t, n = this.defaultBlock, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return xw(this, t, n, r);
    });
  }
  getPastLogs(t, n = Y) {
    return Ee(this, void 0, void 0, function* () {
      return BI(this, t, n);
    });
  }
  getWork() {
    return Ee(this, void 0, void 0, function* () {
      return sG(this.requestManager);
    });
  }
  submitWork(t, n, r) {
    return Ee(this, void 0, void 0, function* () {
      return oG(this.requestManager, t, n, r);
    });
  }
  requestAccounts() {
    return Ee(this, void 0, void 0, function* () {
      return cG(this.requestManager);
    });
  }
  getChainId(t = Y) {
    return Ee(this, void 0, void 0, function* () {
      return NI(this, t);
    });
  }
  getNodeInfo() {
    return Ee(this, void 0, void 0, function* () {
      return fG(this.requestManager);
    });
  }
  getProof(t, n, r = this.defaultBlock, i = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Jq(this, t, n, r, i);
    });
  }
  getFeeHistory(t, n = this.defaultBlock, r, i = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Yq(this, t, n, r, i);
    });
  }
  createAccessList(t, n = this.defaultBlock, r = Y) {
    return Ee(this, void 0, void 0, function* () {
      return MI(this, t, n, r);
    });
  }
  signTypedData(t, n, r = !1, i = Y) {
    return Ee(this, void 0, void 0, function* () {
      return Xq(this, t, n, r, i);
    });
  }
  subscribe(t, n, r = Y) {
    var i;
    return Ee(this, void 0, void 0, function* () {
      const s = yield (i = this.subscriptionManager) === null || i === void 0
        ? void 0
        : i.subscribe(t, n, r);
      return (
        s instanceof LI &&
          t === "logs" &&
          typeof n == "object" &&
          !ce(n.fromBlock) &&
          Number.isFinite(Number(n.fromBlock)) &&
          setImmediate(() => {
            this.getPastLogs(n)
              .then((o) => {
                for (const a of o) s._processSubscriptionResult(a);
              })
              .catch((o) => {
                s._processSubscriptionError(o);
              });
          }),
        s
      );
    });
  }
  static shouldClearSubscription({ sub: t }) {
    return !(t instanceof FI);
  }
  clearSubscriptions(t = !1) {
    var n;
    return (n = this.subscriptionManager) === null || n === void 0
      ? void 0
      : n.unsubscribe(t ? Bp.shouldClearSubscription : void 0);
  }
}
const eW = (e) => {
    if (!M(e.common)) {
      if (M(e.common.customChain)) throw new Fj();
      if (M(e.common.customChain.chainId)) throw new jj();
      if (!M(e.chainId) && e.chainId !== e.common.customChain.chainId)
        throw new Uj({
          txChainId: e.chainId,
          customChainId: e.common.customChain.chainId,
        });
    }
  },
  tW = (e) => {
    if (!M(e.common) && !M(e.chain) && !M(e.hardfork)) throw new zj();
    if ((!M(e.chain) && M(e.hardfork)) || (!M(e.hardfork) && M(e.chain)))
      throw new Gj({ chain: e.chain, hardfork: e.hardfork });
  },
  nW = (e) => {
    if (
      !M(e.common) &&
      !M(e.common.baseChain) &&
      !M(e.chain) &&
      e.chain !== e.common.baseChain
    )
      throw new $j({ txChain: e.chain, baseChain: e.common.baseChain });
  },
  rW = (e) => {
    if (
      !M(e.common) &&
      !M(e.common.hardfork) &&
      !M(e.hardfork) &&
      e.hardfork !== e.common.hardfork
    )
      throw new Hj({
        txHardfork: e.hardfork,
        commonHardfork: e.common.hardfork,
      });
  },
  l2 = (e) => {
    if (M(e.gas) || !oo(e.gas) || M(e.gasPrice) || !oo(e.gasPrice))
      throw new Kj({ gas: e.gas, gasPrice: e.gasPrice });
    if (!M(e.maxFeePerGas) || !M(e.maxPriorityFeePerGas))
      throw new a3({
        maxFeePerGas: e.maxFeePerGas,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas,
      });
  },
  d2 = (e) => {
    if (!M(e.gasPrice) && e.type === "0x2") throw new Jj(e.gasPrice);
    if (e.type === "0x0" || e.type === "0x1")
      throw new a3({
        maxFeePerGas: e.maxFeePerGas,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas,
      });
    if (
      M(e.maxFeePerGas) ||
      !oo(e.maxFeePerGas) ||
      M(e.maxPriorityFeePerGas) ||
      !oo(e.maxPriorityFeePerGas)
    )
      throw new Zj({
        maxPriorityFeePerGas: e.maxPriorityFeePerGas,
        maxFeePerGas: e.maxFeePerGas,
      });
  },
  iW = (e) => {
    const t = !M(e.gas) || !M(e.gasLimit),
      n = t && !M(e.gasPrice),
      r = t && !M(e.maxPriorityFeePerGas) && !M(e.maxFeePerGas);
    if (!n && !r)
      throw new Wj({
        gas: e.gas,
        gasPrice: e.gasPrice,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas,
        maxFeePerGas: e.maxFeePerGas,
      });
    if (n && r)
      throw new Vj({
        gas: e.gas,
        gasPrice: e.gasPrice,
        maxPriorityFeePerGas: e.maxPriorityFeePerGas,
        maxFeePerGas: e.maxFeePerGas,
      });
    (n ? l2 : d2)(e), (!M(e.type) && e.type > "0x1" ? d2 : l2)(e);
  },
  sW = (e, t) => {
    if (!M(t)) {
      t(e);
      return;
    }
    if (typeof e != "object" || M(e)) throw new Yj(e);
    eW(e), tW(e), nW(e), rW(e);
    const n = _n(e, ae);
    if (
      (iW(n),
      M(n.nonce) ||
        M(n.chainId) ||
        n.nonce.startsWith("-") ||
        n.chainId.startsWith("-"))
    )
      throw new Xj({ nonce: e.nonce, chainId: e.chainId });
  };
var oW = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const aW = (e) => {
    var t, n;
    return {
      nonce: e.nonce,
      gasPrice: e.gasPrice,
      gasLimit: (t = e.gasLimit) !== null && t !== void 0 ? t : e.gas,
      to: e.to,
      value: e.value,
      data: (n = e.data) !== null && n !== void 0 ? n : e.input,
      type: e.type,
      chainId: e.chainId,
      accessList: e.accessList,
      maxPriorityFeePerGas: e.maxPriorityFeePerGas,
      maxFeePerGas: e.maxFeePerGas,
    };
  },
  uW = (e, t) => {
    var n, r, i, s, o, a, u, l, c, d, f, p, m, g, w, v, y, b;
    const _ = (!M(e.chain) && !M(e.hardfork)) || !M(e.common);
    let A;
    if (!_)
      t.defaultCommon
        ? ((A = t.defaultCommon),
          M(A.hardfork) &&
            (A.hardfork =
              (n = e.hardfork) !== null && n !== void 0
                ? n
                : t.defaultHardfork),
          M(A.baseChain) && (A.baseChain = t.defaultChain))
        : (A = gt.custom(
            {
              name: "custom-network",
              chainId: yn(e.chainId),
              networkId: M(e.networkId) ? void 0 : yn(e.networkId),
              defaultHardfork:
                (r = e.hardfork) !== null && r !== void 0
                  ? r
                  : t.defaultHardfork,
            },
            { baseChain: t.defaultChain }
          ));
    else {
      const x =
          (a =
            (o =
              (s =
                (i = e == null ? void 0 : e.common) === null || i === void 0
                  ? void 0
                  : i.customChain) === null || s === void 0
                ? void 0
                : s.name) !== null && o !== void 0
              ? o
              : e.chain) !== null && a !== void 0
            ? a
            : "custom-network",
        h = yn(
          (c =
            (l =
              (u = e == null ? void 0 : e.common) === null || u === void 0
                ? void 0
                : u.customChain) === null || l === void 0
              ? void 0
              : l.chainId) !== null && c !== void 0
            ? c
            : e == null
            ? void 0
            : e.chainId
        ),
        E = yn(
          (p =
            (f =
              (d = e == null ? void 0 : e.common) === null || d === void 0
                ? void 0
                : d.customChain) === null || f === void 0
              ? void 0
              : f.networkId) !== null && p !== void 0
            ? p
            : e == null
            ? void 0
            : e.networkId
        ),
        I =
          (w =
            (g =
              (m = e == null ? void 0 : e.common) === null || m === void 0
                ? void 0
                : m.hardfork) !== null && g !== void 0
              ? g
              : e == null
              ? void 0
              : e.hardfork) !== null && w !== void 0
            ? w
            : t.defaultHardfork,
        C =
          (b =
            (y =
              (v = e.common) === null || v === void 0
                ? void 0
                : v.baseChain) !== null && y !== void 0
              ? y
              : e.chain) !== null && b !== void 0
            ? b
            : t.defaultChain;
      h &&
        E &&
        x &&
        (A = gt.custom(
          { name: x, chainId: h, networkId: E, defaultHardfork: I },
          { baseChain: C }
        ));
    }
    return { common: A };
  },
  cW = (e, t, n, r = !1, i = !0) =>
    oW(void 0, void 0, void 0, function* () {
      const s = yield WG({
          transaction: e,
          web3Context: t,
          privateKey: n,
          fillGasPrice: r,
          fillGasLimit: i,
        }),
        o = _n(s, ae);
      return sW(o), lo.fromTxData(aW(o), uW(o, t));
    }),
  f2 = ({ address: e }, t, n) => {
    var r, i;
    const s = n == null ? void 0 : n.topics,
      o = (r = n == null ? void 0 : n.filter) !== null && r !== void 0 ? r : {},
      a = {};
    if (
      (ce(n == null ? void 0 : n.fromBlock) ||
        (a.fromBlock = $(
          uh.properties.number,
          n == null ? void 0 : n.fromBlock,
          { number: Kn.HEX, bytes: mi.HEX }
        )),
      ce(n == null ? void 0 : n.toBlock) ||
        (a.toBlock = $(uh.properties.number, n == null ? void 0 : n.toBlock, {
          number: Kn.HEX,
          bytes: mi.HEX,
        })),
      s && Array.isArray(s))
    )
      a.topics = [...s];
    else if (
      ((a.topics = []),
      t &&
        !t.anonymous &&
        ![ka, "allEvents"].includes(t.name) &&
        a.topics.push(
          (i = t.signature) !== null && i !== void 0 ? i : vw(fo(t))
        ),
      ![ka, "allEvents"].includes(t.name) && t.inputs)
    )
      for (const u of t.inputs) {
        if (!u.indexed) continue;
        const l = o[u.name];
        if (!l) {
          a.topics.push(null);
          continue;
        }
        Array.isArray(l)
          ? a.topics.push(l.map((c) => Pg(u.type, c)))
          : u.type === "string"
          ? a.topics.push(zc(l))
          : a.topics.push(Pg(u.type, l));
      }
    return (
      a.topics.length || delete a.topics, e && (a.address = e.toLowerCase()), a
    );
  },
  zu = (e, t, n) => {
    const r = Array.isArray(e.inputs) ? e.inputs.length : 0;
    if (r !== t.length)
      throw new Tn(
        `The number of arguments is not matching the methods required number. You need to pass ${r} arguments.`
      );
    const i = Dp(Array.isArray(e.inputs) ? e.inputs : [], t).replace("0x", "");
    if (YG(e)) {
      if (!n)
        throw new Tn(
          "The contract has no contract data option set. This is necessary to append the constructor parameters."
        );
      return n.startsWith("0x") ? `${n}${i}` : `0x${n}${i}`;
    }
    return `${Rp(e)}${i}`;
  },
  lW = (e, t) => {
    if (e.type === "constructor") return t;
    if (!t) return null;
    const n = t.length >= 2 ? t.slice(2) : t;
    if (!e.outputs) return null;
    const r = Op([...e.outputs], n);
    return r.__length__ === 1 ? r[0] : r;
  };
class jI extends El {
  constructor(t, n) {
    super(t, n),
      (this.address = t.address),
      (this.topics = t.topics),
      (this.abi = t.abi),
      (this.jsonInterface = t.jsonInterface);
  }
  _buildSubscriptionParams() {
    return ["logs", { address: this.address, topics: this.topics }];
  }
  formatSubscriptionResult(t) {
    return Ew(this.abi, t, this.jsonInterface, super.returnFormat);
  }
}
const Np = (e, t, n, r) => {
    var i, s;
    const o = {};
    return (
      (!ce(e.data) || r === "both") &&
        (o.data = zu(
          t,
          n,
          (i = e.data) !== null && i !== void 0 ? i : e.input
        )),
      (!ce(e.input) || r === "both") &&
        (o.input = zu(
          t,
          n,
          (s = e.input) !== null && s !== void 0 ? s : e.data
        )),
      ce(o.input) && ce(o.data) && (o[r] = zu(t, n)),
      { data: o.data, input: o.input }
    );
  },
  h2 = ({ abi: e, params: t, options: n, contractOptions: r }) => {
    var i, s, o;
    if (
      !((o =
        (s =
          (i = n == null ? void 0 : n.input) !== null && i !== void 0
            ? i
            : n == null
            ? void 0
            : n.data) !== null && s !== void 0
          ? s
          : r.input) !== null && o !== void 0
        ? o
        : r.data) &&
      !(n != null && n.to) &&
      !r.address
    )
      throw new Tn("Contract address not specified");
    if (!(n != null && n.from) && !r.from)
      throw new Tn('Contract "from" address not specified');
    let u = ws(
      {
        to: r.address,
        gas: r.gas,
        gasPrice: r.gasPrice,
        from: r.from,
        input: r.input,
        maxPriorityFeePerGas: r.maxPriorityFeePerGas,
        maxFeePerGas: r.maxFeePerGas,
        data: r.data,
      },
      n
    );
    const l = Np(u, e, t, n == null ? void 0 : n.dataInputFill);
    return (
      (u = Object.assign(Object.assign({}, u), {
        data: l.data,
        input: l.input,
      })),
      u
    );
  },
  dW = ({ abi: e, params: t, options: n, contractOptions: r }) => {
    if (!(n != null && n.to) && !r.address)
      throw new Tn("Contract address not specified");
    let i = ws(
      {
        to: r.address,
        gas: r.gas,
        gasPrice: r.gasPrice,
        from: r.from,
        input: r.input,
        maxPriorityFeePerGas: r.maxPriorityFeePerGas,
        maxFeePerGas: r.maxFeePerGas,
        data: r.data,
      },
      n
    );
    const s = Np(i, e, t, n == null ? void 0 : n.dataInputFill);
    return (
      (i = Object.assign(Object.assign({}, i), {
        data: s.data,
        input: s.input,
      })),
      i
    );
  },
  fW = ({ abi: e, params: t, options: n, contractOptions: r }) => {
    let i = ws(
      {
        to: r.address,
        gas: r.gas,
        gasPrice: r.gasPrice,
        from: r.from,
        input: r.input,
        data: r.data,
      },
      n
    );
    const s = Np(i, e, t, n == null ? void 0 : n.dataInputFill);
    return (
      (i = Object.assign(Object.assign({}, i), {
        data: s.data,
        input: s.input,
      })),
      i
    );
  },
  p2 = (e) =>
    typeof e == "object" && !ce(e) && Object.keys(e).length !== 0 && !$i(e),
  hW = ({ abi: e, params: t, options: n, contractOptions: r }) => {
    if (!(n != null && n.to) && !r.address)
      throw new Tn("Contract address not specified");
    if (!(n != null && n.from) && !r.from)
      throw new Tn('Contract "from" address not specified');
    let i = ws(
      {
        to: r.address,
        gas: r.gas,
        gasPrice: r.gasPrice,
        from: r.from,
        input: r.input,
        maxPriorityFeePerGas: r.maxPriorityFeePerGas,
        maxFeePerGas: r.maxFeePerGas,
        data: r.data,
      },
      n
    );
    const s = Np(i, e, t, n == null ? void 0 : n.dataInputFill);
    return (
      (i = Object.assign(Object.assign({}, i), {
        data: s.data,
        input: s.input,
      })),
      i
    );
  };
var ki = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const pW = { logs: jI, newHeads: fh, newBlockHeaders: fh };
class Qs extends gn {
  constructor(t, n, r, i, s) {
    var o, a, u;
    const l = $i(n) ? n : $i(r) ? r : void 0;
    let c;
    p2(n) ? (c = n) : p2(r) ? (c = r) : (c = i);
    let d;
    if (
      (typeof n == "object" && "provider" in n
        ? (d = n.provider)
        : typeof r == "object" && "provider" in r
        ? (d = r.provider)
        : typeof i == "object" && "provider" in i
        ? (d = i.provider)
        : (d = Qs.givenProvider),
      super(
        Object.assign(Object.assign({}, c), {
          provider: d,
          registeredSubscriptions: pW,
        })
      ),
      (this.syncWithContext = !1),
      (this._functions = {}),
      !M(l) &&
        !M(l.data) &&
        !M(l.input) &&
        this.config.contractDataInputFill !== "both")
    )
      throw new Ij({ data: l.data, input: l.input });
    this._overloadedMethodAbis = new Map();
    const f = Qr(i) ? i : Qr(r) ? r : s ?? Y,
      p = typeof n == "string" ? n : void 0;
    (this.config.contractDataInputFill =
      (o = l == null ? void 0 : l.dataInputFill) !== null && o !== void 0
        ? o
        : this.config.contractDataInputFill),
      this._parseAndSetJsonInterface(t, f),
      M(p) || this._parseAndSetAddress(p, f),
      (this.options = {
        address: p,
        jsonInterface: this._jsonInterface,
        gas:
          (a = l == null ? void 0 : l.gas) !== null && a !== void 0
            ? a
            : l == null
            ? void 0
            : l.gasLimit,
        gasPrice: l == null ? void 0 : l.gasPrice,
        from: l == null ? void 0 : l.from,
        input: l == null ? void 0 : l.input,
        data: l == null ? void 0 : l.data,
      }),
      (this.syncWithContext =
        (u = l == null ? void 0 : l.syncWithContext) !== null && u !== void 0
          ? u
          : !1),
      c instanceof gn && this.subscribeToContextEvents(c),
      Object.defineProperty(this.options, "address", {
        set: (m) => this._parseAndSetAddress(m, f),
        get: () => this._address,
      }),
      Object.defineProperty(this.options, "jsonInterface", {
        set: (m) => this._parseAndSetJsonInterface(m, f),
        get: () => this._jsonInterface,
      }),
      c instanceof gn &&
        c.on(co.CONFIG_CHANGE, (m) => {
          this.setConfig({ [m.name]: m.newValue });
        });
  }
  get events() {
    return this._events;
  }
  get methods() {
    return this._methods;
  }
  clone() {
    let t;
    return (
      this.options.address
        ? (t = new Qs(
            [...this._jsonInterface, ...this._errorsInterface],
            this.options.address,
            {
              gas: this.options.gas,
              gasPrice: this.options.gasPrice,
              from: this.options.from,
              input: this.options.input,
              data: this.options.data,
              provider: this.currentProvider,
              syncWithContext: this.syncWithContext,
              dataInputFill: this.config.contractDataInputFill,
            },
            this.getContextObject()
          ))
        : (t = new Qs(
            [...this._jsonInterface, ...this._errorsInterface],
            {
              gas: this.options.gas,
              gasPrice: this.options.gasPrice,
              from: this.options.from,
              input: this.options.input,
              data: this.options.data,
              provider: this.currentProvider,
              syncWithContext: this.syncWithContext,
              dataInputFill: this.config.contractDataInputFill,
            },
            this.getContextObject()
          )),
      this.context && t.subscribeToContextEvents(this.context),
      t
    );
  }
  deploy(t) {
    var n, r, i;
    let s = this._jsonInterface.find((d) => d.type === "constructor");
    s || (s = { type: "constructor", inputs: [], stateMutability: "" });
    const o = $(
        { format: "bytes" },
        (n = t == null ? void 0 : t.input) !== null && n !== void 0
          ? n
          : this.options.input,
        Y
      ),
      a = $(
        { format: "bytes" },
        (r = t == null ? void 0 : t.data) !== null && r !== void 0
          ? r
          : this.options.data,
        Y
      );
    if ((!o || o.trim() === "0x") && (!a || a.trim() === "0x"))
      throw new Tn("contract creation without any data provided.");
    const u =
        (i = t == null ? void 0 : t.arguments) !== null && i !== void 0
          ? i
          : [],
      l = Object.assign(Object.assign({}, this.options), { input: o, data: a }),
      c = o ?? a;
    return {
      arguments: u,
      send: (d) => {
        const f = Object.assign({}, d);
        return this._contractMethodDeploySend(s, u, f, l);
      },
      estimateGas: (d, f = Y) =>
        ki(this, void 0, void 0, function* () {
          const p = Object.assign({}, d);
          return this._contractMethodEstimateGas({
            abi: s,
            params: u,
            returnFormat: f,
            options: p,
            contractOptions: l,
          });
        }),
      encodeABI: () => zu(s, u, $({ format: "bytes" }, c, Y)),
    };
  }
  getPastEvents(t, n, r) {
    var i;
    return ki(this, void 0, void 0, function* () {
      const s = typeof t == "string" ? t : ka,
        o = typeof t != "string" && !Qr(t) ? t : Qr(n) ? {} : n,
        a = Qr(t) ? t : Qr(n) ? n : r ?? Y,
        u =
          s === "allEvents" || s === ka
            ? Ag
            : this._jsonInterface.find((v) => "name" in v && v.name === s);
      if (!u) throw new Tn(`Event ${s} not found.`);
      const {
          fromBlock: l,
          toBlock: c,
          topics: d,
          address: f,
        } = f2(this.options, u, o ?? {}),
        m = (yield BI(
          this,
          { fromBlock: l, toBlock: c, topics: d, address: f },
          a
        )).map((v) =>
          typeof v == "string" ? v : Ew(u, v, this._jsonInterface, a)
        ),
        g =
          (i = o == null ? void 0 : o.filter) !== null && i !== void 0 ? i : {},
        w = Object.keys(g);
      return w.length > 0
        ? m.filter((v) =>
            typeof v == "string"
              ? !0
              : w.every((y) => {
                  var b;
                  if (Array.isArray(g[y]))
                    return g[y].some(
                      (A) =>
                        String(v.returnValues[y]).toUpperCase() ===
                        String(A).toUpperCase()
                    );
                  const _ =
                    (b = u.inputs) === null || b === void 0
                      ? void 0
                      : b.filter((A) => A.name === y)[0];
                  return _ != null &&
                    _.indexed &&
                    _.type === "string" &&
                    zc(g[y]) === String(v.returnValues[y])
                    ? !0
                    : String(v.returnValues[y]).toUpperCase() ===
                        String(g[y]).toUpperCase();
                })
          )
        : m;
    });
  }
  _parseAndSetAddress(t, n = Y) {
    this._address = t && Lr($({ format: "address" }, t, n));
  }
  _parseAndSetJsonInterface(t, n = Y) {
    var r, i, s, o, a;
    (this._functions = {}), (this._methods = {}), (this._events = {});
    let u = [];
    const l = t.filter((d) => d.type !== "error"),
      c = t.filter((d) => kp(d));
    for (const d of l) {
      const f = Object.assign(Object.assign({}, d), { signature: "" });
      if (Pp(f)) {
        const p = fo(f),
          m = Rp(p);
        (f.signature = m),
          (f.constant =
            (i =
              (r = f.stateMutability === "view") !== null && r !== void 0
                ? r
                : f.stateMutability === "pure") !== null && i !== void 0
              ? i
              : f.constant),
          (f.payable =
            (s = f.stateMutability === "payable") !== null && s !== void 0
              ? s
              : f.payable),
          this._overloadedMethodAbis.set(f.name, [
            ...((o = this._overloadedMethodAbis.get(f.name)) !== null &&
            o !== void 0
              ? o
              : []),
            f,
          ]);
        const g =
            (a = this._overloadedMethodAbis.get(f.name)) !== null &&
            a !== void 0
              ? a
              : [],
          w = this._createContractMethod(g, c);
        (this._functions[p] = { signature: m, method: w }),
          (this._methods[f.name] = this._functions[p].method),
          (this._methods[p] = this._functions[p].method),
          (this._methods[m] = this._functions[p].method);
      } else if (gw(f)) {
        const p = fo(f),
          m = vw(p),
          g = this._createContractEvent(f, n);
        (f.signature = m),
          (!(p in this._events) || f.name === "bound") && (this._events[p] = g),
          (this._events[f.name] = g),
          (this._events[m] = g);
      }
      u = [...u, f];
    }
    (this._events.allEvents = this._createContractEvent(Ag, n)),
      (this._jsonInterface = [...u]),
      (this._errorsInterface = c);
  }
  _getAbiParams(t, n) {
    var r;
    try {
      return $u((r = t.inputs) !== null && r !== void 0 ? r : [], n);
    } catch (i) {
      throw new Tn(`Invalid parameters for method ${t.name}: ${i.message}`);
    }
  }
  _createContractMethod(t, n) {
    const r = t[t.length - 1];
    return (...i) => {
      var s, o;
      let a;
      const u =
        (s = this._overloadedMethodAbis.get(r.name)) !== null && s !== void 0
          ? s
          : [];
      let l = u[0];
      const c = n,
        d = u.filter((p) => {
          var m;
          return (
            ((m = p.inputs) !== null && m !== void 0 ? m : []).length ===
            i.length
          );
        });
      if (u.length === 1 || d.length === 0)
        (a = this._getAbiParams(l, i)),
          ie.validate((o = r.inputs) !== null && o !== void 0 ? o : [], a);
      else {
        const p = [];
        for (const m of d)
          try {
            (a = this._getAbiParams(m, i)), ie.validate(m.inputs, a), (l = m);
            break;
          } catch (g) {
            p.push(g);
          }
        if (p.length === d.length) throw new Aa(p);
      }
      const f = {
        arguments: a,
        call: (p, m) =>
          ki(this, void 0, void 0, function* () {
            return this._contractMethodCall(l, a, c, p, m);
          }),
        send: (p) => this._contractMethodSend(l, a, c, p),
        estimateGas: (p, m = Y) =>
          ki(this, void 0, void 0, function* () {
            return this._contractMethodEstimateGas({
              abi: l,
              params: a,
              returnFormat: m,
              options: p,
            });
          }),
        encodeABI: () => zu(l, a),
        createAccessList: (p, m) =>
          ki(this, void 0, void 0, function* () {
            return this._contractMethodCreateAccessList(l, a, c, p, m);
          }),
      };
      return l.stateMutability === "payable", f;
    };
  }
  _contractMethodCall(t, n, r, i, s) {
    var o;
    return ki(this, void 0, void 0, function* () {
      const a = dW({
        abi: t,
        params: n,
        options: Object.assign(Object.assign({}, i), {
          dataInputFill: this.config.contractDataInputFill,
        }),
        contractOptions: Object.assign(Object.assign({}, this.options), {
          from:
            (o = this.options.from) !== null && o !== void 0
              ? o
              : this.config.defaultAccount,
        }),
      });
      try {
        const u = yield Aw(this, a, s, Y);
        return lW(t, u);
      } catch (u) {
        throw (u instanceof zs && Bd(r, u.innerError), u);
      }
    });
  }
  _contractMethodCreateAccessList(t, n, r, i, s) {
    var o;
    return ki(this, void 0, void 0, function* () {
      const a = hW({
        abi: t,
        params: n,
        options: Object.assign(Object.assign({}, i), {
          dataInputFill: this.config.contractDataInputFill,
        }),
        contractOptions: Object.assign(Object.assign({}, this.options), {
          from:
            (o = this.options.from) !== null && o !== void 0
              ? o
              : this.config.defaultAccount,
        }),
      });
      try {
        return MI(this, a, s, Y);
      } catch (u) {
        throw (u instanceof zs && Bd(r, u.innerError), u);
      }
    });
  }
  _contractMethodSend(t, n, r, i, s) {
    var o, a;
    let u = s ?? this.options;
    u = Object.assign(Object.assign({}, u), {
      input: void 0,
      from:
        (a =
          (o = u.from) !== null && o !== void 0 ? o : this.defaultAccount) !==
          null && a !== void 0
          ? a
          : void 0,
    });
    const l = h2({
        abi: t,
        params: n,
        options: Object.assign(Object.assign({}, i), {
          dataInputFill: this.config.contractDataInputFill,
        }),
        contractOptions: u,
      }),
      c = Dg(this, l, Y, {
        checkRevertBeforeSending: !1,
        contractAbi: this._jsonInterface,
      });
    return (
      c.on("error", (d) => {
        d instanceof zs && Bd(r, d.innerError);
      }),
      c
    );
  }
  _contractMethodDeploySend(t, n, r, i) {
    var s, o;
    let a = i ?? this.options;
    a = Object.assign(Object.assign({}, a), {
      from:
        (o =
          (s = a.from) !== null && s !== void 0 ? s : this.defaultAccount) !==
          null && o !== void 0
          ? o
          : void 0,
    });
    const u = h2({
      abi: t,
      params: n,
      options: Object.assign(Object.assign({}, r), {
        dataInputFill: this.config.contractDataInputFill,
      }),
      contractOptions: a,
    });
    return Dg(this, u, Y, {
      transactionResolver: (l) => {
        if (l.status === BigInt(0)) throw new Tn("code couldn't be stored", l);
        const c = this.clone();
        return (c.options.address = l.contractAddress), c;
      },
      contractAbi: this._jsonInterface,
      checkRevertBeforeSending: !1,
    });
  }
  _contractMethodEstimateGas({
    abi: t,
    params: n,
    returnFormat: r,
    options: i,
    contractOptions: s,
  }) {
    return ki(this, void 0, void 0, function* () {
      const o = fW({
        abi: t,
        params: n,
        options: Object.assign(Object.assign({}, i), {
          dataInputFill: this.config.contractDataInputFill,
        }),
        contractOptions: s ?? this.options,
      });
      return xw(this, o, Zr.LATEST, r);
    });
  }
  _createContractEvent(t, n = Y) {
    return (...r) => {
      var i;
      const { topics: s, fromBlock: o } = f2(this.options, t, r[0]),
        a = new jI(
          {
            address: this.options.address,
            topics: s,
            abi: t,
            jsonInterface: this._jsonInterface,
          },
          { subscriptionManager: this.subscriptionManager, returnFormat: n }
        );
      return (
        M(o) ||
          this.getPastEvents(t.name, { fromBlock: o, topics: s }, n)
            .then((u) => {
              u.forEach((l) => a.emit("data", l));
            })
            .catch((u) => {
              a.emit("error", new or("Failed to get past events.", u));
            }),
        (i = this.subscriptionManager) === null ||
          i === void 0 ||
          i.addSubscription(a).catch((u) => {
            a.emit("error", new or("Failed to subscribe.", u));
          }),
        a
      );
    };
  }
  subscribeToContextEvents(t) {
    const n = this;
    (this.context = t),
      n.syncWithContext &&
        t.on(co.CONFIG_CHANGE, (r) => {
          n.setConfig({ [r.name]: r.newValue });
        });
  }
}
const m2 = {
    addr: "0x3b3b57de",
    name: "0x691f3431",
    abi: "0x2203ab56",
    pubkey: "0xc8690233",
    text: "0x59d1d43c",
    contenthash: "0xbc1c58d1",
  },
  n0 = {
    setAddr: "addr",
    addr: "addr",
    setPubkey: "pubkey",
    pubkey: "pubkey",
    setContenthash: "contenthash",
    contenthash: "contenthash",
  },
  hh = {
    main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  },
  mW = { "0x1": "main", "0x5": "goerli" },
  yW = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes32",
          name: "label",
          type: "bytes32",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "NewOwner",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        {
          indexed: !1,
          internalType: "address",
          name: "resolver",
          type: "address",
        },
      ],
      name: "NewResolver",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        {
          indexed: !1,
          internalType: "address",
          name: "owner",
          type: "address",
        },
      ],
      name: "Transfer",
      type: "event",
    },
    {
      inputs: [
        { internalType: "address", name: "owner", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "owner",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "recordExists",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "resolver",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "ttl",
      outputs: [{ internalType: "uint64", name: "", type: "uint64" }],
      stateMutability: "view",
      type: "function",
    },
  ],
  gW = [
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        { indexed: !1, internalType: "address", name: "a", type: "address" },
      ],
      name: "AddrChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        {
          indexed: !1,
          internalType: "uint256",
          name: "coinType",
          type: "uint256",
        },
        {
          indexed: !1,
          internalType: "bytes",
          name: "newAddress",
          type: "bytes",
        },
      ],
      name: "AddressChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address",
        },
        {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address",
        },
        { indexed: !1, internalType: "bool", name: "approved", type: "bool" },
      ],
      name: "ApprovalForAll",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        { indexed: !1, internalType: "bytes", name: "hash", type: "bytes" },
      ],
      name: "ContenthashChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        { indexed: !1, internalType: "bytes", name: "name", type: "bytes" },
        {
          indexed: !1,
          internalType: "uint16",
          name: "resource",
          type: "uint16",
        },
        { indexed: !1, internalType: "bytes", name: "record", type: "bytes" },
      ],
      name: "DNSRecordChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        { indexed: !1, internalType: "bytes", name: "name", type: "bytes" },
        {
          indexed: !1,
          internalType: "uint16",
          name: "resource",
          type: "uint16",
        },
      ],
      name: "DNSRecordDeleted",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
      ],
      name: "DNSZoneCleared",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        {
          indexed: !1,
          internalType: "bytes",
          name: "lastzonehash",
          type: "bytes",
        },
        { indexed: !1, internalType: "bytes", name: "zonehash", type: "bytes" },
      ],
      name: "DNSZonehashChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        {
          indexed: !0,
          internalType: "bytes4",
          name: "interfaceID",
          type: "bytes4",
        },
        {
          indexed: !1,
          internalType: "address",
          name: "implementer",
          type: "address",
        },
      ],
      name: "InterfaceChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        { indexed: !1, internalType: "string", name: "name", type: "string" },
      ],
      name: "NameChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        { indexed: !1, internalType: "bytes32", name: "x", type: "bytes32" },
        { indexed: !1, internalType: "bytes32", name: "y", type: "bytes32" },
      ],
      name: "PubkeyChanged",
      type: "event",
    },
    {
      anonymous: !1,
      inputs: [
        { indexed: !0, internalType: "bytes32", name: "node", type: "bytes32" },
        {
          indexed: !0,
          internalType: "string",
          name: "indexedKey",
          type: "string",
        },
        { indexed: !1, internalType: "string", name: "key", type: "string" },
      ],
      name: "TextChanged",
      type: "event",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "node", type: "bytes32" },
        { internalType: "uint256", name: "contentTypes", type: "uint256" },
      ],
      name: "ABI",
      outputs: [
        { internalType: "uint256", name: "", type: "uint256" },
        { internalType: "bytes", name: "", type: "bytes" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "addr",
      outputs: [{ internalType: "address payable", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "node", type: "bytes32" },
        { internalType: "uint256", name: "coinType", type: "uint256" },
      ],
      name: "addr",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "contenthash",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "node", type: "bytes32" },
        { internalType: "bytes32", name: "name", type: "bytes32" },
        { internalType: "uint16", name: "resource", type: "uint16" },
      ],
      name: "dnsRecord",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "node", type: "bytes32" },
        { internalType: "bytes32", name: "name", type: "bytes32" },
      ],
      name: "hasDNSRecords",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "node", type: "bytes32" },
        { internalType: "bytes4", name: "interfaceID", type: "bytes4" },
      ],
      name: "interfaceImplementer",
      outputs: [{ internalType: "address", name: "", type: "address" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "address", name: "account", type: "address" },
        { internalType: "address", name: "operator", type: "address" },
      ],
      name: "isApprovedForAll",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "name",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "pubkey",
      outputs: [
        { internalType: "bytes32", name: "x", type: "bytes32" },
        { internalType: "bytes32", name: "y", type: "bytes32" },
      ],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes4", name: "interfaceID", type: "bytes4" }],
      name: "supportsInterface",
      outputs: [{ internalType: "bool", name: "", type: "bool" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [
        { internalType: "bytes32", name: "node", type: "bytes32" },
        { internalType: "string", name: "key", type: "string" },
      ],
      name: "text",
      outputs: [{ internalType: "string", name: "", type: "string" }],
      stateMutability: "view",
      type: "function",
    },
    {
      inputs: [{ internalType: "bytes32", name: "node", type: "bytes32" }],
      name: "zonehash",
      outputs: [{ internalType: "bytes", name: "", type: "bytes" }],
      stateMutability: "view",
      type: "function",
    },
  ];
var vW =
  "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
const y2 = new Map([
    [8217, "apostrophe"],
    [8260, "fraction slash"],
    [12539, "middle dot"],
  ]),
  g2 = 4;
function bW(e) {
  let t = 0;
  function n() {
    return (e[t++] << 8) | e[t++];
  }
  let r = n(),
    i = 1,
    s = [0, 1];
  for (let A = 1; A < r; A++) s.push((i += n()));
  let o = n(),
    a = t;
  t += o;
  let u = 0,
    l = 0;
  function c() {
    return u == 0 && ((l = (l << 8) | e[t++]), (u = 8)), (l >> --u) & 1;
  }
  const d = 31,
    f = 2 ** d,
    p = f >>> 1,
    m = p >> 1,
    g = f - 1;
  let w = 0;
  for (let A = 0; A < d; A++) w = (w << 1) | c();
  let v = [],
    y = 0,
    b = f;
  for (;;) {
    let A = Math.floor(((w - y + 1) * i - 1) / b),
      x = 0,
      h = r;
    for (; h - x > 1; ) {
      let C = (x + h) >>> 1;
      A < s[C] ? (h = C) : (x = C);
    }
    if (x == 0) break;
    v.push(x);
    let E = y + Math.floor((b * s[x]) / i),
      I = y + Math.floor((b * s[x + 1]) / i) - 1;
    for (; !((E ^ I) & p); )
      (w = ((w << 1) & g) | c()), (E = (E << 1) & g), (I = ((I << 1) & g) | 1);
    for (; E & ~I & m; )
      (w = (w & p) | ((w << 1) & (g >>> 1)) | c()),
        (E = (E << 1) ^ p),
        (I = ((I ^ p) << 1) | p | 1);
    (y = E), (b = 1 + I - E);
  }
  let _ = r - 4;
  return v.map((A) => {
    switch (A - _) {
      case 3:
        return _ + 65792 + ((e[a++] << 16) | (e[a++] << 8) | e[a++]);
      case 2:
        return _ + 256 + ((e[a++] << 8) | e[a++]);
      case 1:
        return _ + e[a++];
      default:
        return A - 1;
    }
  });
}
function wW(e) {
  let t = 0;
  return () => e[t++];
}
function UI(e) {
  return wW(bW(EW(e)));
}
function EW(e) {
  let t = [];
  [
    ..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  ].forEach((i, s) => (t[i.charCodeAt(0)] = s));
  let n = e.length,
    r = new Uint8Array((6 * n) >> 3);
  for (let i = 0, s = 0, o = 0, a = 0; i < n; i++)
    (a = (a << 6) | t[e.charCodeAt(i)]),
      (o += 6),
      o >= 8 && (r[s++] = a >> (o -= 8));
  return r;
}
function _W(e) {
  return e & 1 ? ~e >> 1 : e >> 1;
}
function AW(e, t) {
  let n = Array(e);
  for (let r = 0, i = 0; r < e; r++) n[r] = i += _W(t());
  return n;
}
function Vc(e, t = 0) {
  let n = [];
  for (;;) {
    let r = e(),
      i = e();
    if (!i) break;
    t += r;
    for (let s = 0; s < i; s++) n.push(t + s);
    t += i + 1;
  }
  return n;
}
function $I(e) {
  return Kc(() => {
    let t = Vc(e);
    if (t.length) return t;
  });
}
function HI(e) {
  let t = [];
  for (;;) {
    let n = e();
    if (n == 0) break;
    t.push(xW(n, e));
  }
  for (;;) {
    let n = e() - 1;
    if (n < 0) break;
    t.push(SW(n, e));
  }
  return t.flat();
}
function Kc(e) {
  let t = [];
  for (;;) {
    let n = e(t.length);
    if (!n) break;
    t.push(n);
  }
  return t;
}
function zI(e, t, n) {
  let r = Array(e)
    .fill()
    .map(() => []);
  for (let i = 0; i < t; i++) AW(e, n).forEach((s, o) => r[o].push(s));
  return r;
}
function xW(e, t) {
  let n = 1 + t(),
    r = t(),
    i = Kc(t);
  return zI(i.length, 1 + e, t).flatMap((o, a) => {
    let [u, ...l] = o;
    return Array(i[a])
      .fill()
      .map((c, d) => {
        let f = d * r;
        return [u + d * n, l.map((p) => p + f)];
      });
  });
}
function SW(e, t) {
  let n = 1 + t();
  return zI(n, 1 + e, t).map((i) => [i[0], i.slice(1)]);
}
function CW(e) {
  let t = [],
    n = Vc(e);
  return i(r([]), []), t;
  function r(s) {
    let o = e(),
      a = Kc(() => {
        let u = Vc(e).map((l) => n[l]);
        if (u.length) return r(u);
      });
    return { S: o, B: a, Q: s };
  }
  function i({ S: s, B: o }, a, u) {
    if (!(s & 4 && u === a[a.length - 1])) {
      s & 2 && (u = a[a.length - 1]), s & 1 && t.push(a);
      for (let l of o) for (let c of l.Q) i(l, [...a, c], u);
    }
  }
}
function TW(e) {
  return e.toString(16).toUpperCase().padStart(2, "0");
}
function GI(e) {
  return `{${TW(e)}}`;
}
function IW(e) {
  let t = [];
  for (let n = 0, r = e.length; n < r; ) {
    let i = e.codePointAt(n);
    (n += i < 65536 ? 1 : 2), t.push(i);
  }
  return t;
}
function Da(e) {
  let n = e.length;
  if (n < 4096) return String.fromCodePoint(...e);
  let r = [];
  for (let i = 0; i < n; )
    r.push(String.fromCodePoint(...e.slice(i, (i += 4096))));
  return r.join("");
}
function kW(e, t) {
  let n = e.length,
    r = n - t.length;
  for (let i = 0; r == 0 && i < n; i++) r = e[i] - t[i];
  return r;
}
var PW =
  "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
const Zc = 44032,
  ph = 4352,
  mh = 4449,
  yh = 4519,
  qI = 19,
  WI = 21,
  Oa = 28,
  gh = WI * Oa,
  DW = qI * gh,
  OW = Zc + DW,
  RW = ph + qI,
  BW = mh + WI,
  NW = yh + Oa;
function xu(e) {
  return (e >> 24) & 255;
}
function QI(e) {
  return e & 16777215;
}
let Rg, v2, Bg, Nd;
function MW() {
  let e = UI(PW);
  (Rg = new Map($I(e).flatMap((t, n) => t.map((r) => [r, (n + 1) << 24])))),
    (v2 = new Set(Vc(e))),
    (Bg = new Map()),
    (Nd = new Map());
  for (let [t, n] of HI(e)) {
    if (!v2.has(t) && n.length == 2) {
      let [r, i] = n,
        s = Nd.get(r);
      s || ((s = new Map()), Nd.set(r, s)), s.set(i, t);
    }
    Bg.set(t, n.reverse());
  }
}
function VI(e) {
  return e >= Zc && e < OW;
}
function LW(e, t) {
  if (e >= ph && e < RW && t >= mh && t < BW)
    return Zc + (e - ph) * gh + (t - mh) * Oa;
  if (VI(e) && t > yh && t < NW && (e - Zc) % Oa == 0) return e + (t - yh);
  {
    let n = Nd.get(e);
    return n && ((n = n.get(t)), n) ? n : -1;
  }
}
function KI(e) {
  Rg || MW();
  let t = [],
    n = [],
    r = !1;
  function i(s) {
    let o = Rg.get(s);
    o && ((r = !0), (s |= o)), t.push(s);
  }
  for (let s of e)
    for (;;) {
      if (s < 128) t.push(s);
      else if (VI(s)) {
        let o = s - Zc,
          a = (o / gh) | 0,
          u = ((o % gh) / Oa) | 0,
          l = o % Oa;
        i(ph + a), i(mh + u), l > 0 && i(yh + l);
      } else {
        let o = Bg.get(s);
        o ? n.push(...o) : i(s);
      }
      if (!n.length) break;
      s = n.pop();
    }
  if (r && t.length > 1) {
    let s = xu(t[0]);
    for (let o = 1; o < t.length; o++) {
      let a = xu(t[o]);
      if (a == 0 || s <= a) {
        s = a;
        continue;
      }
      let u = o - 1;
      for (;;) {
        let l = t[u + 1];
        if (((t[u + 1] = t[u]), (t[u] = l), !u || ((s = xu(t[--u])), s <= a)))
          break;
      }
      s = xu(t[o]);
    }
  }
  return t;
}
function FW(e) {
  let t = [],
    n = [],
    r = -1,
    i = 0;
  for (let s of e) {
    let o = xu(s),
      a = QI(s);
    if (r == -1) o == 0 ? (r = a) : t.push(a);
    else if (i > 0 && i >= o)
      o == 0 ? (t.push(r, ...n), (n.length = 0), (r = a)) : n.push(a), (i = o);
    else {
      let u = LW(r, a);
      u >= 0
        ? (r = u)
        : i == 0 && o == 0
        ? (t.push(r), (r = a))
        : (n.push(a), (i = o));
    }
  }
  return r >= 0 && t.push(r, ...n), t;
}
function ZI(e) {
  return KI(e).map(QI);
}
function jW(e) {
  return FW(KI(e));
}
const b2 = 45,
  JI = ".",
  YI = 65039,
  XI = 1,
  Ko = (e) => Array.from(e);
function Jc(e, t) {
  return e.P.has(t) || e.Q.has(t);
}
class UW extends Array {
  get is_emoji() {
    return !0;
  }
}
let Ng, ek, Fs, Mg, tk, ca, r0, Ro, nk, w2, Lg;
function Sw() {
  if (Ng) return;
  let e = UI(vW);
  const t = () => Vc(e),
    n = () => new Set(t());
  (Ng = new Map(HI(e))),
    (ek = n()),
    (Fs = t()),
    (Mg = new Set(t().map((c) => Fs[c]))),
    (Fs = new Set(Fs)),
    (tk = n()),
    n();
  let r = $I(e),
    i = e();
  const s = () =>
    new Set(
      t()
        .flatMap((c) => r[c])
        .concat(t())
    );
  (ca = Kc((c) => {
    let d = Kc(e).map((f) => f + 96);
    if (d.length) {
      let f = c >= i;
      (d[0] -= 32), (d = Da(d)), f && (d = `Restricted[${d}]`);
      let p = s(),
        m = s(),
        g = !e();
      return { N: d, P: p, Q: m, M: g, R: f };
    }
  })),
    (r0 = n()),
    (Ro = new Map());
  let o = t()
    .concat(Ko(r0))
    .sort((c, d) => c - d);
  o.forEach((c, d) => {
    let f = e(),
      p = (o[d] = f ? o[d - f] : { V: [], M: new Map() });
    p.V.push(c), r0.has(c) || Ro.set(c, p);
  });
  for (let { V: c, M: d } of new Set(Ro.values())) {
    let f = [];
    for (let m of c) {
      let g = ca.filter((v) => Jc(v, m)),
        w = f.find(({ G: v }) => g.some((y) => v.has(y)));
      w || ((w = { G: new Set(), V: [] }), f.push(w)),
        w.V.push(m),
        g.forEach((v) => w.G.add(v));
    }
    let p = f.flatMap((m) => Ko(m.G));
    for (let { G: m, V: g } of f) {
      let w = new Set(p.filter((v) => !m.has(v)));
      for (let v of g) d.set(v, w);
    }
  }
  let a = new Set(),
    u = new Set();
  const l = (c) => (a.has(c) ? u.add(c) : a.add(c));
  for (let c of ca) {
    for (let d of c.P) l(d);
    for (let d of c.Q) l(d);
  }
  for (let c of a) !Ro.has(c) && !u.has(c) && Ro.set(c, XI);
  (nk = new Set(Ko(a).concat(Ko(ZI(a))))),
    (w2 = CW(e)
      .map((c) => UW.from(c))
      .sort(kW)),
    (Lg = new Map());
  for (let c of w2) {
    let d = [Lg];
    for (let f of c) {
      let p = d.map((m) => {
        let g = m.get(f);
        return g || ((g = new Map()), m.set(f, g)), g;
      });
      f === YI ? d.push(...p) : (d = p);
    }
    for (let f of d) f.V = c;
  }
}
function Cw(e) {
  return (rk(e) ? "" : `${Tw(Mp([e]))} `) + GI(e);
}
function Tw(e) {
  return `"${e}"`;
}
function $W(e) {
  if (e.length >= 4 && e[2] == b2 && e[3] == b2)
    throw new Error(`invalid label extension: "${Da(e.slice(0, 4))}"`);
}
function HW(e) {
  for (let n = e.lastIndexOf(95); n > 0; )
    if (e[--n] !== 95) throw new Error("underscore allowed only at start");
}
function zW(e) {
  let t = e[0],
    n = y2.get(t);
  if (n) throw Gu(`leading ${n}`);
  let r = e.length,
    i = -1;
  for (let s = 1; s < r; s++) {
    t = e[s];
    let o = y2.get(t);
    if (o) {
      if (i == s) throw Gu(`${n} + ${o}`);
      (i = s + 1), (n = o);
    }
  }
  if (i == r) throw Gu(`trailing ${n}`);
}
function Mp(e, t = GI) {
  let n = [];
  GW(e[0]) && n.push("");
  let r = 0,
    i = e.length;
  for (let s = 0; s < i; s++) {
    let o = e[s];
    rk(o) && (n.push(Da(e.slice(r, s))), n.push(t(o)), (r = s + 1));
  }
  return n.push(Da(e.slice(r, i))), n.join("");
}
function GW(e) {
  return Sw(), Fs.has(e);
}
function rk(e) {
  return Sw(), tk.has(e);
}
function qW(e) {
  return KW(WW(e, jW, YW));
}
function WW(e, t, n) {
  if (!e) return [];
  Sw();
  let r = 0;
  return e.split(JI).map((i) => {
    let s = IW(i),
      o = { input: s, offset: r };
    r += s.length + 1;
    try {
      let a = (o.tokens = JW(s, t, n)),
        u = a.length,
        l;
      if (!u) throw new Error("empty label");
      let c = (o.output = a.flat());
      if (
        (HW(c), !(o.emoji = u > 1 || a[0].is_emoji) && c.every((f) => f < 128))
      )
        $W(c), (l = "ASCII");
      else {
        let f = a.flatMap((p) => (p.is_emoji ? [] : p));
        if (!f.length) l = "Emoji";
        else {
          if (Fs.has(c[0])) throw Gu("leading combining mark");
          for (let g = 1; g < u; g++) {
            let w = a[g];
            if (!w.is_emoji && Fs.has(w[0]))
              throw Gu(
                `emoji + combining mark: "${Da(a[g - 1])} + ${Mp([w[0]])}"`
              );
          }
          zW(c);
          let p = Ko(new Set(f)),
            [m] = VW(p);
          ZW(m, f), QW(m, p), (l = m.N);
        }
      }
      o.type = l;
    } catch (a) {
      o.error = a;
    }
    return o;
  });
}
function QW(e, t) {
  let n,
    r = [];
  for (let i of t) {
    let s = Ro.get(i);
    if (s === XI) return;
    if (s) {
      let o = s.M.get(i);
      if (((n = n ? n.filter((a) => o.has(a)) : Ko(o)), !n.length)) return;
    } else r.push(i);
  }
  if (n) {
    for (let i of n)
      if (r.every((s) => Jc(i, s)))
        throw new Error(`whole-script confusable: ${e.N}/${i.N}`);
  }
}
function VW(e) {
  let t = ca;
  for (let n of e) {
    let r = t.filter((i) => Jc(i, n));
    if (!r.length) throw ca.some((i) => Jc(i, n)) ? sk(t[0], n) : ik(n);
    if (((t = r), r.length == 1)) break;
  }
  return t;
}
function KW(e) {
  return e
    .map(({ input: t, error: n, output: r }) => {
      if (n) {
        let i = n.message;
        throw new Error(e.length == 1 ? i : `Invalid label ${Tw(Mp(t))}: ${i}`);
      }
      return Da(r);
    })
    .join(JI);
}
function ik(e) {
  return new Error(`disallowed character: ${Cw(e)}`);
}
function sk(e, t) {
  let n = Cw(t),
    r = ca.find((i) => i.P.has(t));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${e.N} + ${n}`);
}
function Gu(e) {
  return new Error(`illegal placement: ${e}`);
}
function ZW(e, t) {
  for (let n of t) if (!Jc(e, n)) throw sk(e, n);
  if (e.M) {
    let n = ZI(t);
    for (let r = 1, i = n.length; r < i; r++)
      if (Mg.has(n[r])) {
        let s = r + 1;
        for (let o; s < i && Mg.has((o = n[s])); s++)
          for (let a = r; a < s; a++)
            if (n[a] == o)
              throw new Error(`duplicate non-spacing marks: ${Cw(o)}`);
        if (s - r > g2)
          throw new Error(
            `excessive non-spacing marks: ${Tw(Mp(n.slice(r - 1, s)))} (${
              s - r
            }/${g2})`
          );
        r = s;
      }
  }
}
function JW(e, t, n) {
  let r = [],
    i = [];
  for (e = e.slice().reverse(); e.length; ) {
    let s = XW(e);
    if (s) i.length && (r.push(t(i)), (i = [])), r.push(n(s));
    else {
      let o = e.pop();
      if (nk.has(o)) i.push(o);
      else {
        let a = Ng.get(o);
        if (a) i.push(...a);
        else if (!ek.has(o)) throw ik(o);
      }
    }
  }
  return i.length && r.push(t(i)), r;
}
function YW(e) {
  return e.filter((t) => t != YI);
}
function XW(e, t) {
  let n = Lg,
    r,
    i = e.length;
  for (; i && ((n = n.get(e[--i])), !!n); ) {
    let { V: s } = n;
    s && ((r = s), t && t.push(...e.slice(i).reverse()), (e.length = i));
  }
  return r;
}
const eQ = (e) => qW(e),
  js = (e) => {
    let t = "";
    for (let n = 0; n < 32; n += 1) t += "00";
    if (e) {
      const r = eQ(e).split(".");
      for (let i = r.length - 1; i >= 0; i -= 1) {
        const s = On(r[i]).slice(2);
        t = On(`0x${t}${s}`).slice(2);
      }
    }
    return `0x${t}`;
  };
var rd = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class tQ {
  constructor(t, n) {
    (this.contract = new Qs(yW, n ?? hh.main, t)), (this.context = t);
  }
  getOwner(t) {
    return rd(this, void 0, void 0, function* () {
      try {
        return this.contract.methods.owner(js(t)).call();
      } catch {
        throw new Error();
      }
    });
  }
  getTTL(t) {
    return rd(this, void 0, void 0, function* () {
      try {
        return this.contract.methods.ttl(js(t)).call();
      } catch {
        throw new Error();
      }
    });
  }
  recordExists(t) {
    return rd(this, void 0, void 0, function* () {
      try {
        return this.contract.methods.recordExists(js(t)).call();
      } catch {
        throw new Error();
      }
    });
  }
  getResolver(t) {
    return rd(this, void 0, void 0, function* () {
      try {
        return this.contract.methods
          .resolver(js(t))
          .call()
          .then((n) => {
            if (typeof n == "string") return new Qs(gW, n, this.context);
            throw new Error();
          });
      } catch {
        throw new Error();
      }
    });
  }
  get events() {
    return this.contract.events;
  }
}
var To = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class nQ {
  constructor(t) {
    this.registry = t;
  }
  getResolverContractAdapter(t) {
    return To(this, void 0, void 0, function* () {
      return this.registry.getResolver(t);
    });
  }
  checkInterfaceSupport(t, n) {
    var r, i;
    return To(this, void 0, void 0, function* () {
      if (ce(m2[n]))
        throw new y_(
          (r = t.options.address) !== null && r !== void 0 ? r : "",
          n
        );
      if (!(yield t.methods.supportsInterface(m2[n]).call()))
        throw new y_(
          (i = t.options.address) !== null && i !== void 0 ? i : "",
          n
        );
    });
  }
  supportsInterface(t, n) {
    var r;
    return To(this, void 0, void 0, function* () {
      const i = yield this.getResolverContractAdapter(t);
      let s = n;
      if (!De(s)) {
        if (((s = (r = wl(n)) !== null && r !== void 0 ? r : ""), n === ""))
          throw new Error("Invalid interface Id");
        s = s.slice(0, 10);
      }
      return i.methods.supportsInterface(s).call();
    });
  }
  getAddress(t, n = 60) {
    return To(this, void 0, void 0, function* () {
      const r = yield this.getResolverContractAdapter(t);
      return (
        yield this.checkInterfaceSupport(r, n0.addr),
        r.methods.addr(js(t), n).call()
      );
    });
  }
  getPubkey(t) {
    return To(this, void 0, void 0, function* () {
      const n = yield this.getResolverContractAdapter(t);
      return (
        yield this.checkInterfaceSupport(n, n0.pubkey),
        n.methods.pubkey(js(t)).call()
      );
    });
  }
  getContenthash(t) {
    return To(this, void 0, void 0, function* () {
      const n = yield this.getResolverContractAdapter(t);
      return (
        yield this.checkInterfaceSupport(n, n0.contenthash),
        n.methods.contenthash(js(t)).call()
      );
    });
  }
}
var Hr = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class ok extends gn {
  constructor(t, n) {
    super(n ?? ""),
      (this.registryAddress = t ?? hh.main),
      (this._registry = new tQ(this.getContextObject(), t)),
      (this._resolver = new nQ(this._registry));
  }
  getResolver(t) {
    return Hr(this, void 0, void 0, function* () {
      return this._registry.getResolver(t);
    });
  }
  recordExists(t) {
    return Hr(this, void 0, void 0, function* () {
      return this._registry.recordExists(t);
    });
  }
  getTTL(t) {
    return Hr(this, void 0, void 0, function* () {
      return this._registry.getTTL(t);
    });
  }
  getOwner(t) {
    return Hr(this, void 0, void 0, function* () {
      return this._registry.getOwner(t);
    });
  }
  getAddress(t, n = 60) {
    return Hr(this, void 0, void 0, function* () {
      return this._resolver.getAddress(t, n);
    });
  }
  getPubkey(t) {
    return Hr(this, void 0, void 0, function* () {
      return this._resolver.getPubkey(t);
    });
  }
  getContenthash(t) {
    return Hr(this, void 0, void 0, function* () {
      return this._resolver.getContenthash(t);
    });
  }
  checkNetwork() {
    return Hr(this, void 0, void 0, function* () {
      const t = Date.now() / 1e3;
      if (!this._lastSyncCheck || t - this._lastSyncCheck > 3600) {
        const i = yield Lq(this);
        if (!(typeof i == "boolean" && !i)) throw new Pj();
        this._lastSyncCheck = t;
      }
      if (this._detectedAddress) return this._detectedAddress;
      const n = yield pw(
          this,
          Object.assign(Object.assign({}, Y), { number: Kn.HEX })
        ),
        r = hh[mW[n]];
      if (typeof r > "u") throw new kj(n);
      return (this._detectedAddress = r), this._detectedAddress;
    });
  }
  supportsInterface(t, n) {
    return Hr(this, void 0, void 0, function* () {
      return this._resolver.supportsInterface(t, n);
    });
  }
  get events() {
    return this._registry.events;
  }
}
var Ei = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const rQ = (e) =>
    Ei(void 0, void 0, void 0, function* () {
      return (yield vG(e)).map(Lr);
    }),
  iQ = (e, t) =>
    Ei(void 0, void 0, void 0, function* () {
      ie.validate(["string"], [t]);
      const n = yield bG(e, t);
      return Lr(n);
    }),
  sQ = (e, t, n, r) =>
    Ei(void 0, void 0, void 0, function* () {
      return (
        ie.validate(["address", "string", "uint"], [t, n, r]), wG(e, t, n, r)
      );
    }),
  oQ = (e, t) =>
    Ei(void 0, void 0, void 0, function* () {
      return ie.validate(["address"], [t]), EG(e, t);
    }),
  aQ = (e, t, n) =>
    Ei(void 0, void 0, void 0, function* () {
      return ie.validate(["string", "string"], [t, n]), _G(e, t, n);
    }),
  uQ = (e, t, n) =>
    Ei(void 0, void 0, void 0, function* () {
      const r = _n(t, ae);
      return AG(e, r, n);
    }),
  cQ = (e, t, n) =>
    Ei(void 0, void 0, void 0, function* () {
      const r = _n(t, ae);
      return xG(e, r, n);
    }),
  lQ = (e, t, n, r) =>
    Ei(void 0, void 0, void 0, function* () {
      ie.validate(["string", "address", "string"], [t, n, r]);
      const i = De(t) ? t : yr(t);
      return SG(e, i, n, r);
    }),
  dQ = (e, t, n) =>
    Ei(void 0, void 0, void 0, function* () {
      ie.validate(["string", "string"], [t, n]);
      const r = De(t) ? t : yr(t);
      return CG(e, r, n);
    });
var zr = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
class ak extends gn {
  getAccounts() {
    return zr(this, void 0, void 0, function* () {
      return rQ(this.requestManager);
    });
  }
  newAccount(t) {
    return zr(this, void 0, void 0, function* () {
      return iQ(this.requestManager, t);
    });
  }
  unlockAccount(t, n, r) {
    return zr(this, void 0, void 0, function* () {
      return sQ(this.requestManager, t, n, r);
    });
  }
  lockAccount(t) {
    return zr(this, void 0, void 0, function* () {
      return oQ(this.requestManager, t);
    });
  }
  importRawKey(t, n) {
    return zr(this, void 0, void 0, function* () {
      return aQ(this.requestManager, t, n);
    });
  }
  sendTransaction(t, n) {
    return zr(this, void 0, void 0, function* () {
      return uQ(this.requestManager, t, n);
    });
  }
  signTransaction(t, n) {
    return zr(this, void 0, void 0, function* () {
      return cQ(this.requestManager, t, n);
    });
  }
  sign(t, n, r) {
    return zr(this, void 0, void 0, function* () {
      return lQ(this.requestManager, t, n, r);
    });
  }
  ecRecover(t, n) {
    return zr(this, void 0, void 0, function* () {
      return dQ(this.requestManager, t, n);
    });
  }
}
const fQ = {
  encodeEventSignature: vw,
  encodeFunctionCall: Dq,
  encodeFunctionSignature: Rp,
  encodeParameter: Pg,
  encodeParameters: Dp,
  decodeParameter: SI,
  decodeParameters: Op,
  decodeLog: CI,
};
var hu = function (e, t, n, r) {
  function i(s) {
    return s instanceof n
      ? s
      : new n(function (o) {
          o(s);
        });
  }
  return new (n || (n = Promise))(function (s, o) {
    function a(c) {
      try {
        l(r.next(c));
      } catch (d) {
        o(d);
      }
    }
    function u(c) {
      try {
        l(r.throw(c));
      } catch (d) {
        o(d);
      }
    }
    function l(c) {
      c.done ? s(c.value) : i(c.value).then(a, u);
    }
    l((r = r.apply(e, t || [])).next());
  });
};
const hQ = (e) => {
    const t = (o, a) =>
        hu(void 0, void 0, void 0, function* () {
          const u = yield cW(o, e),
            l = $({ format: "bytes" }, a, ae);
          return Az(u, l);
        }),
      n = (o) => {
        const a = lw(o);
        return Object.assign(Object.assign({}, a), {
          signTransaction: (u) =>
            hu(void 0, void 0, void 0, function* () {
              return t(u, a.privateKey);
            }),
        });
      },
      r = (o, a, u) =>
        hu(void 0, void 0, void 0, function* () {
          var l;
          const c = yield Tz(
            o,
            a,
            (l = u == null ? void 0 : u.nonStrict) !== null && l !== void 0
              ? l
              : !0
          );
          return Object.assign(Object.assign({}, c), {
            signTransaction: (d) =>
              hu(void 0, void 0, void 0, function* () {
                return t(d, c.privateKey);
              }),
          });
        }),
      i = () => {
        const o = Cz();
        return Object.assign(Object.assign({}, o), {
          signTransaction: (a) =>
            hu(void 0, void 0, void 0, function* () {
              return t(a, o.privateKey);
            }),
        });
      },
      s = new ih({ create: i, privateKeyToAccount: n, decrypt: r });
    return {
      signTransaction: t,
      create: i,
      privateKeyToAccount: n,
      decrypt: r,
      recoverTransaction: xz,
      hashMessage: cw,
      sign: qT,
      recover: Eg,
      encrypt: WT,
      wallet: s,
      privateKeyToAddress: Cp,
      parseAndValidatePrivateKey: Wa,
      privateKeyToPublicKey: Sz,
    };
  },
  pQ = { version: "4.3.0" };
class Lp extends gn {
  constructor(t) {
    var n;
    (ce(t) ||
      (typeof t == "string" && t.trim() === "") ||
      (typeof t != "string" && !rh(t) && !t.provider)) &&
      console.warn(
        "NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!"
      );
    let r = {};
    typeof t == "string" || rh(t) ? (r.provider = t) : t ? (r = t) : (r = {}),
      (r.registeredSubscriptions = Object.assign(
        Object.assign({}, Og),
        (n = r.registeredSubscriptions) !== null && n !== void 0 ? n : {}
      )),
      super(r);
    const i = hQ(this);
    (this._wallet = i.wallet), (this._accountProvider = i), (this.utils = dT);
    const s = this;
    class o extends Qs {
      constructor(l, c, d, f, p) {
        if ($i(c) && $i(d))
          throw new g_(
            "Should not provide options at both 2nd and 3rd parameters"
          );
        let m,
          g = {},
          w,
          v = Y;
        if (!ce(c) && typeof c != "object" && typeof c != "string")
          throw new g_();
        typeof c == "string" && (m = c),
          $i(c) ? (g = c) : $i(d) ? (g = d) : (g = {}),
          c instanceof gn
            ? (w = c)
            : d instanceof gn
            ? (w = d)
            : f instanceof gn
            ? (w = f)
            : (w = s.getContextObject()),
          p ? (v = p) : Qr(d) ? (v = d) : Qr(f) && (v = f),
          super(l, m, g, w, v),
          super.subscribeToContextEvents(s);
      }
    }
    const a = s.use(Bp);
    this.eth = Object.assign(a, {
      ens: s.use(ok, hh.main),
      Iban: at,
      net: s.use(XT),
      personal: s.use(ak),
      Contract: o,
      abi: fQ,
      accounts: i,
    });
  }
}
Lp.version = pQ.version;
Lp.utils = dT;
Lp.modules = { Web3Eth: Bp, Iban: at, Net: XT, ENS: ok, Personal: ak };
function uk(e, t) {
  return function () {
    return e.apply(t, arguments);
  };
}
const { toString: mQ } = Object.prototype,
  { getPrototypeOf: Iw } = Object,
  Fp = ((e) => (t) => {
    const n = mQ.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
  })(Object.create(null)),
  Fr = (e) => ((e = e.toLowerCase()), (t) => Fp(t) === e),
  jp = (e) => (t) => typeof t === e,
  { isArray: Va } = Array,
  Yc = jp("undefined");
function yQ(e) {
  return (
    e !== null &&
    !Yc(e) &&
    e.constructor !== null &&
    !Yc(e.constructor) &&
    Jn(e.constructor.isBuffer) &&
    e.constructor.isBuffer(e)
  );
}
const ck = Fr("ArrayBuffer");
function gQ(e) {
  let t;
  return (
    typeof ArrayBuffer < "u" && ArrayBuffer.isView
      ? (t = ArrayBuffer.isView(e))
      : (t = e && e.buffer && ck(e.buffer)),
    t
  );
}
const vQ = jp("string"),
  Jn = jp("function"),
  lk = jp("number"),
  Up = (e) => e !== null && typeof e == "object",
  bQ = (e) => e === !0 || e === !1,
  Md = (e) => {
    if (Fp(e) !== "object") return !1;
    const t = Iw(e);
    return (
      (t === null ||
        t === Object.prototype ||
        Object.getPrototypeOf(t) === null) &&
      !(Symbol.toStringTag in e) &&
      !(Symbol.iterator in e)
    );
  },
  wQ = Fr("Date"),
  EQ = Fr("File"),
  _Q = Fr("Blob"),
  AQ = Fr("FileList"),
  xQ = (e) => Up(e) && Jn(e.pipe),
  SQ = (e) => {
    let t;
    return (
      e &&
      ((typeof FormData == "function" && e instanceof FormData) ||
        (Jn(e.append) &&
          ((t = Fp(e)) === "formdata" ||
            (t === "object" &&
              Jn(e.toString) &&
              e.toString() === "[object FormData]"))))
    );
  },
  CQ = Fr("URLSearchParams"),
  TQ = (e) =>
    e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function xl(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u") return;
  let r, i;
  if ((typeof e != "object" && (e = [e]), Va(e)))
    for (r = 0, i = e.length; r < i; r++) t.call(null, e[r], r, e);
  else {
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e),
      o = s.length;
    let a;
    for (r = 0; r < o; r++) (a = s[r]), t.call(null, e[a], a, e);
  }
}
function dk(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length,
    i;
  for (; r-- > 0; ) if (((i = n[r]), t === i.toLowerCase())) return i;
  return null;
}
const fk =
    typeof globalThis < "u"
      ? globalThis
      : typeof self < "u"
      ? self
      : typeof window < "u"
      ? window
      : global,
  hk = (e) => !Yc(e) && e !== fk;
function Fg() {
  const { caseless: e } = (hk(this) && this) || {},
    t = {},
    n = (r, i) => {
      const s = (e && dk(t, i)) || i;
      Md(t[s]) && Md(r)
        ? (t[s] = Fg(t[s], r))
        : Md(r)
        ? (t[s] = Fg({}, r))
        : Va(r)
        ? (t[s] = r.slice())
        : (t[s] = r);
    };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && xl(arguments[r], n);
  return t;
}
const IQ = (e, t, n, { allOwnKeys: r } = {}) => (
    xl(
      t,
      (i, s) => {
        n && Jn(i) ? (e[s] = uk(i, n)) : (e[s] = i);
      },
      { allOwnKeys: r }
    ),
    e
  ),
  kQ = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e),
  PQ = (e, t, n, r) => {
    (e.prototype = Object.create(t.prototype, r)),
      (e.prototype.constructor = e),
      Object.defineProperty(e, "super", { value: t.prototype }),
      n && Object.assign(e.prototype, n);
  },
  DQ = (e, t, n, r) => {
    let i, s, o;
    const a = {};
    if (((t = t || {}), e == null)) return t;
    do {
      for (i = Object.getOwnPropertyNames(e), s = i.length; s-- > 0; )
        (o = i[s]), (!r || r(o, e, t)) && !a[o] && ((t[o] = e[o]), (a[o] = !0));
      e = n !== !1 && Iw(e);
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t;
  },
  OQ = (e, t, n) => {
    (e = String(e)),
      (n === void 0 || n > e.length) && (n = e.length),
      (n -= t.length);
    const r = e.indexOf(t, n);
    return r !== -1 && r === n;
  },
  RQ = (e) => {
    if (!e) return null;
    if (Va(e)) return e;
    let t = e.length;
    if (!lk(t)) return null;
    const n = new Array(t);
    for (; t-- > 0; ) n[t] = e[t];
    return n;
  },
  BQ = (
    (e) => (t) =>
      e && t instanceof e
  )(typeof Uint8Array < "u" && Iw(Uint8Array)),
  NQ = (e, t) => {
    const r = (e && e[Symbol.iterator]).call(e);
    let i;
    for (; (i = r.next()) && !i.done; ) {
      const s = i.value;
      t.call(e, s[0], s[1]);
    }
  },
  MQ = (e, t) => {
    let n;
    const r = [];
    for (; (n = e.exec(t)) !== null; ) r.push(n);
    return r;
  },
  LQ = Fr("HTMLFormElement"),
  FQ = (e) =>
    e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) {
      return r.toUpperCase() + i;
    }),
  E2 = (
    ({ hasOwnProperty: e }) =>
    (t, n) =>
      e.call(t, n)
  )(Object.prototype),
  jQ = Fr("RegExp"),
  pk = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e),
      r = {};
    xl(n, (i, s) => {
      let o;
      (o = t(i, s, e)) !== !1 && (r[s] = o || i);
    }),
      Object.defineProperties(e, r);
  },
  UQ = (e) => {
    pk(e, (t, n) => {
      if (Jn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
        return !1;
      const r = e[n];
      if (Jn(r)) {
        if (((t.enumerable = !1), "writable" in t)) {
          t.writable = !1;
          return;
        }
        t.set ||
          (t.set = () => {
            throw Error("Can not rewrite read-only method '" + n + "'");
          });
      }
    });
  },
  $Q = (e, t) => {
    const n = {},
      r = (i) => {
        i.forEach((s) => {
          n[s] = !0;
        });
      };
    return Va(e) ? r(e) : r(String(e).split(t)), n;
  },
  HQ = () => {},
  zQ = (e, t) => ((e = +e), Number.isFinite(e) ? e : t),
  i0 = "abcdefghijklmnopqrstuvwxyz",
  _2 = "0123456789",
  mk = { DIGIT: _2, ALPHA: i0, ALPHA_DIGIT: i0 + i0.toUpperCase() + _2 },
  GQ = (e = 16, t = mk.ALPHA_DIGIT) => {
    let n = "";
    const { length: r } = t;
    for (; e--; ) n += t[(Math.random() * r) | 0];
    return n;
  };
function qQ(e) {
  return !!(
    e &&
    Jn(e.append) &&
    e[Symbol.toStringTag] === "FormData" &&
    e[Symbol.iterator]
  );
}
const WQ = (e) => {
    const t = new Array(10),
      n = (r, i) => {
        if (Up(r)) {
          if (t.indexOf(r) >= 0) return;
          if (!("toJSON" in r)) {
            t[i] = r;
            const s = Va(r) ? [] : {};
            return (
              xl(r, (o, a) => {
                const u = n(o, i + 1);
                !Yc(u) && (s[a] = u);
              }),
              (t[i] = void 0),
              s
            );
          }
        }
        return r;
      };
    return n(e, 0);
  },
  QQ = Fr("AsyncFunction"),
  VQ = (e) => e && (Up(e) || Jn(e)) && Jn(e.then) && Jn(e.catch),
  F = {
    isArray: Va,
    isArrayBuffer: ck,
    isBuffer: yQ,
    isFormData: SQ,
    isArrayBufferView: gQ,
    isString: vQ,
    isNumber: lk,
    isBoolean: bQ,
    isObject: Up,
    isPlainObject: Md,
    isUndefined: Yc,
    isDate: wQ,
    isFile: EQ,
    isBlob: _Q,
    isRegExp: jQ,
    isFunction: Jn,
    isStream: xQ,
    isURLSearchParams: CQ,
    isTypedArray: BQ,
    isFileList: AQ,
    forEach: xl,
    merge: Fg,
    extend: IQ,
    trim: TQ,
    stripBOM: kQ,
    inherits: PQ,
    toFlatObject: DQ,
    kindOf: Fp,
    kindOfTest: Fr,
    endsWith: OQ,
    toArray: RQ,
    forEachEntry: NQ,
    matchAll: MQ,
    isHTMLForm: LQ,
    hasOwnProperty: E2,
    hasOwnProp: E2,
    reduceDescriptors: pk,
    freezeMethods: UQ,
    toObjectSet: $Q,
    toCamelCase: FQ,
    noop: HQ,
    toFiniteNumber: zQ,
    findKey: dk,
    global: fk,
    isContextDefined: hk,
    ALPHABET: mk,
    generateString: GQ,
    isSpecCompliantForm: qQ,
    toJSONObject: WQ,
    isAsyncFn: QQ,
    isThenable: VQ,
  };
function Se(e, t, n, r, i) {
  Error.call(this),
    Error.captureStackTrace
      ? Error.captureStackTrace(this, this.constructor)
      : (this.stack = new Error().stack),
    (this.message = e),
    (this.name = "AxiosError"),
    t && (this.code = t),
    n && (this.config = n),
    r && (this.request = r),
    i && (this.response = i);
}
F.inherits(Se, Error, {
  toJSON: function () {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: F.toJSONObject(this.config),
      code: this.code,
      status:
        this.response && this.response.status ? this.response.status : null,
    };
  },
});
const yk = Se.prototype,
  gk = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL",
].forEach((e) => {
  gk[e] = { value: e };
});
Object.defineProperties(Se, gk);
Object.defineProperty(yk, "isAxiosError", { value: !0 });
Se.from = (e, t, n, r, i, s) => {
  const o = Object.create(yk);
  return (
    F.toFlatObject(
      e,
      o,
      function (u) {
        return u !== Error.prototype;
      },
      (a) => a !== "isAxiosError"
    ),
    Se.call(o, e.message, t, n, r, i),
    (o.cause = e),
    (o.name = e.name),
    s && Object.assign(o, s),
    o
  );
};
const KQ = null;
function jg(e) {
  return F.isPlainObject(e) || F.isArray(e);
}
function vk(e) {
  return F.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function A2(e, t, n) {
  return e
    ? e
        .concat(t)
        .map(function (i, s) {
          return (i = vk(i)), !n && s ? "[" + i + "]" : i;
        })
        .join(n ? "." : "")
    : t;
}
function ZQ(e) {
  return F.isArray(e) && !e.some(jg);
}
const JQ = F.toFlatObject(F, {}, null, function (t) {
  return /^is[A-Z]/.test(t);
});
function $p(e, t, n) {
  if (!F.isObject(e)) throw new TypeError("target must be an object");
  (t = t || new FormData()),
    (n = F.toFlatObject(
      n,
      { metaTokens: !0, dots: !1, indexes: !1 },
      !1,
      function (g, w) {
        return !F.isUndefined(w[g]);
      }
    ));
  const r = n.metaTokens,
    i = n.visitor || c,
    s = n.dots,
    o = n.indexes,
    u = (n.Blob || (typeof Blob < "u" && Blob)) && F.isSpecCompliantForm(t);
  if (!F.isFunction(i)) throw new TypeError("visitor must be a function");
  function l(m) {
    if (m === null) return "";
    if (F.isDate(m)) return m.toISOString();
    if (!u && F.isBlob(m))
      throw new Se("Blob is not supported. Use a Buffer instead.");
    return F.isArrayBuffer(m) || F.isTypedArray(m)
      ? u && typeof Blob == "function"
        ? new Blob([m])
        : Buffer.from(m)
      : m;
  }
  function c(m, g, w) {
    let v = m;
    if (m && !w && typeof m == "object") {
      if (F.endsWith(g, "{}"))
        (g = r ? g : g.slice(0, -2)), (m = JSON.stringify(m));
      else if (
        (F.isArray(m) && ZQ(m)) ||
        ((F.isFileList(m) || F.endsWith(g, "[]")) && (v = F.toArray(m)))
      )
        return (
          (g = vk(g)),
          v.forEach(function (b, _) {
            !(F.isUndefined(b) || b === null) &&
              t.append(
                o === !0 ? A2([g], _, s) : o === null ? g : g + "[]",
                l(b)
              );
          }),
          !1
        );
    }
    return jg(m) ? !0 : (t.append(A2(w, g, s), l(m)), !1);
  }
  const d = [],
    f = Object.assign(JQ, {
      defaultVisitor: c,
      convertValue: l,
      isVisitable: jg,
    });
  function p(m, g) {
    if (!F.isUndefined(m)) {
      if (d.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + g.join("."));
      d.push(m),
        F.forEach(m, function (v, y) {
          (!(F.isUndefined(v) || v === null) &&
            i.call(t, v, F.isString(y) ? y.trim() : y, g, f)) === !0 &&
            p(v, g ? g.concat(y) : [y]);
        }),
        d.pop();
    }
  }
  if (!F.isObject(e)) throw new TypeError("data must be an object");
  return p(e), t;
}
function x2(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0",
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (r) {
    return t[r];
  });
}
function kw(e, t) {
  (this._pairs = []), e && $p(e, this, t);
}
const bk = kw.prototype;
bk.append = function (t, n) {
  this._pairs.push([t, n]);
};
bk.toString = function (t) {
  const n = t
    ? function (r) {
        return t.call(this, r, x2);
      }
    : x2;
  return this._pairs
    .map(function (i) {
      return n(i[0]) + "=" + n(i[1]);
    }, "")
    .join("&");
};
function YQ(e) {
  return encodeURIComponent(e)
    .replace(/%3A/gi, ":")
    .replace(/%24/g, "$")
    .replace(/%2C/gi, ",")
    .replace(/%20/g, "+")
    .replace(/%5B/gi, "[")
    .replace(/%5D/gi, "]");
}
function wk(e, t, n) {
  if (!t) return e;
  const r = (n && n.encode) || YQ,
    i = n && n.serialize;
  let s;
  if (
    (i
      ? (s = i(t, n))
      : (s = F.isURLSearchParams(t) ? t.toString() : new kw(t, n).toString(r)),
    s)
  ) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)),
      (e += (e.indexOf("?") === -1 ? "?" : "&") + s);
  }
  return e;
}
class XQ {
  constructor() {
    this.handlers = [];
  }
  use(t, n, r) {
    return (
      this.handlers.push({
        fulfilled: t,
        rejected: n,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null,
      }),
      this.handlers.length - 1
    );
  }
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  clear() {
    this.handlers && (this.handlers = []);
  }
  forEach(t) {
    F.forEach(this.handlers, function (r) {
      r !== null && t(r);
    });
  }
}
const S2 = XQ,
  Ek = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1,
  },
  eV = typeof URLSearchParams < "u" ? URLSearchParams : kw,
  tV = typeof FormData < "u" ? FormData : null,
  nV = typeof Blob < "u" ? Blob : null,
  rV = {
    isBrowser: !0,
    classes: { URLSearchParams: eV, FormData: tV, Blob: nV },
    protocols: ["http", "https", "file", "blob", "url", "data"],
  },
  _k = typeof window < "u" && typeof document < "u",
  iV = ((e) => _k && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(
    typeof navigator < "u" && navigator.product
  ),
  sV =
    typeof WorkerGlobalScope < "u" &&
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts == "function",
  oV = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        hasBrowserEnv: _k,
        hasStandardBrowserEnv: iV,
        hasStandardBrowserWebWorkerEnv: sV,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  Ir = { ...oV, ...rV };
function aV(e, t) {
  return $p(
    e,
    new Ir.classes.URLSearchParams(),
    Object.assign(
      {
        visitor: function (n, r, i, s) {
          return Ir.isNode && F.isBuffer(n)
            ? (this.append(r, n.toString("base64")), !1)
            : s.defaultVisitor.apply(this, arguments);
        },
      },
      t
    )
  );
}
function uV(e) {
  return F.matchAll(/\w+|\[(\w*)]/g, e).map((t) =>
    t[0] === "[]" ? "" : t[1] || t[0]
  );
}
function cV(e) {
  const t = {},
    n = Object.keys(e);
  let r;
  const i = n.length;
  let s;
  for (r = 0; r < i; r++) (s = n[r]), (t[s] = e[s]);
  return t;
}
function Ak(e) {
  function t(n, r, i, s) {
    let o = n[s++];
    const a = Number.isFinite(+o),
      u = s >= n.length;
    return (
      (o = !o && F.isArray(i) ? i.length : o),
      u
        ? (F.hasOwnProp(i, o) ? (i[o] = [i[o], r]) : (i[o] = r), !a)
        : ((!i[o] || !F.isObject(i[o])) && (i[o] = []),
          t(n, r, i[o], s) && F.isArray(i[o]) && (i[o] = cV(i[o])),
          !a)
    );
  }
  if (F.isFormData(e) && F.isFunction(e.entries)) {
    const n = {};
    return (
      F.forEachEntry(e, (r, i) => {
        t(uV(r), i, n, 0);
      }),
      n
    );
  }
  return null;
}
function lV(e, t, n) {
  if (F.isString(e))
    try {
      return (t || JSON.parse)(e), F.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError") throw r;
    }
  return (n || JSON.stringify)(e);
}
const Pw = {
  transitional: Ek,
  adapter: ["xhr", "http"],
  transformRequest: [
    function (t, n) {
      const r = n.getContentType() || "",
        i = r.indexOf("application/json") > -1,
        s = F.isObject(t);
      if ((s && F.isHTMLForm(t) && (t = new FormData(t)), F.isFormData(t)))
        return i && i ? JSON.stringify(Ak(t)) : t;
      if (
        F.isArrayBuffer(t) ||
        F.isBuffer(t) ||
        F.isStream(t) ||
        F.isFile(t) ||
        F.isBlob(t)
      )
        return t;
      if (F.isArrayBufferView(t)) return t.buffer;
      if (F.isURLSearchParams(t))
        return (
          n.setContentType(
            "application/x-www-form-urlencoded;charset=utf-8",
            !1
          ),
          t.toString()
        );
      let a;
      if (s) {
        if (r.indexOf("application/x-www-form-urlencoded") > -1)
          return aV(t, this.formSerializer).toString();
        if ((a = F.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
          const u = this.env && this.env.FormData;
          return $p(
            a ? { "files[]": t } : t,
            u && new u(),
            this.formSerializer
          );
        }
      }
      return s || i ? (n.setContentType("application/json", !1), lV(t)) : t;
    },
  ],
  transformResponse: [
    function (t) {
      const n = this.transitional || Pw.transitional,
        r = n && n.forcedJSONParsing,
        i = this.responseType === "json";
      if (t && F.isString(t) && ((r && !this.responseType) || i)) {
        const o = !(n && n.silentJSONParsing) && i;
        try {
          return JSON.parse(t);
        } catch (a) {
          if (o)
            throw a.name === "SyntaxError"
              ? Se.from(a, Se.ERR_BAD_RESPONSE, this, null, this.response)
              : a;
        }
      }
      return t;
    },
  ],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: { FormData: Ir.classes.FormData, Blob: Ir.classes.Blob },
  validateStatus: function (t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0,
    },
  },
};
F.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Pw.headers[e] = {};
});
const Dw = Pw,
  dV = F.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent",
  ]),
  fV = (e) => {
    const t = {};
    let n, r, i;
    return (
      e &&
        e
          .split(
            `
`
          )
          .forEach(function (o) {
            (i = o.indexOf(":")),
              (n = o.substring(0, i).trim().toLowerCase()),
              (r = o.substring(i + 1).trim()),
              !(!n || (t[n] && dV[n])) &&
                (n === "set-cookie"
                  ? t[n]
                    ? t[n].push(r)
                    : (t[n] = [r])
                  : (t[n] = t[n] ? t[n] + ", " + r : r));
          }),
      t
    );
  },
  C2 = Symbol("internals");
function pu(e) {
  return e && String(e).trim().toLowerCase();
}
function Ld(e) {
  return e === !1 || e == null ? e : F.isArray(e) ? e.map(Ld) : String(e);
}
function hV(e) {
  const t = Object.create(null),
    n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; (r = n.exec(e)); ) t[r[1]] = r[2];
  return t;
}
const pV = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function s0(e, t, n, r, i) {
  if (F.isFunction(r)) return r.call(this, t, n);
  if ((i && (t = n), !!F.isString(t))) {
    if (F.isString(r)) return t.indexOf(r) !== -1;
    if (F.isRegExp(r)) return r.test(t);
  }
}
function mV(e) {
  return e
    .trim()
    .toLowerCase()
    .replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function yV(e, t) {
  const n = F.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function (i, s, o) {
        return this[r].call(this, t, i, s, o);
      },
      configurable: !0,
    });
  });
}
class Hp {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function s(a, u, l) {
      const c = pu(u);
      if (!c) throw new Error("header name must be a non-empty string");
      const d = F.findKey(i, c);
      (!d || i[d] === void 0 || l === !0 || (l === void 0 && i[d] !== !1)) &&
        (i[d || u] = Ld(a));
    }
    const o = (a, u) => F.forEach(a, (l, c) => s(l, c, u));
    return (
      F.isPlainObject(t) || t instanceof this.constructor
        ? o(t, n)
        : F.isString(t) && (t = t.trim()) && !pV(t)
        ? o(fV(t), n)
        : t != null && s(n, t, r),
      this
    );
  }
  get(t, n) {
    if (((t = pu(t)), t)) {
      const r = F.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n) return i;
        if (n === !0) return hV(i);
        if (F.isFunction(n)) return n.call(this, i, r);
        if (F.isRegExp(n)) return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (((t = pu(t)), t)) {
      const r = F.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || s0(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function s(o) {
      if (((o = pu(o)), o)) {
        const a = F.findKey(r, o);
        a && (!n || s0(r, r[a], a, n)) && (delete r[a], (i = !0));
      }
    }
    return F.isArray(t) ? t.forEach(s) : s(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length,
      i = !1;
    for (; r--; ) {
      const s = n[r];
      (!t || s0(this, this[s], s, t, !0)) && (delete this[s], (i = !0));
    }
    return i;
  }
  normalize(t) {
    const n = this,
      r = {};
    return (
      F.forEach(this, (i, s) => {
        const o = F.findKey(r, s);
        if (o) {
          (n[o] = Ld(i)), delete n[s];
          return;
        }
        const a = t ? mV(s) : String(s).trim();
        a !== s && delete n[s], (n[a] = Ld(i)), (r[a] = !0);
      }),
      this
    );
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = Object.create(null);
    return (
      F.forEach(this, (r, i) => {
        r != null && r !== !1 && (n[i] = t && F.isArray(r) ? r.join(", ") : r);
      }),
      n
    );
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[C2] = this[C2] = { accessors: {} }).accessors,
      i = this.prototype;
    function s(o) {
      const a = pu(o);
      r[a] || (yV(i, o), (r[a] = !0));
    }
    return F.isArray(t) ? t.forEach(s) : s(t), this;
  }
}
Hp.accessor([
  "Content-Type",
  "Content-Length",
  "Accept",
  "Accept-Encoding",
  "User-Agent",
  "Authorization",
]);
F.reduceDescriptors(Hp.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    },
  };
});
F.freezeMethods(Hp);
const oi = Hp;
function o0(e, t) {
  const n = this || Dw,
    r = t || n,
    i = oi.from(r.headers);
  let s = r.data;
  return (
    F.forEach(e, function (a) {
      s = a.call(n, s, i.normalize(), t ? t.status : void 0);
    }),
    i.normalize(),
    s
  );
}
function xk(e) {
  return !!(e && e.__CANCEL__);
}
function Sl(e, t, n) {
  Se.call(this, e ?? "canceled", Se.ERR_CANCELED, t, n),
    (this.name = "CanceledError");
}
F.inherits(Sl, Se, { __CANCEL__: !0 });
function gV(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status)
    ? e(n)
    : t(
        new Se(
          "Request failed with status code " + n.status,
          [Se.ERR_BAD_REQUEST, Se.ERR_BAD_RESPONSE][
            Math.floor(n.status / 100) - 4
          ],
          n.config,
          n.request,
          n
        )
      );
}
const vV = Ir.hasStandardBrowserEnv
  ? {
      write(e, t, n, r, i, s) {
        const o = [e + "=" + encodeURIComponent(t)];
        F.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()),
          F.isString(r) && o.push("path=" + r),
          F.isString(i) && o.push("domain=" + i),
          s === !0 && o.push("secure"),
          (document.cookie = o.join("; "));
      },
      read(e) {
        const t = document.cookie.match(
          new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")
        );
        return t ? decodeURIComponent(t[3]) : null;
      },
      remove(e) {
        this.write(e, "", Date.now() - 864e5);
      },
    }
  : {
      write() {},
      read() {
        return null;
      },
      remove() {},
    };
function bV(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function wV(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function Sk(e, t) {
  return e && !bV(t) ? wV(e, t) : t;
}
const EV = Ir.hasStandardBrowserEnv
  ? (function () {
      const t = /(msie|trident)/i.test(navigator.userAgent),
        n = document.createElement("a");
      let r;
      function i(s) {
        let o = s;
        return (
          t && (n.setAttribute("href", o), (o = n.href)),
          n.setAttribute("href", o),
          {
            href: n.href,
            protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
            host: n.host,
            search: n.search ? n.search.replace(/^\?/, "") : "",
            hash: n.hash ? n.hash.replace(/^#/, "") : "",
            hostname: n.hostname,
            port: n.port,
            pathname:
              n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname,
          }
        );
      }
      return (
        (r = i(window.location.href)),
        function (o) {
          const a = F.isString(o) ? i(o) : o;
          return a.protocol === r.protocol && a.host === r.host;
        }
      );
    })()
  : (function () {
      return function () {
        return !0;
      };
    })();
function _V(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return (t && t[1]) || "";
}
function AV(e, t) {
  e = e || 10;
  const n = new Array(e),
    r = new Array(e);
  let i = 0,
    s = 0,
    o;
  return (
    (t = t !== void 0 ? t : 1e3),
    function (u) {
      const l = Date.now(),
        c = r[s];
      o || (o = l), (n[i] = u), (r[i] = l);
      let d = s,
        f = 0;
      for (; d !== i; ) (f += n[d++]), (d = d % e);
      if (((i = (i + 1) % e), i === s && (s = (s + 1) % e), l - o < t)) return;
      const p = c && l - c;
      return p ? Math.round((f * 1e3) / p) : void 0;
    }
  );
}
function T2(e, t) {
  let n = 0;
  const r = AV(50, 250);
  return (i) => {
    const s = i.loaded,
      o = i.lengthComputable ? i.total : void 0,
      a = s - n,
      u = r(a),
      l = s <= o;
    n = s;
    const c = {
      loaded: s,
      total: o,
      progress: o ? s / o : void 0,
      bytes: a,
      rate: u || void 0,
      estimated: u && o && l ? (o - s) / u : void 0,
      event: i,
    };
    (c[t ? "download" : "upload"] = !0), e(c);
  };
}
const xV = typeof XMLHttpRequest < "u",
  SV =
    xV &&
    function (e) {
      return new Promise(function (n, r) {
        let i = e.data;
        const s = oi.from(e.headers).normalize();
        let { responseType: o, withXSRFToken: a } = e,
          u;
        function l() {
          e.cancelToken && e.cancelToken.unsubscribe(u),
            e.signal && e.signal.removeEventListener("abort", u);
        }
        let c;
        if (F.isFormData(i)) {
          if (Ir.hasStandardBrowserEnv || Ir.hasStandardBrowserWebWorkerEnv)
            s.setContentType(!1);
          else if ((c = s.getContentType()) !== !1) {
            const [g, ...w] = c
              ? c
                  .split(";")
                  .map((v) => v.trim())
                  .filter(Boolean)
              : [];
            s.setContentType([g || "multipart/form-data", ...w].join("; "));
          }
        }
        let d = new XMLHttpRequest();
        if (e.auth) {
          const g = e.auth.username || "",
            w = e.auth.password
              ? unescape(encodeURIComponent(e.auth.password))
              : "";
          s.set("Authorization", "Basic " + btoa(g + ":" + w));
        }
        const f = Sk(e.baseURL, e.url);
        d.open(e.method.toUpperCase(), wk(f, e.params, e.paramsSerializer), !0),
          (d.timeout = e.timeout);
        function p() {
          if (!d) return;
          const g = oi.from(
              "getAllResponseHeaders" in d && d.getAllResponseHeaders()
            ),
            v = {
              data:
                !o || o === "text" || o === "json"
                  ? d.responseText
                  : d.response,
              status: d.status,
              statusText: d.statusText,
              headers: g,
              config: e,
              request: d,
            };
          gV(
            function (b) {
              n(b), l();
            },
            function (b) {
              r(b), l();
            },
            v
          ),
            (d = null);
        }
        if (
          ("onloadend" in d
            ? (d.onloadend = p)
            : (d.onreadystatechange = function () {
                !d ||
                  d.readyState !== 4 ||
                  (d.status === 0 &&
                    !(d.responseURL && d.responseURL.indexOf("file:") === 0)) ||
                  setTimeout(p);
              }),
          (d.onabort = function () {
            d &&
              (r(new Se("Request aborted", Se.ECONNABORTED, e, d)), (d = null));
          }),
          (d.onerror = function () {
            r(new Se("Network Error", Se.ERR_NETWORK, e, d)), (d = null);
          }),
          (d.ontimeout = function () {
            let w = e.timeout
              ? "timeout of " + e.timeout + "ms exceeded"
              : "timeout exceeded";
            const v = e.transitional || Ek;
            e.timeoutErrorMessage && (w = e.timeoutErrorMessage),
              r(
                new Se(
                  w,
                  v.clarifyTimeoutError ? Se.ETIMEDOUT : Se.ECONNABORTED,
                  e,
                  d
                )
              ),
              (d = null);
          }),
          Ir.hasStandardBrowserEnv &&
            (a && F.isFunction(a) && (a = a(e)), a || (a !== !1 && EV(f))))
        ) {
          const g =
            e.xsrfHeaderName && e.xsrfCookieName && vV.read(e.xsrfCookieName);
          g && s.set(e.xsrfHeaderName, g);
        }
        i === void 0 && s.setContentType(null),
          "setRequestHeader" in d &&
            F.forEach(s.toJSON(), function (w, v) {
              d.setRequestHeader(v, w);
            }),
          F.isUndefined(e.withCredentials) ||
            (d.withCredentials = !!e.withCredentials),
          o && o !== "json" && (d.responseType = e.responseType),
          typeof e.onDownloadProgress == "function" &&
            d.addEventListener("progress", T2(e.onDownloadProgress, !0)),
          typeof e.onUploadProgress == "function" &&
            d.upload &&
            d.upload.addEventListener("progress", T2(e.onUploadProgress)),
          (e.cancelToken || e.signal) &&
            ((u = (g) => {
              d &&
                (r(!g || g.type ? new Sl(null, e, d) : g),
                d.abort(),
                (d = null));
            }),
            e.cancelToken && e.cancelToken.subscribe(u),
            e.signal &&
              (e.signal.aborted ? u() : e.signal.addEventListener("abort", u)));
        const m = _V(f);
        if (m && Ir.protocols.indexOf(m) === -1) {
          r(new Se("Unsupported protocol " + m + ":", Se.ERR_BAD_REQUEST, e));
          return;
        }
        d.send(i || null);
      });
    },
  Ug = { http: KQ, xhr: SV };
F.forEach(Ug, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {}
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const I2 = (e) => `- ${e}`,
  CV = (e) => F.isFunction(e) || e === null || e === !1,
  Ck = {
    getAdapter: (e) => {
      e = F.isArray(e) ? e : [e];
      const { length: t } = e;
      let n, r;
      const i = {};
      for (let s = 0; s < t; s++) {
        n = e[s];
        let o;
        if (
          ((r = n),
          !CV(n) && ((r = Ug[(o = String(n)).toLowerCase()]), r === void 0))
        )
          throw new Se(`Unknown adapter '${o}'`);
        if (r) break;
        i[o || "#" + s] = r;
      }
      if (!r) {
        const s = Object.entries(i).map(
          ([a, u]) =>
            `adapter ${a} ` +
            (u === !1
              ? "is not supported by the environment"
              : "is not available in the build")
        );
        let o = t
          ? s.length > 1
            ? `since :
` +
              s.map(I2).join(`
`)
            : " " + I2(s[0])
          : "as no adapter specified";
        throw new Se(
          "There is no suitable adapter to dispatch the request " + o,
          "ERR_NOT_SUPPORT"
        );
      }
      return r;
    },
    adapters: Ug,
  };
function a0(e) {
  if (
    (e.cancelToken && e.cancelToken.throwIfRequested(),
    e.signal && e.signal.aborted)
  )
    throw new Sl(null, e);
}
function k2(e) {
  return (
    a0(e),
    (e.headers = oi.from(e.headers)),
    (e.data = o0.call(e, e.transformRequest)),
    ["post", "put", "patch"].indexOf(e.method) !== -1 &&
      e.headers.setContentType("application/x-www-form-urlencoded", !1),
    Ck.getAdapter(e.adapter || Dw.adapter)(e).then(
      function (r) {
        return (
          a0(e),
          (r.data = o0.call(e, e.transformResponse, r)),
          (r.headers = oi.from(r.headers)),
          r
        );
      },
      function (r) {
        return (
          xk(r) ||
            (a0(e),
            r &&
              r.response &&
              ((r.response.data = o0.call(e, e.transformResponse, r.response)),
              (r.response.headers = oi.from(r.response.headers)))),
          Promise.reject(r)
        );
      }
    )
  );
}
const P2 = (e) => (e instanceof oi ? e.toJSON() : e);
function Ra(e, t) {
  t = t || {};
  const n = {};
  function r(l, c, d) {
    return F.isPlainObject(l) && F.isPlainObject(c)
      ? F.merge.call({ caseless: d }, l, c)
      : F.isPlainObject(c)
      ? F.merge({}, c)
      : F.isArray(c)
      ? c.slice()
      : c;
  }
  function i(l, c, d) {
    if (F.isUndefined(c)) {
      if (!F.isUndefined(l)) return r(void 0, l, d);
    } else return r(l, c, d);
  }
  function s(l, c) {
    if (!F.isUndefined(c)) return r(void 0, c);
  }
  function o(l, c) {
    if (F.isUndefined(c)) {
      if (!F.isUndefined(l)) return r(void 0, l);
    } else return r(void 0, c);
  }
  function a(l, c, d) {
    if (d in t) return r(l, c);
    if (d in e) return r(void 0, l);
  }
  const u = {
    url: s,
    method: s,
    data: s,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: a,
    headers: (l, c) => i(P2(l), P2(c), !0),
  };
  return (
    F.forEach(Object.keys(Object.assign({}, e, t)), function (c) {
      const d = u[c] || i,
        f = d(e[c], t[c], c);
      (F.isUndefined(f) && d !== a) || (n[c] = f);
    }),
    n
  );
}
const Tk = "1.6.2",
  Ow = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(
  (e, t) => {
    Ow[e] = function (r) {
      return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
    };
  }
);
const D2 = {};
Ow.transitional = function (t, n, r) {
  function i(s, o) {
    return (
      "[Axios v" +
      Tk +
      "] Transitional option '" +
      s +
      "'" +
      o +
      (r ? ". " + r : "")
    );
  }
  return (s, o, a) => {
    if (t === !1)
      throw new Se(
        i(o, " has been removed" + (n ? " in " + n : "")),
        Se.ERR_DEPRECATED
      );
    return (
      n &&
        !D2[o] &&
        ((D2[o] = !0),
        console.warn(
          i(
            o,
            " has been deprecated since v" +
              n +
              " and will be removed in the near future"
          )
        )),
      t ? t(s, o, a) : !0
    );
  };
};
function TV(e, t, n) {
  if (typeof e != "object")
    throw new Se("options must be an object", Se.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const s = r[i],
      o = t[s];
    if (o) {
      const a = e[s],
        u = a === void 0 || o(a, s, e);
      if (u !== !0)
        throw new Se("option " + s + " must be " + u, Se.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0) throw new Se("Unknown option " + s, Se.ERR_BAD_OPTION);
  }
}
const $g = { assertOptions: TV, validators: Ow },
  Pi = $g.validators;
class vh {
  constructor(t) {
    (this.defaults = t),
      (this.interceptors = { request: new S2(), response: new S2() });
  }
  request(t, n) {
    typeof t == "string" ? ((n = n || {}), (n.url = t)) : (n = t || {}),
      (n = Ra(this.defaults, n));
    const { transitional: r, paramsSerializer: i, headers: s } = n;
    r !== void 0 &&
      $g.assertOptions(
        r,
        {
          silentJSONParsing: Pi.transitional(Pi.boolean),
          forcedJSONParsing: Pi.transitional(Pi.boolean),
          clarifyTimeoutError: Pi.transitional(Pi.boolean),
        },
        !1
      ),
      i != null &&
        (F.isFunction(i)
          ? (n.paramsSerializer = { serialize: i })
          : $g.assertOptions(
              i,
              { encode: Pi.function, serialize: Pi.function },
              !0
            )),
      (n.method = (n.method || this.defaults.method || "get").toLowerCase());
    let o = s && F.merge(s.common, s[n.method]);
    s &&
      F.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (m) => {
          delete s[m];
        }
      ),
      (n.headers = oi.concat(o, s));
    const a = [];
    let u = !0;
    this.interceptors.request.forEach(function (g) {
      (typeof g.runWhen == "function" && g.runWhen(n) === !1) ||
        ((u = u && g.synchronous), a.unshift(g.fulfilled, g.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function (g) {
      l.push(g.fulfilled, g.rejected);
    });
    let c,
      d = 0,
      f;
    if (!u) {
      const m = [k2.bind(this), void 0];
      for (
        m.unshift.apply(m, a),
          m.push.apply(m, l),
          f = m.length,
          c = Promise.resolve(n);
        d < f;

      )
        c = c.then(m[d++], m[d++]);
      return c;
    }
    f = a.length;
    let p = n;
    for (d = 0; d < f; ) {
      const m = a[d++],
        g = a[d++];
      try {
        p = m(p);
      } catch (w) {
        g.call(this, w);
        break;
      }
    }
    try {
      c = k2.call(this, p);
    } catch (m) {
      return Promise.reject(m);
    }
    for (d = 0, f = l.length; d < f; ) c = c.then(l[d++], l[d++]);
    return c;
  }
  getUri(t) {
    t = Ra(this.defaults, t);
    const n = Sk(t.baseURL, t.url);
    return wk(n, t.params, t.paramsSerializer);
  }
}
F.forEach(["delete", "get", "head", "options"], function (t) {
  vh.prototype[t] = function (n, r) {
    return this.request(
      Ra(r || {}, { method: t, url: n, data: (r || {}).data })
    );
  };
});
F.forEach(["post", "put", "patch"], function (t) {
  function n(r) {
    return function (s, o, a) {
      return this.request(
        Ra(a || {}, {
          method: t,
          headers: r ? { "Content-Type": "multipart/form-data" } : {},
          url: s,
          data: o,
        })
      );
    };
  }
  (vh.prototype[t] = n()), (vh.prototype[t + "Form"] = n(!0));
});
const Fd = vh;
class Rw {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function (s) {
      n = s;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let s = r._listeners.length;
      for (; s-- > 0; ) r._listeners[s](i);
      r._listeners = null;
    }),
      (this.promise.then = (i) => {
        let s;
        const o = new Promise((a) => {
          r.subscribe(a), (s = a);
        }).then(i);
        return (
          (o.cancel = function () {
            r.unsubscribe(s);
          }),
          o
        );
      }),
      t(function (s, o, a) {
        r.reason || ((r.reason = new Sl(s, o, a)), n(r.reason));
      });
  }
  throwIfRequested() {
    if (this.reason) throw this.reason;
  }
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : (this._listeners = [t]);
  }
  unsubscribe(t) {
    if (!this._listeners) return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  static source() {
    let t;
    return {
      token: new Rw(function (i) {
        t = i;
      }),
      cancel: t,
    };
  }
}
const IV = Rw;
function kV(e) {
  return function (n) {
    return e.apply(null, n);
  };
}
function PV(e) {
  return F.isObject(e) && e.isAxiosError === !0;
}
const Hg = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};
Object.entries(Hg).forEach(([e, t]) => {
  Hg[t] = e;
});
const DV = Hg;
function Ik(e) {
  const t = new Fd(e),
    n = uk(Fd.prototype.request, t);
  return (
    F.extend(n, Fd.prototype, t, { allOwnKeys: !0 }),
    F.extend(n, t, null, { allOwnKeys: !0 }),
    (n.create = function (i) {
      return Ik(Ra(e, i));
    }),
    n
  );
}
const dt = Ik(Dw);
dt.Axios = Fd;
dt.CanceledError = Sl;
dt.CancelToken = IV;
dt.isCancel = xk;
dt.VERSION = Tk;
dt.toFormData = $p;
dt.AxiosError = Se;
dt.Cancel = dt.CanceledError;
dt.all = function (t) {
  return Promise.all(t);
};
dt.spread = kV;
dt.isAxiosError = PV;
dt.mergeConfig = Ra;
dt.AxiosHeaders = oi;
dt.formToJSON = (e) => Ak(F.isHTMLForm(e) ? new FormData(e) : e);
dt.getAdapter = Ck.getAdapter;
dt.HttpStatusCode = DV;
dt.default = dt;
const OV = dt,
  qr = new Lp(BL),
  id = new qr.eth.Contract(Zy, nt == null ? void 0 : nt.Token),
  Su = new qr.eth.Contract(Jy, nt == null ? void 0 : nt.Staking),
  RV = async () => {
    const e = Sd[1].Token,
      t = "https://api.dexscreener.com",
      n = await OV.get(`${t}/latest/dex/tokens/${e}`);
    if (!n) return console.error("Error fetching token price"), 0;
    const r = n.data.pairs[0].priceUsd;
    return console.log(`Current price of the token: ${r}`), Number(r);
  },
  O2 = async (e, t, n) => {
    try {
      return BV(e, t, n);
    } catch (r) {
      return console.error("Error fetching transaction events:", r), null;
    }
  },
  BV = (e, t, n) => {
    const i = new e.eth.Contract(
      t,
      "0x0000000000000000000000000000000000000000"
    )._jsonInterface.filter((o) => o.type === "event");
    let s = [];
    for (const o of i) {
      const a = n.find((u) => u.topics[0] === o.signature);
      if (a) {
        const u = e.eth.abi.decodeLog(o.inputs, a.data, a.topics.slice(1));
        s = [...s, { ...u, name: o.name }];
      }
    }
    return s;
  },
  sd =
    "flex items-center justify-center flex flex-col gap-2 sm:flex-row sm:gap-0",
  od = "my-2 text-[16px] font-bold",
  u0 = "border-white border-solid border rounded-lg px-1",
  c0 =
    "border-white border-solid border rounded-lg w-[15rem] h-[3rem] focus:outline-none mx-2",
  NV = (e) => {
    const { address: t, isConnecting: n, isDisconnected: r } = QC(),
      [i, s] = G.useState(""),
      [o, a] = G.useState(0),
      [u, l] = G.useState(0),
      [c, d] = G.useState(0),
      [f, p] = G.useState(0),
      [m, g] = G.useState(-1),
      [w, v] = G.useState(!0),
      [y, b] = G.useState(!1),
      [_, A] = G.useState(0),
      [x, h] = G.useState(0),
      [E, I] = G.useState(0),
      C = 0.362,
      k = 61.231,
      O = 512.681,
      { data: R } = lL(),
      N = async (z, j, W, ee) => {
        try {
          const Z = await ethereum.request({
            method: "wallet_watchAsset",
            params: {
              type: "ERC20",
              options: { address: z, symbol: j, decimals: W },
            },
          });
          console.log(Z ? "Thanks for your interest!" : "Your loss!");
        } catch (Z) {
          console.log(Z);
        }
      };
    G.useEffect(() => {
      (async () => {
        await S();
        const j = await RV();
        h(j);
      })();
    }, []),
      G.useEffect(() => {
        let z = localStorage.getItem("connectedWallet");
        t && t !== z && localStorage.setItem("connectedWallet", t),
          (async () => {
            try {
              const W = await id.methods.balanceOf(nt.Staking).call(),
                ee = await Su.methods.getAllStakers().call();
              console.log("Stakers:", ee.length);
              for (let Z = 0; Z < ee.length; Z++) {
                const ne = await Su.methods.getStakeInfo(ee[Z]).call();
                console.log(
                  `Staker${Z}: ${ee[Z]}, Staked percent: ${
                    (Number(ne._stake) * 100) / Number(W)
                  } %`
                );
              }
            } catch (W) {
              console.error(W.message), d(0);
            }
          })();
      }, [t]),
      G.useEffect(() => {
        I(o == 0 || x == 0 ? 0 : ((O * 365) / (o * x)) * 100);
      }, [o, x]);
    const S = async () => {
        if (window.ethereum) {
          let z;
          const j = await id.methods.balanceOf(nt.Staking).call();
          (z = qr.utils.fromWei(j.toString(), nt.decimals)), a(Number(z));
          const W = await Su.methods.stakingPeriod().call();
          l(W);
          try {
            const Z = await Su.methods.getStakeInfo(t).call();
            (z = qr.utils.fromWei(Z._stake.toString(), nt.decimals)),
              d(Number(z)),
              p(Number(Z._lastStakedTime));
          } catch (Z) {
            console.error(Z.message), d(0), p(0);
          }
          const ee = await id.methods.balanceOf(t).call();
          (z = qr.utils.fromWei(ee.toString(), nt.decimals)), A(Number(z));
        } else window.web3 || (v(!1), b(!1));
      },
      T = (z) => {
        z.preventDefault(), s(z.target.value), D(z.target.value);
      },
      D = (z) => {
        s(z);
      },
      P = async () => {
        if (w)
          if (!i || i === "0" || i < 0) s("");
          else {
            b(!0);
            let z = qr.utils.toWei(i, nt.decimals);
            if ((await id.methods.allowance(t, nt.Staking).call()) < z) {
              const ne = await R.writeContract({
                  address: nt.Token,
                  abi: Zy,
                  functionName: "approve",
                  args: [nt.Staking, z],
                }),
                Ae = await vE({ hash: ne }),
                de = await O2(qr, Zy, Ae.logs);
              if (de && (de == null ? void 0 : de.length) > 0) {
                let ge = de[0];
                (ge == null ? void 0 : ge.name) === "Approval" &&
                  Fe.success(
                    "You've approved tokens successfully. We will continue excution."
                  );
              } else {
                Fe.error("Failed!"), b(!1);
                return;
              }
            }
            const W = await R.writeContract({
                address: nt.Staking,
                abi: Jy,
                functionName: "stake",
                args: [z],
              }),
              ee = await vE({ hash: W }),
              Z = await O2(qr, Jy, ee.logs);
            if (Z && (Z == null ? void 0 : Z.length) > 0) {
              let ne = Z[0];
              (ne == null ? void 0 : ne.name) === "Staked" &&
                (Fe.success("You've staked successfully."), S());
            } else Fe.error("Failed!");
            b(!1), s("");
          }
      },
      B = async () => {},
      L = async () => {},
      Q = () => {
        s(_), D(_);
      };
    return (
      setTimeout(() => {
        if (f === 0) {
          g(-1);
          return;
        }
        qr.eth
          .getBlockNumber()
          .then(async (z) => {
            const W = (await web3.eth.getBlock(z)).timestamp;
            console.log("Current block timestamp:", W), g(f + u - W);
          })
          .catch((z) => {
            console.error("Error:", z);
          });
      }, [15e3]),
      X.jsxs("div", {
        className: "relative mb-8",
        children: [
          X.jsx("div", {
            className: "absolute right-4 top-4",
            children: X.jsx(RL, {
              label: n ? "Connecting..." : r ? "Disconnected" : t || "Connect",
            }),
          }),
          X.jsx("img", {
            src: DL,
            alt: "logo",
            className: "h-28 mt-8 opacity-80",
          }),
          X.jsx("p", {
            className: "mt-5 text-[32px] font-bold",
            children: " MysticAI Staking ",
          }),
          X.jsxs("div", {
            className: "mt-12",
            children: [
              
              X.jsx("div", {
                className: sd,
                children: X.jsxs("p", {
                  className: od,
                  children: [" Daily Earning in USD: ", O, " "],
                }),
              }),
              X.jsx("div", {
                className: sd,
                children: X.jsxs("p", {
                  className: od,
                  children: [" Current APR: ", E.toFixed(3), " (%) "],
                }),
              }),
            ],
          }),
          X.jsx("div", {
            className: "flex justify-end pr-8",
            children: X.jsx("button", {
              className: u0,
              onClick: () => {
                Q();
              },
              children: "Max",
            }),
          }),
          X.jsx("div", {
            className: "mt-2 pb-2 align-center",
            children: X.jsx("input", {
              className:
                "w-11/12 h-12 rounded-lg border-none text-center text-black focus:outline-none focus:border focus:border-solid focus:border-blue-700",
              type: "number",
              min: "0",
              step: "1",
              onChange: T,
              value: i,
            }),
          }),
          X.jsxs("div", {
            className:
              "flex flex-col gap-2 sm:flex-row sm:gap-1 sm:justify-center",
            children: [
              X.jsxs("button", {
                className: `${c0} hover:bg-blue-600 self-center`,
                onClick: P,
                children: [
                  X.jsx("img", {
                    src: OL,
                    alt: "stake icon",
                    className: "h-[2rem] relative",
                  }),
                  X.jsx("p", {
                    className: "inline relative vertical-middle left-2",
                    children: "Stake",
                  }),
                ],
              }),
              X.jsxs("button", {
                className: `${c0} hover:bg-blue-800 self-center`,
                onClick: B,
                children: [
                  X.jsx("img", {
                    src: p_,
                    alt: "unstake icon",
                    className: "h-[2rem] relative",
                  }),
                  X.jsx("p", {
                    className: "inline relative vertical-middle left-2",
                    children: "Unstake",
                  }),
                ],
              }),
              X.jsxs("button", {
                className: `${c0} hover:bg-blue-900 self-center`,
                onClick: L,
                children: [
                  X.jsx("img", {
                    src: p_,
                    alt: "unstakeAll icon",
                    className: "h-[2rem] relative",
                  }),
                  X.jsx("p", {
                    className: "inline relative vertical-middle left-2",
                    children: "Unstake All",
                  }),
                ],
              }),
            ],
          }),
          X.jsxs("div", {
            className: "mt-12",
            children: [
              X.jsx("div", {
                children: X.jsxs("p", {
                  className: "text-[20px] font-bold",
                  children: [
                    "Total Staked (by all users):",
                    X.jsx("br", {}),
                    o.toFixed(3),
                    " ",
                    nt.name,
                    "(",
                    nt.symbol,
                    ") ($",
                    (o * x).toFixed(2),
                    ")",
                  ],
                }),
              }),
              X.jsxs("div", {
                className: "mt-4",
                children: [
                  X.jsxs("p", {
                    className: "text-[16px] font-bold",
                    children: [
                      "My Stake: ",
                      c.toFixed(3),
                      " ",
                      nt.name,
                      "(",
                      nt.symbol,
                      ") ($",
                      (c * x).toFixed(2),
                      ")",
                    ],
                  }),
                  m !== -1 &&
                    X.jsxs("p", {
                      className: "text-[16px] font-bold",
                      children: [
                        Math.floor(m / 86400),
                        " days ",
                        Math.floor((m % 86400) / 3600),
                        " hours ",
                        Math.floor((m % 3600) / 60),
                        " minutes remaining before unstake",
                      ],
                    }),
                ],
              }),
              X.jsx("div", {
                className: "mt-4",
                children: X.jsxs("p", {
                  className: "text-[16px] font-bold",
                  children: [
                    "My balance: ",
                    _.toFixed(3),
                    " ",
                    nt.name,
                    "(",
                    nt.symbol,
                    ") ($",
                    (_ * x).toFixed(2),
                    ")",
                  ],
                }),
              }),
            ],
          }),
        ],
      })
    );
  },
  MV = "_for_testing_1a63o_1",
  LV = "_network_1a63o_67",
  FV = "_inputDiv_1a63o_77",
  jV = "_input_1a63o_77",
  UV = { for_testing: MV, network: LV, inputDiv: FV, input: jV },
  $V = () => {
    fL();
    const [e, t] = G.useState(0);
    G.useEffect(() => {
      (async () => {
        n();
      })();
    }, []);
    const n = async () => {
      if (window.ethereum) {
        const r = await Su.methods.stakingPeriod().call();
        t(r.toString());
      } else window.web3 || setAppStatus(!1);
    };
    return X.jsx("div", {
      className: UV.for_testing,
      children: X.jsx("h4", { children: " Lock Up Period: 14 Days " }),
    });
  };
function HV() {
  const [e, t] = G.useState(!1),
    n = () => {
      window.scrollY > 0 ? t(!0) : t(!1);
    };
  return (
    G.useEffect(
      () => (
        window.addEventListener("scroll", n),
        () => {
          window.removeEventListener("scroll", n);
        }
      ),
      []
    ),
    X.jsxs(X.Fragment, {
      children: [
        X.jsx(PL, {
          fonts: [{ font: "Source Code Pro", weights: [400, 700] }],
        }),
        X.jsx("div", {
          className: "py-24 max-w-xl mx-auto",
          children: X.jsxs("div", {
            className: `bg-gradient-to-br from-[#0b1e3c] via-[#0a2549] to-[#082d5f] \r
            border-4 border-[#173c8b] \r
            bg-no-repeat \r
            bg-origin-padding bg-origin-border \r
            rounded-3xl \r
            text-center \r
            shadow-[#134b6370]`,
            children: [X.jsx(NV, {}), X.jsx($V, {})],
          }),
        }),
      ],
    })
  );
}
const Bw = [QS, VS],
  Nw = "ba78c8b0160b1370cc3f4b5a2d52dbf3",
  { publicClient: zV } = ZR(Bw, [c4({ projectId: Nw })]),
  kk = ZM({
    autoConnect: !0,
    connectors: l4({ projectId: Nw, chains: Bw }),
    publicClient: zV,
  }),
  GV = new o4(kk, Bw);
l0.createRoot(document.getElementById("root")).render(
  X.jsxs(X.Fragment, {
    children: [
      X.jsxs(JM, {
        config: kk,
        children: [
          X.jsx(HV, { className: "font-sans" }),
          X.jsx(Ky, { position: "top-left" }),
        ],
      }),
      X.jsx(J4, {
        projectId: Nw,
        ethereumClient: GV,
        themeMode: "dark",
        themeVariables: {
          "--w3m-font-family": "Source Code Pro, monospace",
          "--w3m-accent-color": "#",
          "--w3m-accent-fill-color": "#fff",
          "--w3m-background-color": "#",
          "--w3m-border-color": "#fff",
        },
      }),
    ],
  })
);
export {
  lK as $,
  qN as A,
  WN as B,
  hi as C,
  $N as D,
  GN as E,
  v4 as F,
  FN as G,
  uB as H,
  PN as I,
  ZB as J,
  cB as K,
  mC as L,
  KV as M,
  v8 as N,
  TN as O,
  Dm as P,
  RN as Q,
  R2 as R,
  np as S,
  Hb as T,
  pe as U,
  gr as V,
  Qo as W,
  Cu as X,
  Xc as Y,
  q as Z,
  qh as _,
  PO as a,
  Nh as a0,
  rn as a1,
  ns as a2,
  cc as a3,
  ND as a4,
  sl as a5,
  di as a6,
  Wh as a7,
  Mu as a8,
  Dr as a9,
  LE as aa,
  h4 as ab,
  Vr as b,
  zO as c,
  aK as d,
  qW as e,
  Sr as f,
  cK as g,
  GO as h,
  vt as i,
  qO as j,
  BS as k,
  kO as l,
  ZV as m,
  bd as n,
  JV as o,
  uK as p,
  _4 as q,
  YV as r,
  XV as s,
  eK as t,
  M4 as u,
  tK as v,
  nK as w,
  rK as x,
  iK as y,
  sK as z,
};
function __vite__mapDeps(indexes) {
  if (!__vite__mapDeps.viteFileDeps) {
    __vite__mapDeps.viteFileDeps = [
      "assets/index-0Vs2b2Km.js",
      "assets/if-defined-leStHEAq.js",
    ];
  }
  return indexes.map((i) => __vite__mapDeps.viteFileDeps[i]);
}
